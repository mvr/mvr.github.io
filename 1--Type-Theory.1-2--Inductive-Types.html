<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>1.2: Inductive Types - Introduction to Homotopy Type Theory in Cubical Agda</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/Agda.css">
        <link rel="stylesheet" href="theme/css/Agda-highlight.css">
        <link rel="stylesheet" href="theme/pagetoc.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Home</a></li><li class="chapter-item affix "><a href="INSTALLING_AGDA.html">Installing Agda</a></li><li class="chapter-item affix "><a href="USING_AGDA.html">Using Agda</a></li><li class="chapter-item affix "><li class="part-title">Type Theory</li><li class="chapter-item "><a href="1--Type-Theory.1-1--Types-and-Functions.html">1.1: Types and Functions</a></li><li class="chapter-item expanded "><a href="1--Type-Theory.1-2--Inductive-Types.html" class="active">1.2: Inductive Types</a></li><li class="chapter-item "><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html">1.3: Universes and More Inductive Types</a></li><li class="chapter-item "><a href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html">1.4: Record Types and Copatterns</a></li><li class="chapter-item "><a href="1--Type-Theory.1-5--Propositions-as-Types.html">1.5: Propositions as Types</a></li><li class="chapter-item affix "><li class="part-title">Paths and Identifications</li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-1--Paths.html">2.1: Paths</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html">2.2: Equivalences and Path Algebra</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html">2.3: Substitution and J</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html">2.4: Composition and Filling</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-5--Transport.html">2.5: Transport</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-6--Univalence.html">2.6: Univalence</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-7--Propositions.html">2.7: Propositions</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-8--Sets.html">2.8: Sets</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-9--Contractible-Maps.html">2.9: Contractible Maps</a></li><li class="chapter-item affix "><li class="part-title">Topics</li><li class="chapter-item "><a href="3--Topics.3-1--Structure-Identity-Principle.html">3.1: The Structure Identity Principle</a></li><li class="chapter-item "><a href="3--Topics.3-2--Modalities.html">3.2: Modalities</a></li><li class="chapter-item "><a href="3--Topics.3-3--Constructive-Logic.html">3.3: Constructive Logic</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="Library.Primitive.html">Primitives</a></li><li class="chapter-item affix "><a href="Library.Prelude.html">Prelude</a></li><li class="chapter-item affix "><a href="Library.Univalence.html">Univalence</a></li><li class="chapter-item affix "><a href="UNICODE_DICTIONARY.html">Unicode Dictionary</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="ACKNOWLEDGEMENTS.html">Acknowledgements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <!-- <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li> -->
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Homotopy Type Theory in Cubical Agda</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/CQTS/introduction-to-cubical" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                  <main>
                    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<!--
<pre class="Agda"><a id="10" class="Keyword">module</a> <a id="17" href="1--Type-Theory.1-2--Inductive-Types.html" class="Module">1--Type-Theory.1-2--Inductive-Types</a> <a id="53" class="Keyword">where</a>

<a id="60" class="Keyword">open</a> <a id="65" class="Keyword">import</a> <a id="72" href="Library.Prelude.html" class="Module">Library.Prelude</a>
</pre>-->
<h1 id="lecture-1-2-inductive-types"><a class="header" href="#lecture-1-2-inductive-types">Lecture 1-2: Inductive Types</a></h1>
<p>In the last lecture, we saw some abstract type theory. In this
lecture, we’ll get to define our own concrete data-types.</p>
<p>Agda’s data-types come in two flavours which are in some sense mirror
images of each other:</p>
<ul>
<li><strong>Inductive types</strong>: These include Booleans, natural numbers, lists,
more generally, anything which is specified by a set of options,
and where elements are specified by choosing between those options.</li>
<li><strong>Record types</strong>: These include product and Σ-types, more generally
anything where elements are specified by a set of fields, and where
elements are specified by choosing a value for each of those fields.</li>
</ul>
<p>In this Lecture we’ll see our first few examples of inductive types.
We’ll return to record types in Lecture 1-X.</p>
<h2 id="booleans"><a class="header" href="#booleans">Booleans</a></h2>
<p>An inductive type is a type whose elements are built up out of
“constructors”. Here is the inductive type of Booleans:</p>
<pre class="Agda"><a id="1017" class="Keyword">data</a> <a id="Bool"></a><a id="1022" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="1027" class="Symbol">:</a> <a id="1029" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="1034" class="Keyword">where</a>
  <a id="Bool.true"></a><a id="1042" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="1048" class="Symbol">:</a> <a id="1050" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
  <a id="Bool.false"></a><a id="1057" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="1063" class="Symbol">:</a> <a id="1065" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
</pre>
<p>This definition says that to construct a Boolean we either construct
it using <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a></code> or using <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a></code> — that is, a Boolean is either
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a></code> or <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a></code>.</p>
<p>What makes a data type “inductive” is its <em>induction principle</em>, a
process which is often called <em>case analysis</em>: “to use an element of
an inductive type, it suffices to split into cases for what we would
do for each of the constructors”. For example, we may define the
logical <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1637" class="Function">not</a></code> by saying what the result is in the case the Boolean
is <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a></code>, and in the case the Boolean is <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a></code>:</p>
<pre class="Agda"><a id="not"></a><a id="1637" href="1--Type-Theory.1-2--Inductive-Types.html#1637" class="Function">not</a> <a id="1641" class="Symbol">:</a> <a id="1643" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="1648" class="Symbol">→</a> <a id="1650" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="1655" href="1--Type-Theory.1-2--Inductive-Types.html#1637" class="Function">not</a> <a id="1659" href="1--Type-Theory.1-2--Inductive-Types.html#1659" class="Bound">b</a> <a id="1661" class="Symbol">=</a> <a id="1663" href="Library.Prelude.html#2398" class="Function Operator">case</a> <a id="1668" href="1--Type-Theory.1-2--Inductive-Types.html#1659" class="Bound">b</a> <a id="1670" href="Library.Prelude.html#2398" class="Function Operator">of</a> <a id="1673" class="Symbol">λ</a>
  <a id="1677" class="Symbol">{</a> <a id="1679" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="1685" class="Symbol">→</a> <a id="1687" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
  <a id="1695" class="Symbol">;</a> <a id="1697" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="1703" class="Symbol">→</a> <a id="1705" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
  <a id="1712" class="Symbol">}</a>
</pre>
<p>Here, the <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1637" class="Function">not</a></code> function accepts the argument <code>b</code> and then splits
into cases depending on which constructor of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> was used to
construct <code>b</code>.</p>
<div class="info">
<p><span class="info-label">Aside:</span>
Induction may seem like an odd name if you are used to “proof by
induction” from your discrete maths course, but we will see below that
the induction principle for <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code> is basically the mathematical
induction you are used to.</p>
</div>
<p>If we do case analysis on a <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> which is literally <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a></code> or
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a></code> rather than a variable or some other expression, then the
case analysis will disappear leaving the value of the appropriate
case. This is the <em>computation rule</em> for Booleans.</p>
<p>For example, normalising the expression <code>not false</code> leads to the case
analysis</p>
<pre class="Agda"><a id="2450" href="1--Type-Theory.1-2--Inductive-Types.html#2450" class="Function">_</a> <a id="2452" class="Symbol">=</a> <a id="2454" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a>

    <a id="2474" class="Symbol">(</a><a id="2475" href="Library.Prelude.html#2398" class="Function Operator">case</a> <a id="2480" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="2486" href="Library.Prelude.html#2398" class="Function Operator">of</a> <a id="2489" class="Symbol">λ</a>
      <a id="2497" class="Symbol">{</a> <a id="2499" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="2505" class="Symbol">→</a> <a id="2507" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
      <a id="2519" class="Symbol">;</a> <a id="2521" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="2527" class="Symbol">→</a> <a id="2529" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
    <a id="2538" class="Symbol">})</a>

    <a id="2546" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
</pre>
<p>which as you can see does compute to the value <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a></code>. (Remember you
can normalise any expression you want typing <code>C-c C-n</code> to test things.)</p>
<p>We can construct other functions by nesting this kind of case
analysis. Here’s one way we could write a Boolean <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#2836" class="Function">and</a></code>
operation:</p>
<pre class="Agda"><a id="_and_"></a><a id="2836" href="1--Type-Theory.1-2--Inductive-Types.html#2836" class="Function Operator">_and_</a> <a id="2842" class="Symbol">:</a> <a id="2844" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="2849" class="Symbol">→</a> <a id="2851" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="2856" class="Symbol">→</a> <a id="2858" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="2863" href="1--Type-Theory.1-2--Inductive-Types.html#2836" class="Function Operator">_and_</a> <a id="2869" href="1--Type-Theory.1-2--Inductive-Types.html#2869" class="Bound">x</a> <a id="2871" href="1--Type-Theory.1-2--Inductive-Types.html#2871" class="Bound">y</a> <a id="2873" class="Symbol">=</a> <a id="2875" href="Library.Prelude.html#2398" class="Function Operator">case</a> <a id="2880" href="1--Type-Theory.1-2--Inductive-Types.html#2869" class="Bound">x</a> <a id="2882" href="Library.Prelude.html#2398" class="Function Operator">of</a> <a id="2885" class="Symbol">λ</a>
  <a id="2889" class="Symbol">{</a> <a id="2891" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="2897" class="Symbol">→</a> <a id="2899" href="Library.Prelude.html#2398" class="Function Operator">case</a> <a id="2904" href="1--Type-Theory.1-2--Inductive-Types.html#2871" class="Bound">y</a> <a id="2906" href="Library.Prelude.html#2398" class="Function Operator">of</a> <a id="2909" class="Symbol">λ</a>
            <a id="2923" class="Symbol">{</a> <a id="2925" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="2931" class="Symbol">→</a> <a id="2933" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
            <a id="2950" class="Symbol">;</a> <a id="2952" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="2958" class="Symbol">→</a> <a id="2960" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="2966" class="Symbol">}</a>
  <a id="2970" class="Symbol">;</a> <a id="2972" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="2978" class="Symbol">→</a> <a id="2980" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
  <a id="2988" class="Symbol">}</a>

<a id="_xor_"></a><a id="2991" href="1--Type-Theory.1-2--Inductive-Types.html#2991" class="Function Operator">_xor_</a> <a id="2997" class="Symbol">:</a> <a id="2999" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="3004" class="Symbol">→</a> <a id="3006" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="3011" class="Symbol">→</a> <a id="3013" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="3018" class="Comment">-- Exercise:</a>
<a id="3031" class="Comment">-- x xor y = {!!}</a>
</pre><!--
<pre class="Agda"><a id="3062" href="1--Type-Theory.1-2--Inductive-Types.html#2991" class="Function Operator">_xor_</a> <a id="3068" href="1--Type-Theory.1-2--Inductive-Types.html#3068" class="Bound">x</a> <a id="3070" href="1--Type-Theory.1-2--Inductive-Types.html#3070" class="Bound">y</a> <a id="3072" class="Symbol">=</a> <a id="3074" href="Library.Prelude.html#2398" class="Function Operator">case</a> <a id="3079" href="1--Type-Theory.1-2--Inductive-Types.html#3068" class="Bound">x</a> <a id="3081" href="Library.Prelude.html#2398" class="Function Operator">of</a> <a id="3084" class="Symbol">λ</a>
  <a id="3088" class="Symbol">{</a> <a id="3090" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="3096" class="Symbol">→</a> <a id="3098" href="Library.Prelude.html#2398" class="Function Operator">case</a> <a id="3103" href="1--Type-Theory.1-2--Inductive-Types.html#3070" class="Bound">y</a> <a id="3105" href="Library.Prelude.html#2398" class="Function Operator">of</a> <a id="3108" class="Symbol">λ</a>
            <a id="3122" class="Symbol">{</a> <a id="3124" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="3130" class="Symbol">→</a> <a id="3132" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
            <a id="3150" class="Symbol">;</a> <a id="3152" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="3158" class="Symbol">→</a> <a id="3160" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="3165" class="Symbol">}</a>
  <a id="3169" class="Symbol">;</a> <a id="3171" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="3177" class="Symbol">→</a> <a id="3179" href="Library.Prelude.html#2398" class="Function Operator">case</a> <a id="3184" href="1--Type-Theory.1-2--Inductive-Types.html#3070" class="Bound">y</a> <a id="3186" href="Library.Prelude.html#2398" class="Function Operator">of</a> <a id="3189" class="Symbol">λ</a>
            <a id="3203" class="Symbol">{</a> <a id="3205" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="3211" class="Symbol">→</a> <a id="3213" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
            <a id="3230" class="Symbol">;</a> <a id="3232" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="3238" class="Symbol">→</a> <a id="3240" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="3246" class="Symbol">}</a>
  <a id="3250" class="Symbol">}</a>

</pre>-->
<p>Agda considers definitions with names that contain underscores
specially, and lets us use them in two ways: either literally like any
other definition, as in <code>_and_ x y</code>, or with the arguments taking the
place of the underscores, as in <code>x and y</code>. We will use infix operators
like this whenever it is closer to normal mathematical practice, as
with these Boolean operators, arithmetic operators like <code class="Agda"><a href="Library.Prelude.html#3757" class="Function"><em>·</em></a></code>,
pairing <code class="Agda"><a href="Library.Prelude.html#1090" class="InductiveConstructor"><em>,</em></a></code>, etc.</p>
<p>It is not required to do case analysis on all the variables that are
available. Try giving a definition of the logical “or” by case
analysis only on the variable <code>x</code>.</p>
<pre class="Agda"><a id="_or_"></a><a id="3873" href="1--Type-Theory.1-2--Inductive-Types.html#3873" class="Function Operator">_or_</a> <a id="3878" class="Symbol">:</a> <a id="3880" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="3885" class="Symbol">→</a> <a id="3887" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="3892" class="Symbol">→</a> <a id="3894" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="3899" class="Comment">-- Exercise:</a>
<a id="3912" class="Comment">-- x or y = {!!}</a>
</pre><!--
<pre class="Agda"><a id="3942" href="1--Type-Theory.1-2--Inductive-Types.html#3942" class="Bound">x</a> <a id="3944" href="1--Type-Theory.1-2--Inductive-Types.html#3873" class="Function Operator">or</a> <a id="3947" href="1--Type-Theory.1-2--Inductive-Types.html#3947" class="Bound">y</a> <a id="3949" class="Symbol">=</a> <a id="3951" href="Library.Prelude.html#2398" class="Function Operator">case</a> <a id="3956" href="1--Type-Theory.1-2--Inductive-Types.html#3942" class="Bound">x</a> <a id="3958" href="Library.Prelude.html#2398" class="Function Operator">of</a> <a id="3961" class="Symbol">λ</a>
  <a id="3965" class="Symbol">{</a> <a id="3967" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="3973" class="Symbol">→</a> <a id="3975" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
  <a id="3982" class="Symbol">;</a> <a id="3984" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="3990" class="Symbol">→</a> <a id="3992" href="1--Type-Theory.1-2--Inductive-Types.html#3947" class="Bound">y</a>
  <a id="3996" class="Symbol">}</a>

</pre>-->
<div class="info">
<p><span class="info-label">Aside:</span>
The different choices for how we do case analysis in a definition can
result in different computational behaviour. For example, with the
above definition of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#3873" class="Function">or</a></code>, the expression <code>true or y</code> will compute to
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a></code> and <code>false or y</code> will compute to <code>y</code>, but <code>x or true</code> and <code>x or false</code> will both be stuck waiting for the value of <code>x</code> to do case
analysis on.</p>
<pre class="Agda"><a id="4392" href="1--Type-Theory.1-2--Inductive-Types.html#4392" class="Function">_</a> <a id="4394" class="Symbol">=</a> <a id="4396" class="Symbol">λ</a> <a id="4398" class="Symbol">(</a><a id="4399" href="1--Type-Theory.1-2--Inductive-Types.html#4399" class="Bound">y</a> <a id="4401" class="Symbol">:</a> <a id="4403" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="4407" class="Symbol">)</a> <a id="4409" class="Symbol">→</a> <a id="4411" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="4426" class="Symbol">(</a><a id="4427" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="4432" href="1--Type-Theory.1-2--Inductive-Types.html#3873" class="Function Operator">or</a> <a id="4435" href="1--Type-Theory.1-2--Inductive-Types.html#4399" class="Bound">y</a><a id="4436" class="Symbol">)</a> <a id="4438" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
<a id="4443" href="1--Type-Theory.1-2--Inductive-Types.html#4443" class="Function">_</a> <a id="4445" class="Symbol">=</a> <a id="4447" class="Symbol">λ</a> <a id="4449" class="Symbol">(</a><a id="4450" href="1--Type-Theory.1-2--Inductive-Types.html#4450" class="Bound">y</a> <a id="4452" class="Symbol">:</a> <a id="4454" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="4458" class="Symbol">)</a> <a id="4460" class="Symbol">→</a> <a id="4462" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="4477" class="Symbol">(</a><a id="4478" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="4484" href="1--Type-Theory.1-2--Inductive-Types.html#3873" class="Function Operator">or</a> <a id="4487" href="1--Type-Theory.1-2--Inductive-Types.html#4450" class="Bound">y</a><a id="4488" class="Symbol">)</a> <a id="4490" href="1--Type-Theory.1-2--Inductive-Types.html#4450" class="Bound">y</a>
<a id="4492" class="Comment">-- Won&#39;t work:</a>
<a id="4507" class="Comment">-- _ = λ (x : Bool) → test-identical (x or true) true</a>
<a id="4561" class="Comment">-- _ = λ (x : Bool) → test-identical (x or false) x</a>
</pre>
</div>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>In all the above definitions we accept some elements of an inductive
type as arguments and then immediately split into cases. This is
overwhelmingly the most common situation when working with inductive
types, so Agda gives us some pleasant syntax for it. Rather than
writing definitions with variable names on the left of the <code>=</code> sign,
we can write multiple lines of definition, one for each possible
constructor that could occur in that position.</p>
<pre class="Agda"><a id="not&#39;"></a><a id="5098" href="1--Type-Theory.1-2--Inductive-Types.html#5098" class="Function">not&#39;</a> <a id="5103" class="Symbol">:</a> <a id="5105" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="5110" class="Symbol">→</a> <a id="5112" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="5117" href="1--Type-Theory.1-2--Inductive-Types.html#5098" class="Function">not&#39;</a> <a id="5122" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="5128" class="Symbol">=</a> <a id="5130" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
<a id="5136" href="1--Type-Theory.1-2--Inductive-Types.html#5098" class="Function">not&#39;</a> <a id="5141" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="5147" class="Symbol">=</a> <a id="5149" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>

<a id="_and&#39;_"></a><a id="5155" href="1--Type-Theory.1-2--Inductive-Types.html#5155" class="Function Operator">_and&#39;_</a> <a id="5162" class="Symbol">:</a> <a id="5164" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="5169" class="Symbol">→</a> <a id="5171" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="5176" class="Symbol">→</a> <a id="5178" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="5183" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="5189" href="1--Type-Theory.1-2--Inductive-Types.html#5155" class="Function Operator">and&#39;</a> <a id="5194" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="5200" class="Symbol">=</a> <a id="5202" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
<a id="5207" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="5213" href="1--Type-Theory.1-2--Inductive-Types.html#5155" class="Function Operator">and&#39;</a> <a id="5218" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="5224" class="Symbol">=</a> <a id="5226" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
<a id="5232" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="5238" href="1--Type-Theory.1-2--Inductive-Types.html#5155" class="Function Operator">and&#39;</a> <a id="5243" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="5249" class="Symbol">=</a> <a id="5251" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
<a id="5257" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="5263" href="1--Type-Theory.1-2--Inductive-Types.html#5155" class="Function Operator">and&#39;</a> <a id="5268" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="5274" class="Symbol">=</a> <a id="5276" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
</pre>
<p>Although there are multiple <code>=</code> signs, all of them together constitute
a single definition. Agda uses a mechanism called “coverage checking”
to make sure that every case is covered by your definition, and will
complain if you missed something. If desired, it is always possible to
rewrite such a definition as a single expression that does the
case-splitting manually.</p>
<p>The method of writing functions where we describe what they do on
particular forms of their input is called <em>pattern matching</em>. We
already saw an example of this in the previous lecture when writing
functions with pairs as arguments. Agda has nice support for working
with pattern matching — it can automatically write out all the cases
that are needed to define a function involving an inductive type. To
have Agda do this for you, place your cursor in a hole and press <code>C-c C-c</code>. You will be prompted for the list of variables separated by
spaces that you want to apply case-splitting to.</p>
<p>Try this below: press <code>C-c C-c</code> in the hole for <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#6411" class="Function"><em>xor’</em></a></code> below and
enter <code>x y</code> to have Agda split this definition into all the cases you
need to handle.</p>
<pre class="Agda"><a id="_xor&#39;_"></a><a id="6411" href="1--Type-Theory.1-2--Inductive-Types.html#6411" class="Function Operator">_xor&#39;_</a> <a id="6418" class="Symbol">:</a> <a id="6420" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="6425" class="Symbol">→</a> <a id="6427" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="6432" class="Symbol">→</a> <a id="6434" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="6439" class="Comment">-- Exercise:</a>
<a id="6452" class="Comment">-- x xor&#39; y = {!!}</a>
</pre><!--
<pre class="Agda"><a id="6484" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="6489" href="1--Type-Theory.1-2--Inductive-Types.html#6411" class="Function Operator">xor&#39;</a> <a id="6494" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="6499" class="Symbol">=</a> <a id="6501" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
<a id="6507" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="6512" href="1--Type-Theory.1-2--Inductive-Types.html#6411" class="Function Operator">xor&#39;</a> <a id="6517" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="6523" class="Symbol">=</a> <a id="6525" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
<a id="6530" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="6536" href="1--Type-Theory.1-2--Inductive-Types.html#6411" class="Function Operator">xor&#39;</a> <a id="6541" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="6546" class="Symbol">=</a> <a id="6548" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
<a id="6553" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="6559" href="1--Type-Theory.1-2--Inductive-Types.html#6411" class="Function Operator">xor&#39;</a> <a id="6564" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="6570" class="Symbol">=</a> <a id="6572" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>

</pre>-->
<p>As before, we don’t necessarily have to to case-split on all the
variables. Try leaving <code>y</code> un-split as you did in the first definition
of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#3873" class="Function">or</a></code>.</p>
<pre class="Agda"><a id="_or&#39;_"></a><a id="6748" href="1--Type-Theory.1-2--Inductive-Types.html#6748" class="Function Operator">_or&#39;_</a> <a id="6754" class="Symbol">:</a> <a id="6756" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="6761" class="Symbol">→</a> <a id="6763" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="6768" class="Symbol">→</a> <a id="6770" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="6775" class="Comment">-- Exercise:</a>
<a id="6788" class="Comment">-- x or&#39; y = {!!}</a>
</pre><!--
<pre class="Agda"><a id="6819" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="6824" href="1--Type-Theory.1-2--Inductive-Types.html#6748" class="Function Operator">or&#39;</a> <a id="6828" href="1--Type-Theory.1-2--Inductive-Types.html#6828" class="Bound">y</a> <a id="6830" class="Symbol">=</a> <a id="6832" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
<a id="6837" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="6843" href="1--Type-Theory.1-2--Inductive-Types.html#6748" class="Function Operator">or&#39;</a> <a id="6847" href="1--Type-Theory.1-2--Inductive-Types.html#6847" class="Bound">y</a> <a id="6849" class="Symbol">=</a> <a id="6851" href="1--Type-Theory.1-2--Inductive-Types.html#6847" class="Bound">y</a>

</pre>-->
<p>Here is the definition of logical implication. There is a strange
feature of this definition which has a Latin name: “ex falso
quodlibet” — <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a></code> implies anything.</p>
<pre class="Agda"><a id="_implies_"></a><a id="7046" href="1--Type-Theory.1-2--Inductive-Types.html#7046" class="Function Operator">_implies_</a> <a id="7056" class="Symbol">:</a> <a id="7058" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="7063" class="Symbol">→</a> <a id="7065" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="7070" class="Symbol">→</a> <a id="7072" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="7077" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="7083" href="1--Type-Theory.1-2--Inductive-Types.html#7046" class="Function Operator">implies</a> <a id="7091" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="7097" class="Symbol">=</a> <a id="7099" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
<a id="7104" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="7110" href="1--Type-Theory.1-2--Inductive-Types.html#7046" class="Function Operator">implies</a> <a id="7118" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="7124" class="Symbol">=</a> <a id="7126" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
<a id="7132" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="7138" href="1--Type-Theory.1-2--Inductive-Types.html#7046" class="Function Operator">implies</a> <a id="7146" class="Symbol">_</a>     <a id="7152" class="Symbol">=</a> <a id="7154" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
</pre>
<p>Here we use a “wildcard” argument (the underscore <code>_</code>) to say that the
definition we are giving is valid for anything we put in that spot, so
we don’t have to bother giving the variable a name at all.</p>
<p>There is nothing special about <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> having exactly two
constructors, we can just as well define a type with seven elements:</p>
<pre class="Agda"><a id="7499" class="Keyword">data</a> <a id="Day"></a><a id="7504" href="1--Type-Theory.1-2--Inductive-Types.html#7504" class="Datatype">Day</a> <a id="7508" class="Symbol">:</a> <a id="7510" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="7515" class="Keyword">where</a>
  <a id="Day.monday"></a><a id="7523" href="1--Type-Theory.1-2--Inductive-Types.html#7523" class="InductiveConstructor">monday</a>    <a id="7533" class="Symbol">:</a> <a id="7535" href="1--Type-Theory.1-2--Inductive-Types.html#7504" class="Datatype">Day</a>
  <a id="Day.tuesday"></a><a id="7541" href="1--Type-Theory.1-2--Inductive-Types.html#7541" class="InductiveConstructor">tuesday</a>   <a id="7551" class="Symbol">:</a> <a id="7553" href="1--Type-Theory.1-2--Inductive-Types.html#7504" class="Datatype">Day</a>
  <a id="Day.wednesday"></a><a id="7559" href="1--Type-Theory.1-2--Inductive-Types.html#7559" class="InductiveConstructor">wednesday</a> <a id="7569" class="Symbol">:</a> <a id="7571" href="1--Type-Theory.1-2--Inductive-Types.html#7504" class="Datatype">Day</a>
  <a id="Day.thursday"></a><a id="7577" href="1--Type-Theory.1-2--Inductive-Types.html#7577" class="InductiveConstructor">thursday</a>  <a id="7587" class="Symbol">:</a> <a id="7589" href="1--Type-Theory.1-2--Inductive-Types.html#7504" class="Datatype">Day</a>
  <a id="Day.friday"></a><a id="7595" href="1--Type-Theory.1-2--Inductive-Types.html#7595" class="InductiveConstructor">friday</a>    <a id="7605" class="Symbol">:</a> <a id="7607" href="1--Type-Theory.1-2--Inductive-Types.html#7504" class="Datatype">Day</a>
  <a id="Day.saturday"></a><a id="7613" href="1--Type-Theory.1-2--Inductive-Types.html#7613" class="InductiveConstructor">saturday</a>  <a id="7623" class="Symbol">:</a> <a id="7625" href="1--Type-Theory.1-2--Inductive-Types.html#7504" class="Datatype">Day</a>
  <a id="Day.sunday"></a><a id="7631" href="1--Type-Theory.1-2--Inductive-Types.html#7631" class="InductiveConstructor">sunday</a>    <a id="7641" class="Symbol">:</a> <a id="7643" href="1--Type-Theory.1-2--Inductive-Types.html#7504" class="Datatype">Day</a>
</pre>
<p>And define functions out of it by providing cases for each of the
constructors:</p>
<pre class="Agda"><a id="isWeekend"></a><a id="7737" href="1--Type-Theory.1-2--Inductive-Types.html#7737" class="Function">isWeekend</a> <a id="7747" class="Symbol">:</a> <a id="7749" href="1--Type-Theory.1-2--Inductive-Types.html#7504" class="Datatype">Day</a> <a id="7753" class="Symbol">→</a> <a id="7755" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="7760" href="1--Type-Theory.1-2--Inductive-Types.html#7737" class="Function">isWeekend</a> <a id="7770" href="1--Type-Theory.1-2--Inductive-Types.html#7523" class="InductiveConstructor">monday</a>    <a id="7780" class="Symbol">=</a> <a id="7782" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
<a id="7788" href="1--Type-Theory.1-2--Inductive-Types.html#7737" class="Function">isWeekend</a> <a id="7798" href="1--Type-Theory.1-2--Inductive-Types.html#7541" class="InductiveConstructor">tuesday</a>   <a id="7808" class="Symbol">=</a> <a id="7810" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
<a id="7816" href="1--Type-Theory.1-2--Inductive-Types.html#7737" class="Function">isWeekend</a> <a id="7826" href="1--Type-Theory.1-2--Inductive-Types.html#7559" class="InductiveConstructor">wednesday</a> <a id="7836" class="Symbol">=</a> <a id="7838" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
<a id="7844" href="1--Type-Theory.1-2--Inductive-Types.html#7737" class="Function">isWeekend</a> <a id="7854" href="1--Type-Theory.1-2--Inductive-Types.html#7577" class="InductiveConstructor">thursday</a>  <a id="7864" class="Symbol">=</a> <a id="7866" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
<a id="7872" href="1--Type-Theory.1-2--Inductive-Types.html#7737" class="Function">isWeekend</a> <a id="7882" href="1--Type-Theory.1-2--Inductive-Types.html#7595" class="InductiveConstructor">friday</a>    <a id="7892" class="Symbol">=</a> <a id="7894" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
<a id="7900" href="1--Type-Theory.1-2--Inductive-Types.html#7737" class="Function">isWeekend</a> <a id="7910" href="1--Type-Theory.1-2--Inductive-Types.html#7613" class="InductiveConstructor">saturday</a>  <a id="7920" class="Symbol">=</a> <a id="7922" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
<a id="7927" href="1--Type-Theory.1-2--Inductive-Types.html#7737" class="Function">isWeekend</a> <a id="7937" href="1--Type-Theory.1-2--Inductive-Types.html#7631" class="InductiveConstructor">sunday</a>    <a id="7947" class="Symbol">=</a> <a id="7949" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>

<a id="nextDay"></a><a id="7955" href="1--Type-Theory.1-2--Inductive-Types.html#7955" class="Function">nextDay</a> <a id="7963" class="Symbol">:</a> <a id="7965" href="1--Type-Theory.1-2--Inductive-Types.html#7504" class="Datatype">Day</a> <a id="7969" class="Symbol">→</a> <a id="7971" href="1--Type-Theory.1-2--Inductive-Types.html#7504" class="Datatype">Day</a>
<a id="7975" class="Comment">-- Exercise:</a>
<a id="7988" class="Comment">-- nextDay c = {!!}</a>
</pre><!--
<pre class="Agda"><a id="8021" href="1--Type-Theory.1-2--Inductive-Types.html#7955" class="Function">nextDay</a> <a id="8029" href="1--Type-Theory.1-2--Inductive-Types.html#7523" class="InductiveConstructor">monday</a>    <a id="8039" class="Symbol">=</a> <a id="8041" href="1--Type-Theory.1-2--Inductive-Types.html#7541" class="InductiveConstructor">tuesday</a>
<a id="8049" href="1--Type-Theory.1-2--Inductive-Types.html#7955" class="Function">nextDay</a> <a id="8057" href="1--Type-Theory.1-2--Inductive-Types.html#7541" class="InductiveConstructor">tuesday</a>   <a id="8067" class="Symbol">=</a> <a id="8069" href="1--Type-Theory.1-2--Inductive-Types.html#7559" class="InductiveConstructor">wednesday</a>
<a id="8079" href="1--Type-Theory.1-2--Inductive-Types.html#7955" class="Function">nextDay</a> <a id="8087" href="1--Type-Theory.1-2--Inductive-Types.html#7559" class="InductiveConstructor">wednesday</a> <a id="8097" class="Symbol">=</a> <a id="8099" href="1--Type-Theory.1-2--Inductive-Types.html#7577" class="InductiveConstructor">thursday</a>
<a id="8108" href="1--Type-Theory.1-2--Inductive-Types.html#7955" class="Function">nextDay</a> <a id="8116" href="1--Type-Theory.1-2--Inductive-Types.html#7577" class="InductiveConstructor">thursday</a>  <a id="8126" class="Symbol">=</a> <a id="8128" href="1--Type-Theory.1-2--Inductive-Types.html#7595" class="InductiveConstructor">friday</a>
<a id="8135" href="1--Type-Theory.1-2--Inductive-Types.html#7955" class="Function">nextDay</a> <a id="8143" href="1--Type-Theory.1-2--Inductive-Types.html#7595" class="InductiveConstructor">friday</a>    <a id="8153" class="Symbol">=</a> <a id="8155" href="1--Type-Theory.1-2--Inductive-Types.html#7613" class="InductiveConstructor">saturday</a>
<a id="8164" href="1--Type-Theory.1-2--Inductive-Types.html#7955" class="Function">nextDay</a> <a id="8172" href="1--Type-Theory.1-2--Inductive-Types.html#7613" class="InductiveConstructor">saturday</a>  <a id="8182" class="Symbol">=</a> <a id="8184" href="1--Type-Theory.1-2--Inductive-Types.html#7631" class="InductiveConstructor">sunday</a>
<a id="8191" href="1--Type-Theory.1-2--Inductive-Types.html#7955" class="Function">nextDay</a> <a id="8199" href="1--Type-Theory.1-2--Inductive-Types.html#7631" class="InductiveConstructor">sunday</a>    <a id="8209" class="Symbol">=</a> <a id="8211" href="1--Type-Theory.1-2--Inductive-Types.html#7523" class="InductiveConstructor">monday</a>

</pre>-->
<h2 id="the-unit"><a class="header" href="#the-unit">The Unit</a></h2>
<p><code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> is a simple data type, but it isn’t the simplest. We can
use even fewer constructors. With one constructor, we have the unit
type <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a></code>, with its unique element <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a></code>:</p>
<pre class="Agda"><a id="8433" class="Keyword">data</a> <a id="⊤"></a><a id="8438" href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a> <a id="8440" class="Symbol">:</a> <a id="8442" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="8447" class="Keyword">where</a>
  <a id="⊤.tt"></a><a id="8455" href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a> <a id="8458" class="Symbol">:</a> <a id="8460" href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a>
</pre>
<p>To define a function <code>⊤ → A</code>, we just have to say what it does on the
constructor <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a></code>. This is so simple that it is difficult to
come up with interesting examples.</p>
<pre class="Agda"><a id="pick-true"></a><a id="8639" href="1--Type-Theory.1-2--Inductive-Types.html#8639" class="Function">pick-true</a> <a id="8649" class="Symbol">:</a> <a id="8651" href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a> <a id="8653" class="Symbol">→</a> <a id="8655" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="8660" href="1--Type-Theory.1-2--Inductive-Types.html#8639" class="Function">pick-true</a> <a id="8670" href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a> <a id="8673" class="Symbol">=</a> <a id="8675" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>

<a id="ignore-bool"></a><a id="8681" href="1--Type-Theory.1-2--Inductive-Types.html#8681" class="Function">ignore-bool</a> <a id="8693" class="Symbol">:</a> <a id="8695" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="8700" class="Symbol">→</a> <a id="8702" href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a>
<a id="8704" href="1--Type-Theory.1-2--Inductive-Types.html#8681" class="Function">ignore-bool</a> <a id="8716" href="1--Type-Theory.1-2--Inductive-Types.html#8716" class="Bound">b</a> <a id="8718" class="Symbol">=</a> <a id="8720" href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a>
</pre>
<p>Because <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a></code> contains no information, maps into <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a></code> provide no
information either.</p>
<pre class="Agda"><a id="⊤-ump-in-to"></a><a id="8819" href="1--Type-Theory.1-2--Inductive-Types.html#8819" class="Function">⊤-ump-in-to</a> <a id="8831" class="Symbol">:</a> <a id="8833" class="Symbol">{</a><a id="8834" href="1--Type-Theory.1-2--Inductive-Types.html#8834" class="Bound">A</a> <a id="8836" class="Symbol">:</a> <a id="8838" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="8842" class="Symbol">}</a>
  <a id="8846" class="Symbol">→</a> <a id="8848" href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a>
  <a id="8852" class="Symbol">→</a> <a id="8854" class="Symbol">(</a><a id="8855" href="1--Type-Theory.1-2--Inductive-Types.html#8834" class="Bound">A</a> <a id="8857" class="Symbol">→</a> <a id="8859" href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a><a id="8860" class="Symbol">)</a>
<a id="8862" class="Comment">-- Exercise:</a>
<a id="8875" class="Comment">-- ⊤-ump-in-to t = {!!}</a>
</pre><!--
<pre class="Agda"><a id="8912" href="1--Type-Theory.1-2--Inductive-Types.html#8819" class="Function">⊤-ump-in-to</a> <a id="8924" href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a> <a id="8927" class="Symbol">=</a> <a id="8929" class="Symbol">λ</a> <a id="8931" href="1--Type-Theory.1-2--Inductive-Types.html#8931" class="Bound">a</a> <a id="8933" class="Symbol">→</a> <a id="8935" href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a>

</pre>-->
<pre class="Agda">
<a id="⊤-ump-in-fro"></a><a id="8952" href="1--Type-Theory.1-2--Inductive-Types.html#8952" class="Function">⊤-ump-in-fro</a> <a id="8965" class="Symbol">:</a> <a id="8967" class="Symbol">{</a><a id="8968" href="1--Type-Theory.1-2--Inductive-Types.html#8968" class="Bound">A</a> <a id="8970" class="Symbol">:</a> <a id="8972" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="8976" class="Symbol">}</a>
  <a id="8980" class="Symbol">→</a> <a id="8982" class="Symbol">(</a><a id="8983" href="1--Type-Theory.1-2--Inductive-Types.html#8968" class="Bound">A</a> <a id="8985" class="Symbol">→</a> <a id="8987" href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a><a id="8988" class="Symbol">)</a>
  <a id="8992" class="Symbol">→</a> <a id="8994" href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a>
<a id="8996" class="Comment">-- Exercise:</a>
<a id="9009" class="Comment">-- ⊤-ump-in-fro f = {!!}</a>
</pre><!--
<pre class="Agda"><a id="9047" href="1--Type-Theory.1-2--Inductive-Types.html#8952" class="Function">⊤-ump-in-fro</a> <a id="9060" href="1--Type-Theory.1-2--Inductive-Types.html#9060" class="Bound">f</a> <a id="9062" class="Symbol">=</a> <a id="9064" href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a>

</pre>-->
<p>These two functions constitute the universal “mapping-in” property of
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a></code>, like the one that we saw for <code class="Agda"><a href="Library.Prelude.html#1692" class="Function">×</a></code> in <code class="Agda"><a href="1--Type-Theory.1-1--Types-and-Functions.html#21853" class="Function">×-ump-to</a></code> and
<code class="Agda"><a href="1--Type-Theory.1-1--Types-and-Functions.html#22192" class="Function">×-ump-fro</a></code>.</p>
<p><code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a></code> is a little unusual, in that it also has a universal
“mapping-<em>out</em>” property, which says that maps out of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a></code> just pick
an element of the output type.</p>
<pre class="Agda"><a id="⊤-ump-out-to"></a><a id="9398" href="1--Type-Theory.1-2--Inductive-Types.html#9398" class="Function">⊤-ump-out-to</a> <a id="9411" class="Symbol">:</a> <a id="9413" class="Symbol">{</a><a id="9414" href="1--Type-Theory.1-2--Inductive-Types.html#9414" class="Bound">A</a> <a id="9416" class="Symbol">:</a> <a id="9418" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="9422" class="Symbol">}</a>
  <a id="9426" class="Symbol">→</a> <a id="9428" href="1--Type-Theory.1-2--Inductive-Types.html#9414" class="Bound">A</a>
  <a id="9432" class="Symbol">→</a> <a id="9434" class="Symbol">(</a><a id="9435" href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a> <a id="9437" class="Symbol">→</a> <a id="9439" href="1--Type-Theory.1-2--Inductive-Types.html#9414" class="Bound">A</a><a id="9440" class="Symbol">)</a>
<a id="9442" class="Comment">-- Exercise:</a>
<a id="9455" class="Comment">-- ⊤-ump-out-to t = {!!}</a>
</pre><!--
<pre class="Agda"><a id="9493" href="1--Type-Theory.1-2--Inductive-Types.html#9398" class="Function">⊤-ump-out-to</a> <a id="9506" href="1--Type-Theory.1-2--Inductive-Types.html#9506" class="Bound">a</a> <a id="9508" class="Symbol">=</a> <a id="9510" class="Symbol">λ</a> <a id="9512" href="1--Type-Theory.1-2--Inductive-Types.html#9512" class="Bound">_</a> <a id="9514" class="Symbol">→</a> <a id="9516" href="1--Type-Theory.1-2--Inductive-Types.html#9506" class="Bound">a</a>

</pre>-->
<pre class="Agda">
<a id="⊤-ump-out-fro"></a><a id="9532" href="1--Type-Theory.1-2--Inductive-Types.html#9532" class="Function">⊤-ump-out-fro</a> <a id="9546" class="Symbol">:</a> <a id="9548" class="Symbol">{</a><a id="9549" href="1--Type-Theory.1-2--Inductive-Types.html#9549" class="Bound">A</a> <a id="9551" class="Symbol">:</a> <a id="9553" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="9557" class="Symbol">}</a>
  <a id="9561" class="Symbol">→</a> <a id="9563" class="Symbol">(</a><a id="9564" href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a> <a id="9566" class="Symbol">→</a> <a id="9568" href="1--Type-Theory.1-2--Inductive-Types.html#9549" class="Bound">A</a><a id="9569" class="Symbol">)</a>
  <a id="9573" class="Symbol">→</a> <a id="9575" href="1--Type-Theory.1-2--Inductive-Types.html#9549" class="Bound">A</a>
<a id="9577" class="Comment">-- Exercise:</a>
<a id="9590" class="Comment">-- ⊤-ump-out-fro f = {!!}</a>
</pre><!--
<pre class="Agda"><a id="9629" href="1--Type-Theory.1-2--Inductive-Types.html#9532" class="Function">⊤-ump-out-fro</a> <a id="9643" href="1--Type-Theory.1-2--Inductive-Types.html#9643" class="Bound">f</a> <a id="9645" class="Symbol">=</a> <a id="9647" href="1--Type-Theory.1-2--Inductive-Types.html#9643" class="Bound">f</a> <a id="9649" href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a>

</pre>-->
<h2 id="natural-numbers"><a class="header" href="#natural-numbers">Natural Numbers</a></h2>
<p>Enough with the simple data types, let’s do some mathematics. We can
define the natural numbers <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code> as an inductive data type with two
constructors. There is a constructor <code>zero : ℕ</code>, saying that zero is a
natural number, and a constructor <code>suc : ℕ → ℕ</code>, which says that if
<code>n</code> is already a natural number then <code>suc n</code> (the “successor” of <code>n</code>,
i.e. <code>1 + n</code>) is also a natural number.</p>
<p>We actually defined <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code> behind the scenes so that we could use it in
Lecture 1-1. On the website, you can click on its name to take you
there.</p>
<p>The exact definition of <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code>, copy-pasted, is:</p>
<pre><code>data ℕ : Type where
  zero : ℕ
  suc  : ℕ → ℕ
</code></pre>
<p>(We leave it commented out, so that Agda doesn’t complain about
defining a new type with the same name as an existing one.)</p>
<p>Defining functions out of <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code> is similar to defining functions out
of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code>, we just have to give cases for the two constructors. The
difference is that the <code class="Agda"><a href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a></code> constructor tells us which natural
number the provided argument is the successor of.</p>
<p>Here’s a first example:</p>
<pre class="Agda"><a id="isZero"></a><a id="10742" href="1--Type-Theory.1-2--Inductive-Types.html#10742" class="Function">isZero</a> <a id="10749" class="Symbol">:</a> <a id="10751" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="10753" class="Symbol">→</a> <a id="10755" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="10760" href="1--Type-Theory.1-2--Inductive-Types.html#10742" class="Function">isZero</a> <a id="10767" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="10772" class="Symbol">=</a> <a id="10774" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
<a id="10779" href="1--Type-Theory.1-2--Inductive-Types.html#10742" class="Function">isZero</a> <a id="10786" class="Symbol">(</a><a id="10787" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="10791" href="1--Type-Theory.1-2--Inductive-Types.html#10791" class="Bound">n</a><a id="10792" class="Symbol">)</a> <a id="10794" class="Symbol">=</a> <a id="10796" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>

<a id="10803" href="1--Type-Theory.1-2--Inductive-Types.html#10803" class="Function">_</a> <a id="10805" class="Symbol">=</a> <a id="10807" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="10822" class="Symbol">(</a><a id="10823" href="1--Type-Theory.1-2--Inductive-Types.html#10742" class="Function">isZero</a> <a id="10830" class="Number">0</a><a id="10831" class="Symbol">)</a>  <a id="10834" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
<a id="10839" href="1--Type-Theory.1-2--Inductive-Types.html#10839" class="Function">_</a> <a id="10841" class="Symbol">=</a> <a id="10843" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="10858" class="Symbol">(</a><a id="10859" href="1--Type-Theory.1-2--Inductive-Types.html#10742" class="Function">isZero</a> <a id="10866" class="Number">19</a><a id="10868" class="Symbol">)</a> <a id="10870" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
</pre>
<p>So, <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#10742" class="Function">isZero</a></code> is <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a></code> for zero, and <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a></code> for any successor.</p>
<div class="info">
<p><span class="info-label">Aside:</span>
Agda throws in some secret-sauce that lets us write elements of <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code>
as numerals <code>1</code>, <code>2</code>, <code>3</code>, …, rather than having to write out <code>suc (suc (suc zero))</code> for <code>3</code>, for example.</p>
</div>
<p>For <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#10742" class="Function">isZero</a></code> we didn’t need to use the variable <code>n</code>, but to do
anything interesting we will. For example:</p>
<pre class="Agda"><a id="doubleℕ"></a><a id="11261" href="1--Type-Theory.1-2--Inductive-Types.html#11261" class="Function">doubleℕ</a> <a id="11269" class="Symbol">:</a> <a id="11271" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="11273" class="Symbol">→</a> <a id="11275" href="Library.Prelude.html#3629" class="Datatype">ℕ</a>
<a id="11277" href="1--Type-Theory.1-2--Inductive-Types.html#11261" class="Function">doubleℕ</a> <a id="11285" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="11290" class="Symbol">=</a> <a id="11292" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>
<a id="11297" href="1--Type-Theory.1-2--Inductive-Types.html#11261" class="Function">doubleℕ</a> <a id="11305" class="Symbol">(</a><a id="11306" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="11310" href="1--Type-Theory.1-2--Inductive-Types.html#11310" class="Bound">n</a><a id="11311" class="Symbol">)</a> <a id="11313" class="Symbol">=</a> <a id="11315" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="11319" class="Symbol">(</a><a id="11320" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="11324" class="Symbol">(</a><a id="11325" href="1--Type-Theory.1-2--Inductive-Types.html#11261" class="Function">doubleℕ</a> <a id="11333" href="1--Type-Theory.1-2--Inductive-Types.html#11310" class="Bound">n</a><a id="11334" class="Symbol">))</a>
</pre>
<p>Thinking mathematically, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>, covering the first case. For the
second case, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>. To achieve the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mord">+</span></span></span></span> part,
we use <code class="Agda"><a href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a></code> twice, and to achieve the <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> part, we use a
recursive call to the <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#11261" class="Function">doubleℕ</a></code> function we are currently defining!</p>
<p>Agda allows this kind of recursion so long as it is convinced that the
argument that you provide to the recursive call is smaller than the
argument that you started with. That is certainly the case here,
because we go from <code>suc n</code> to just <code>n</code>.</p>
<p>We can even do what is called “mutual” recursion, where two
definitions depend on each other to make sense. Here is a definition
of a function that decides whether a number is even, defined together
with the same for whether a number is odd:</p>
<pre class="Agda"><a id="isEven"></a><a id="12109" href="1--Type-Theory.1-2--Inductive-Types.html#12109" class="Function">isEven</a> <a id="12116" class="Symbol">:</a> <a id="12118" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="12120" class="Symbol">→</a> <a id="12122" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="isOdd"></a><a id="12127" href="1--Type-Theory.1-2--Inductive-Types.html#12127" class="Function">isOdd</a>  <a id="12134" class="Symbol">:</a> <a id="12136" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="12138" class="Symbol">→</a> <a id="12140" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>

<a id="12146" href="1--Type-Theory.1-2--Inductive-Types.html#12109" class="Function">isEven</a> <a id="12153" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="12158" class="Symbol">=</a> <a id="12160" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
<a id="12165" href="1--Type-Theory.1-2--Inductive-Types.html#12109" class="Function">isEven</a> <a id="12172" class="Symbol">(</a><a id="12173" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="12177" href="1--Type-Theory.1-2--Inductive-Types.html#12177" class="Bound">n</a><a id="12178" class="Symbol">)</a> <a id="12180" class="Symbol">=</a> <a id="12182" href="1--Type-Theory.1-2--Inductive-Types.html#12127" class="Function">isOdd</a> <a id="12188" href="1--Type-Theory.1-2--Inductive-Types.html#12177" class="Bound">n</a>

<a id="12191" href="1--Type-Theory.1-2--Inductive-Types.html#12127" class="Function">isOdd</a> <a id="12197" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="12202" class="Symbol">=</a> <a id="12204" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
<a id="12210" href="1--Type-Theory.1-2--Inductive-Types.html#12127" class="Function">isOdd</a> <a id="12216" class="Symbol">(</a><a id="12217" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="12221" href="1--Type-Theory.1-2--Inductive-Types.html#12221" class="Bound">n</a><a id="12222" class="Symbol">)</a> <a id="12224" class="Symbol">=</a> <a id="12226" href="1--Type-Theory.1-2--Inductive-Types.html#12109" class="Function">isEven</a> <a id="12233" href="1--Type-Theory.1-2--Inductive-Types.html#12221" class="Bound">n</a>
</pre>
<p>Using pattern matching, we can define the arithmetic operations on
numbers:</p>
<pre class="Agda"><a id="_+ℕ_"></a><a id="12321" href="1--Type-Theory.1-2--Inductive-Types.html#12321" class="Function Operator">_+ℕ_</a> <a id="12326" class="Symbol">:</a> <a id="12328" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="12330" class="Symbol">→</a> <a id="12332" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="12334" class="Symbol">→</a> <a id="12336" href="Library.Prelude.html#3629" class="Datatype">ℕ</a>
<a id="12338" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>    <a id="12346" href="1--Type-Theory.1-2--Inductive-Types.html#12321" class="Function Operator">+ℕ</a> <a id="12349" href="1--Type-Theory.1-2--Inductive-Types.html#12349" class="Bound">m</a> <a id="12351" class="Symbol">=</a> <a id="12353" href="1--Type-Theory.1-2--Inductive-Types.html#12349" class="Bound">m</a>
<a id="12355" class="Symbol">(</a><a id="12356" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="12360" href="1--Type-Theory.1-2--Inductive-Types.html#12360" class="Bound">n</a><a id="12361" class="Symbol">)</a> <a id="12363" href="1--Type-Theory.1-2--Inductive-Types.html#12321" class="Function Operator">+ℕ</a> <a id="12366" href="1--Type-Theory.1-2--Inductive-Types.html#12366" class="Bound">m</a> <a id="12368" class="Symbol">=</a> <a id="12370" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="12374" class="Symbol">(</a><a id="12375" href="1--Type-Theory.1-2--Inductive-Types.html#12360" class="Bound">n</a> <a id="12377" href="1--Type-Theory.1-2--Inductive-Types.html#12321" class="Function Operator">+ℕ</a> <a id="12380" href="1--Type-Theory.1-2--Inductive-Types.html#12366" class="Bound">m</a><a id="12381" class="Symbol">)</a>

<a id="12384" href="1--Type-Theory.1-2--Inductive-Types.html#12384" class="Function">_</a> <a id="12386" class="Symbol">=</a> <a id="12388" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="12403" class="Symbol">(</a><a id="12404" class="Number">2</a> <a id="12406" href="1--Type-Theory.1-2--Inductive-Types.html#12321" class="Function Operator">+ℕ</a> <a id="12409" class="Number">3</a><a id="12410" class="Symbol">)</a> <a id="12412" class="Number">5</a>
</pre>
<p>Remember that you can test any piece of code yourself by typing <code>C-c C-n</code> and then <code>2 +ℕ 3</code>, say.</p>
<p>Here we have chosen to split into cases on the left side and leave the
right side alone, but we could equally well split into cases on the
right instead:</p>
<pre class="Agda"><a id="_+ℕ&#39;_"></a><a id="12677" href="1--Type-Theory.1-2--Inductive-Types.html#12677" class="Function Operator">_+ℕ&#39;_</a> <a id="12683" class="Symbol">:</a> <a id="12685" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="12687" class="Symbol">→</a> <a id="12689" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="12691" class="Symbol">→</a> <a id="12693" href="Library.Prelude.html#3629" class="Datatype">ℕ</a>
<a id="12695" href="1--Type-Theory.1-2--Inductive-Types.html#12695" class="Bound">n</a> <a id="12697" href="1--Type-Theory.1-2--Inductive-Types.html#12677" class="Function Operator">+ℕ&#39;</a> <a id="12701" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="12706" class="Symbol">=</a> <a id="12708" href="1--Type-Theory.1-2--Inductive-Types.html#12695" class="Bound">n</a>
<a id="12710" href="1--Type-Theory.1-2--Inductive-Types.html#12710" class="Bound">n</a> <a id="12712" href="1--Type-Theory.1-2--Inductive-Types.html#12677" class="Function Operator">+ℕ&#39;</a> <a id="12716" class="Symbol">(</a><a id="12717" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="12721" href="1--Type-Theory.1-2--Inductive-Types.html#12721" class="Bound">m</a><a id="12722" class="Symbol">)</a> <a id="12724" class="Symbol">=</a> <a id="12726" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="12730" class="Symbol">(</a><a id="12731" href="1--Type-Theory.1-2--Inductive-Types.html#12710" class="Bound">n</a> <a id="12733" href="1--Type-Theory.1-2--Inductive-Types.html#12677" class="Function Operator">+ℕ&#39;</a> <a id="12737" href="1--Type-Theory.1-2--Inductive-Types.html#12721" class="Bound">m</a><a id="12738" class="Symbol">)</a>

<a id="12741" href="1--Type-Theory.1-2--Inductive-Types.html#12741" class="Function">_</a> <a id="12743" class="Symbol">=</a> <a id="12745" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="12760" class="Symbol">(</a><a id="12761" class="Number">2</a> <a id="12763" href="1--Type-Theory.1-2--Inductive-Types.html#12677" class="Function Operator">+ℕ&#39;</a> <a id="12767" class="Number">3</a><a id="12768" class="Symbol">)</a> <a id="12770" class="Number">5</a>
</pre>
<p>We will be able to show that these two versions of addition do produce
the same result whenever they are handed two concrete elements of
<code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code>, but Agda isn’t able to automatically consider them <em>exactly</em>
identical.</p>
<pre class="Agda"><a id="12998" class="Comment">-- This will fail!</a>
<a id="13017" class="Comment">-- _ = test-identical _+ℕ_ _+ℕ&#39;_</a>
</pre>
<p>One way they are not identical is that they have different
computational behaviour:</p>
<pre class="Agda"><a id="13144" href="1--Type-Theory.1-2--Inductive-Types.html#13144" class="Function">_</a> <a id="13146" class="Symbol">=</a> <a id="13148" class="Symbol">λ</a> <a id="13150" class="Symbol">(</a><a id="13151" href="1--Type-Theory.1-2--Inductive-Types.html#13151" class="Bound">m</a> <a id="13153" class="Symbol">:</a> <a id="13155" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="13156" class="Symbol">)</a> <a id="13158" class="Symbol">→</a> <a id="13160" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="13175" class="Symbol">(</a><a id="13176" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="13181" href="1--Type-Theory.1-2--Inductive-Types.html#12321" class="Function Operator">+ℕ</a> <a id="13184" href="1--Type-Theory.1-2--Inductive-Types.html#13151" class="Bound">m</a><a id="13185" class="Symbol">)</a> <a id="13187" href="1--Type-Theory.1-2--Inductive-Types.html#13151" class="Bound">m</a>
<a id="13189" class="Comment">-- Fails, because `+ℕ` case splits on `n`!</a>
<a id="13232" class="Comment">-- _ = λ (n : ℕ) → test-identical (n +ℕ zero) n</a>
<a id="13280" href="1--Type-Theory.1-2--Inductive-Types.html#13280" class="Function">_</a> <a id="13282" class="Symbol">=</a> <a id="13284" class="Symbol">λ</a> <a id="13286" class="Symbol">(</a><a id="13287" href="1--Type-Theory.1-2--Inductive-Types.html#13287" class="Bound">n</a> <a id="13289" class="Symbol">:</a> <a id="13291" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="13292" class="Symbol">)</a> <a id="13294" class="Symbol">→</a> <a id="13296" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="13311" class="Symbol">(</a><a id="13312" href="1--Type-Theory.1-2--Inductive-Types.html#13287" class="Bound">n</a> <a id="13314" href="1--Type-Theory.1-2--Inductive-Types.html#12677" class="Function Operator">+ℕ&#39;</a> <a id="13318" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="13322" class="Symbol">)</a> <a id="13324" href="1--Type-Theory.1-2--Inductive-Types.html#13287" class="Bound">n</a>
</pre>
<p>Try some other ordinary operations on natural numbers. To figure out
how these should go, calculate what the answer should be
mathematically. For example, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>, and this can
be turned into one of the cases for multiplication.</p>
<pre class="Agda"><a id="13585" class="Comment">-- Multiplication</a>
<a id="_·ℕ_"></a><a id="13603" href="1--Type-Theory.1-2--Inductive-Types.html#13603" class="Function Operator">_·ℕ_</a> <a id="13608" class="Symbol">:</a> <a id="13610" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="13612" class="Symbol">→</a> <a id="13614" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="13616" class="Symbol">→</a> <a id="13618" href="Library.Prelude.html#3629" class="Datatype">ℕ</a>
<a id="13620" class="Comment">-- Exercise:</a>
<a id="13633" class="Comment">-- n ·ℕ m = {!!}</a>
</pre><!--
<pre class="Agda"><a id="13663" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="13668" href="1--Type-Theory.1-2--Inductive-Types.html#13603" class="Function Operator">·ℕ</a> <a id="13671" href="1--Type-Theory.1-2--Inductive-Types.html#13671" class="Bound">m</a> <a id="13673" class="Symbol">=</a> <a id="13675" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>
<a id="13680" class="Symbol">(</a><a id="13681" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="13685" href="1--Type-Theory.1-2--Inductive-Types.html#13685" class="Bound">n</a><a id="13686" class="Symbol">)</a> <a id="13688" href="1--Type-Theory.1-2--Inductive-Types.html#13603" class="Function Operator">·ℕ</a> <a id="13691" href="1--Type-Theory.1-2--Inductive-Types.html#13691" class="Bound">m</a> <a id="13693" class="Symbol">=</a> <a id="13695" href="1--Type-Theory.1-2--Inductive-Types.html#13691" class="Bound">m</a> <a id="13697" href="1--Type-Theory.1-2--Inductive-Types.html#12321" class="Function Operator">+ℕ</a> <a id="13700" class="Symbol">(</a><a id="13701" href="1--Type-Theory.1-2--Inductive-Types.html#13685" class="Bound">n</a> <a id="13703" href="1--Type-Theory.1-2--Inductive-Types.html#13603" class="Function Operator">·ℕ</a> <a id="13706" href="1--Type-Theory.1-2--Inductive-Types.html#13691" class="Bound">m</a><a id="13707" class="Symbol">)</a>

</pre>-->
<pre class="Agda">
<a id="13723" href="1--Type-Theory.1-2--Inductive-Types.html#13723" class="Function">_</a> <a id="13725" class="Symbol">=</a> <a id="13727" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="13742" class="Symbol">(</a><a id="13743" class="Number">0</a> <a id="13745" href="1--Type-Theory.1-2--Inductive-Types.html#13603" class="Function Operator">·ℕ</a> <a id="13748" class="Number">1</a><a id="13749" class="Symbol">)</a> <a id="13751" class="Number">0</a>
<a id="13753" href="1--Type-Theory.1-2--Inductive-Types.html#13753" class="Function">_</a> <a id="13755" class="Symbol">=</a> <a id="13757" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="13772" class="Symbol">(</a><a id="13773" class="Number">2</a> <a id="13775" href="1--Type-Theory.1-2--Inductive-Types.html#13603" class="Function Operator">·ℕ</a> <a id="13778" class="Number">3</a><a id="13779" class="Symbol">)</a> <a id="13781" class="Number">6</a>
<a id="13783" href="1--Type-Theory.1-2--Inductive-Types.html#13783" class="Function">_</a> <a id="13785" class="Symbol">=</a> <a id="13787" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="13802" class="Symbol">(</a><a id="13803" class="Number">3</a> <a id="13805" href="1--Type-Theory.1-2--Inductive-Types.html#13603" class="Function Operator">·ℕ</a> <a id="13808" class="Number">2</a><a id="13809" class="Symbol">)</a> <a id="13811" class="Number">6</a>

<a id="13814" class="Comment">-- Exponentiation</a>
<a id="_^ℕ_"></a><a id="13832" href="1--Type-Theory.1-2--Inductive-Types.html#13832" class="Function Operator">_^ℕ_</a> <a id="13837" class="Symbol">:</a> <a id="13839" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="13841" class="Symbol">→</a> <a id="13843" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="13845" class="Symbol">→</a> <a id="13847" href="Library.Prelude.html#3629" class="Datatype">ℕ</a>
<a id="13849" class="Comment">-- Exercise:</a>
<a id="13862" class="Comment">-- n ^ℕ m = {!!}</a>
</pre><!--
<pre class="Agda"><a id="13892" href="1--Type-Theory.1-2--Inductive-Types.html#13892" class="Bound">n</a> <a id="13894" href="1--Type-Theory.1-2--Inductive-Types.html#13832" class="Function Operator">^ℕ</a> <a id="13897" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="13902" class="Symbol">=</a> <a id="13904" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="13908" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>
<a id="13913" href="1--Type-Theory.1-2--Inductive-Types.html#13913" class="Bound">n</a> <a id="13915" href="1--Type-Theory.1-2--Inductive-Types.html#13832" class="Function Operator">^ℕ</a> <a id="13918" class="Symbol">(</a><a id="13919" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="13923" href="1--Type-Theory.1-2--Inductive-Types.html#13923" class="Bound">m</a><a id="13924" class="Symbol">)</a> <a id="13926" class="Symbol">=</a> <a id="13928" href="1--Type-Theory.1-2--Inductive-Types.html#13913" class="Bound">n</a> <a id="13930" href="1--Type-Theory.1-2--Inductive-Types.html#13603" class="Function Operator">·ℕ</a> <a id="13933" class="Symbol">(</a><a id="13934" href="1--Type-Theory.1-2--Inductive-Types.html#13913" class="Bound">n</a> <a id="13936" href="1--Type-Theory.1-2--Inductive-Types.html#13832" class="Function Operator">^ℕ</a> <a id="13939" href="1--Type-Theory.1-2--Inductive-Types.html#13923" class="Bound">m</a><a id="13940" class="Symbol">)</a>

</pre>-->
<pre class="Agda">
<a id="13956" href="1--Type-Theory.1-2--Inductive-Types.html#13956" class="Function">_</a> <a id="13958" class="Symbol">=</a> <a id="13960" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="13975" class="Symbol">(</a><a id="13976" class="Number">1</a> <a id="13978" href="1--Type-Theory.1-2--Inductive-Types.html#13832" class="Function Operator">^ℕ</a> <a id="13981" class="Number">1</a><a id="13982" class="Symbol">)</a> <a id="13984" class="Number">1</a>
<a id="13986" href="1--Type-Theory.1-2--Inductive-Types.html#13986" class="Function">_</a> <a id="13988" class="Symbol">=</a> <a id="13990" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="14005" class="Symbol">(</a><a id="14006" class="Number">2</a> <a id="14008" href="1--Type-Theory.1-2--Inductive-Types.html#13832" class="Function Operator">^ℕ</a> <a id="14011" class="Number">3</a><a id="14012" class="Symbol">)</a> <a id="14014" class="Number">8</a>
<a id="14016" href="1--Type-Theory.1-2--Inductive-Types.html#14016" class="Function">_</a> <a id="14018" class="Symbol">=</a> <a id="14020" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="14035" class="Symbol">(</a><a id="14036" class="Number">3</a> <a id="14038" href="1--Type-Theory.1-2--Inductive-Types.html#13832" class="Function Operator">^ℕ</a> <a id="14041" class="Number">2</a><a id="14042" class="Symbol">)</a> <a id="14044" class="Number">9</a>
</pre>
<p>Remember that you can test these manually using <code>C-c C-n</code>!</p>
<p>We can also define a “predecessor” operation, which partially undoes
the successor <code>suc : ℕ → ℕ</code>. Of course, it can’t fully undo it, since
<code class="Agda"><a href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a></code> has nowhere to go except <code class="Agda"><a href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a></code> again.</p>
<pre class="Agda"><a id="predℕ"></a><a id="14305" href="1--Type-Theory.1-2--Inductive-Types.html#14305" class="Function">predℕ</a> <a id="14311" class="Symbol">:</a> <a id="14313" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="14315" class="Symbol">→</a> <a id="14317" href="Library.Prelude.html#3629" class="Datatype">ℕ</a>
<a id="14319" class="Comment">-- Exercise:</a>
<a id="14332" class="Comment">-- predℕ n = {!!}</a>
</pre><!--
<pre class="Agda"><a id="14363" href="1--Type-Theory.1-2--Inductive-Types.html#14305" class="Function">predℕ</a> <a id="14369" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="14374" class="Symbol">=</a> <a id="14376" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>
<a id="14381" href="1--Type-Theory.1-2--Inductive-Types.html#14305" class="Function">predℕ</a> <a id="14387" class="Symbol">(</a><a id="14388" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="14392" href="1--Type-Theory.1-2--Inductive-Types.html#14392" class="Bound">n</a><a id="14393" class="Symbol">)</a> <a id="14395" class="Symbol">=</a> <a id="14397" href="1--Type-Theory.1-2--Inductive-Types.html#14392" class="Bound">n</a>

</pre>-->
<pre class="Agda">
<a id="14413" href="1--Type-Theory.1-2--Inductive-Types.html#14413" class="Function">_</a> <a id="14415" class="Symbol">=</a> <a id="14417" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="14432" class="Symbol">(</a><a id="14433" href="1--Type-Theory.1-2--Inductive-Types.html#14305" class="Function">predℕ</a> <a id="14439" class="Number">0</a><a id="14440" class="Symbol">)</a> <a id="14442" class="Number">0</a>
<a id="14444" href="1--Type-Theory.1-2--Inductive-Types.html#14444" class="Function">_</a> <a id="14446" class="Symbol">=</a> <a id="14448" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="14463" class="Symbol">(</a><a id="14464" href="1--Type-Theory.1-2--Inductive-Types.html#14305" class="Function">predℕ</a> <a id="14470" class="Number">1</a><a id="14471" class="Symbol">)</a> <a id="14473" class="Number">0</a>
<a id="14475" href="1--Type-Theory.1-2--Inductive-Types.html#14475" class="Function">_</a> <a id="14477" class="Symbol">=</a> <a id="14479" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="14494" class="Symbol">(</a><a id="14495" href="1--Type-Theory.1-2--Inductive-Types.html#14305" class="Function">predℕ</a> <a id="14501" class="Number">19</a><a id="14503" class="Symbol">)</a> <a id="14505" class="Number">18</a>
</pre>
<h2 id="lists"><a class="header" href="#lists">Lists</a></h2>
<p>If this were a course on functional programming, we would spend a lot
more time working with lists. This isn’t a course on functional
programming, but it’s worth seeing a little of how <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#14742" class="Datatype">List</a></code>s are
handled.</p>
<pre class="Agda"><a id="14737" class="Keyword">data</a> <a id="List"></a><a id="14742" href="1--Type-Theory.1-2--Inductive-Types.html#14742" class="Datatype">List</a> <a id="14747" class="Symbol">(</a><a id="14748" href="1--Type-Theory.1-2--Inductive-Types.html#14748" class="Bound">A</a> <a id="14750" class="Symbol">:</a> <a id="14752" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="14756" class="Symbol">)</a> <a id="14758" class="Symbol">:</a> <a id="14760" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="14765" class="Keyword">where</a>
  <a id="List.[]"></a><a id="14773" href="1--Type-Theory.1-2--Inductive-Types.html#14773" class="InductiveConstructor">[]</a>    <a id="14779" class="Symbol">:</a> <a id="14781" href="1--Type-Theory.1-2--Inductive-Types.html#14742" class="Datatype">List</a> <a id="14786" href="1--Type-Theory.1-2--Inductive-Types.html#14748" class="Bound">A</a>                <a id="14803" class="Comment">-- The empty list</a>
  <a id="List._::_"></a><a id="14823" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">_::_</a>  <a id="14829" class="Symbol">:</a> <a id="14831" href="1--Type-Theory.1-2--Inductive-Types.html#14748" class="Bound">A</a> <a id="14833" class="Symbol">→</a> <a id="14835" href="1--Type-Theory.1-2--Inductive-Types.html#14742" class="Datatype">List</a> <a id="14840" href="1--Type-Theory.1-2--Inductive-Types.html#14748" class="Bound">A</a> <a id="14842" class="Symbol">→</a> <a id="14844" href="1--Type-Theory.1-2--Inductive-Types.html#14742" class="Datatype">List</a> <a id="14849" href="1--Type-Theory.1-2--Inductive-Types.html#14748" class="Bound">A</a>   <a id="14853" class="Comment">-- The list with a head element and a tail remainder</a>
</pre>
<p>That is, a list is either the empty list <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#14773" class="InductiveConstructor">[]</a></code>, or the list <code>a :: l</code>
which has <code>a</code> at the head and <code>l</code> as the remainder of the list. We use
some reasonably common symbols as the names of the two constructors.
Other functional languages might call these <code>nil</code> and <code>cons</code>.</p>
<p>A list that we would typically write as <code>[1, 2, 3]</code> can be constructed
by stringing together the <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor">::</a></code> constructor, and ending with the
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#14773" class="InductiveConstructor">[]</a></code> constructor:</p>
<pre class="Agda"><a id="shortList"></a><a id="15346" href="1--Type-Theory.1-2--Inductive-Types.html#15346" class="Function">shortList</a> <a id="15356" class="Symbol">:</a> <a id="15358" href="1--Type-Theory.1-2--Inductive-Types.html#14742" class="Datatype">List</a> <a id="15363" href="Library.Prelude.html#3629" class="Datatype">ℕ</a>
<a id="15365" href="1--Type-Theory.1-2--Inductive-Types.html#15346" class="Function">shortList</a> <a id="15375" class="Symbol">=</a> <a id="15377" class="Number">34</a> <a id="15380" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="15383" class="Number">19</a> <a id="15386" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="15389" href="1--Type-Theory.1-2--Inductive-Types.html#14773" class="InductiveConstructor">[]</a>
</pre>
<p><code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#14742" class="Datatype">List</a></code> is our first example of an “indexed” inductive type, a type
constructor that requires an argument. Here, for any type <code>T</code>, there
is an inductive type <code>List T</code> with those two constructors, where <code>T</code>
has been substituted wherever <code>A</code> appears in the types of those
constructors. This is what lets us use the <code>[]</code> constructor as though
it has type <code>List ℕ</code>, and the <code>::</code> constructor as though it has type
<code>ℕ → List ℕ → List ℕ</code> in the definition of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#15346" class="Function">shortList</a></code>.</p>
<p>It is fairly common to create a list with a singleton element, so here
is a helper that achieves that.</p>
<pre class="Agda"><a id="[_]"></a><a id="15974" href="1--Type-Theory.1-2--Inductive-Types.html#15974" class="Function Operator">[_]</a> <a id="15978" class="Symbol">:</a> <a id="15980" class="Symbol">{</a><a id="15981" href="1--Type-Theory.1-2--Inductive-Types.html#15981" class="Bound">A</a> <a id="15983" class="Symbol">:</a> <a id="15985" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="15989" class="Symbol">}</a> <a id="15991" class="Symbol">→</a> <a id="15993" href="1--Type-Theory.1-2--Inductive-Types.html#15981" class="Bound">A</a> <a id="15995" class="Symbol">→</a> <a id="15997" href="1--Type-Theory.1-2--Inductive-Types.html#14742" class="Datatype">List</a> <a id="16002" href="1--Type-Theory.1-2--Inductive-Types.html#15981" class="Bound">A</a>
<a id="16004" href="1--Type-Theory.1-2--Inductive-Types.html#15974" class="Function Operator">[</a> <a id="16006" href="1--Type-Theory.1-2--Inductive-Types.html#16006" class="Bound">a</a> <a id="16008" href="1--Type-Theory.1-2--Inductive-Types.html#15974" class="Function Operator">]</a> <a id="16010" class="Symbol">=</a> <a id="16012" href="1--Type-Theory.1-2--Inductive-Types.html#16006" class="Bound">a</a> <a id="16014" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="16017" href="1--Type-Theory.1-2--Inductive-Types.html#14773" class="InductiveConstructor">[]</a>
</pre>
<p>The type that we want to use for the elements of the list is accepted
as an implicit argument. As usual, <code>List A</code> doesn’t make sense as a
type unless we have defined what <code>A</code> is somewhere.</p>
<p>Concatenation of lists is defined by pattern-matching. For example, the
concatenation <code>[1, 2, 3] ++ [4, 5, 6]</code> is <code>[1, 2, 3, 4, 5, 6]</code>.</p>
<pre class="Agda"><a id="_++_"></a><a id="16356" href="1--Type-Theory.1-2--Inductive-Types.html#16356" class="Function Operator">_++_</a> <a id="16361" class="Symbol">:</a> <a id="16363" class="Symbol">{</a><a id="16364" href="1--Type-Theory.1-2--Inductive-Types.html#16364" class="Bound">A</a> <a id="16366" class="Symbol">:</a> <a id="16368" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="16372" class="Symbol">}</a> <a id="16374" class="Symbol">→</a> <a id="16376" href="1--Type-Theory.1-2--Inductive-Types.html#14742" class="Datatype">List</a> <a id="16381" href="1--Type-Theory.1-2--Inductive-Types.html#16364" class="Bound">A</a> <a id="16383" class="Symbol">→</a> <a id="16385" href="1--Type-Theory.1-2--Inductive-Types.html#14742" class="Datatype">List</a> <a id="16390" href="1--Type-Theory.1-2--Inductive-Types.html#16364" class="Bound">A</a> <a id="16392" class="Symbol">→</a> <a id="16394" href="1--Type-Theory.1-2--Inductive-Types.html#14742" class="Datatype">List</a> <a id="16399" href="1--Type-Theory.1-2--Inductive-Types.html#16364" class="Bound">A</a>
<a id="16401" href="1--Type-Theory.1-2--Inductive-Types.html#14773" class="InductiveConstructor">[]</a> <a id="16404" href="1--Type-Theory.1-2--Inductive-Types.html#16356" class="Function Operator">++</a> <a id="16407" href="1--Type-Theory.1-2--Inductive-Types.html#16407" class="Bound">l2</a> <a id="16410" class="Symbol">=</a> <a id="16412" href="1--Type-Theory.1-2--Inductive-Types.html#16407" class="Bound">l2</a>
<a id="16415" class="Symbol">(</a><a id="16416" href="1--Type-Theory.1-2--Inductive-Types.html#16416" class="Bound">x</a> <a id="16418" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="16421" href="1--Type-Theory.1-2--Inductive-Types.html#16421" class="Bound">l1</a><a id="16423" class="Symbol">)</a> <a id="16425" href="1--Type-Theory.1-2--Inductive-Types.html#16356" class="Function Operator">++</a> <a id="16428" href="1--Type-Theory.1-2--Inductive-Types.html#16428" class="Bound">l2</a> <a id="16431" class="Symbol">=</a> <a id="16433" href="1--Type-Theory.1-2--Inductive-Types.html#16416" class="Bound">x</a> <a id="16435" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="16438" class="Symbol">(</a><a id="16439" href="1--Type-Theory.1-2--Inductive-Types.html#16421" class="Bound">l1</a> <a id="16442" href="1--Type-Theory.1-2--Inductive-Types.html#16356" class="Function Operator">++</a> <a id="16445" href="1--Type-Theory.1-2--Inductive-Types.html#16428" class="Bound">l2</a><a id="16447" class="Symbol">)</a>
</pre>
<p>In words, concatenating the empty list to any list doesn’t change it,
and when concatenating a list with a head to another list, the result
has the same head, and the remainder is the concatenation with the
remainder.</p>
<p>Compare this to the definition of addition on <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code>, the
structure is <em>exactly</em> the same (if we rewrite the second case as
<code>_::_ x l</code> rather than using the constructor infix). All that is
different is keeping track of the element of <code>A</code>.</p>
<p>With this in mind, try defining a function to calculate the <code>length</code>
of a list.</p>
<pre class="Agda"><a id="length"></a><a id="16997" href="1--Type-Theory.1-2--Inductive-Types.html#16997" class="Function">length</a> <a id="17004" class="Symbol">:</a> <a id="17006" class="Symbol">{</a><a id="17007" href="1--Type-Theory.1-2--Inductive-Types.html#17007" class="Bound">A</a> <a id="17009" class="Symbol">:</a> <a id="17011" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="17015" class="Symbol">}</a> <a id="17017" class="Symbol">→</a> <a id="17019" href="1--Type-Theory.1-2--Inductive-Types.html#14742" class="Datatype">List</a> <a id="17024" href="1--Type-Theory.1-2--Inductive-Types.html#17007" class="Bound">A</a> <a id="17026" class="Symbol">→</a> <a id="17028" href="Library.Prelude.html#3629" class="Datatype">ℕ</a>
<a id="17030" class="Comment">-- Exercise:</a>
<a id="17043" class="Comment">-- length L = {!!}</a>
</pre><!--
<pre class="Agda"><a id="17075" href="1--Type-Theory.1-2--Inductive-Types.html#16997" class="Function">length</a> <a id="17082" href="1--Type-Theory.1-2--Inductive-Types.html#14773" class="InductiveConstructor">[]</a> <a id="17085" class="Symbol">=</a> <a id="17087" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>
<a id="17092" href="1--Type-Theory.1-2--Inductive-Types.html#16997" class="Function">length</a> <a id="17099" class="Symbol">(</a><a id="17100" href="1--Type-Theory.1-2--Inductive-Types.html#17100" class="Bound">x</a> <a id="17102" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="17105" href="1--Type-Theory.1-2--Inductive-Types.html#17105" class="Bound">l</a><a id="17106" class="Symbol">)</a> <a id="17108" class="Symbol">=</a> <a id="17110" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="17114" class="Symbol">(</a><a id="17115" href="1--Type-Theory.1-2--Inductive-Types.html#16997" class="Function">length</a> <a id="17122" href="1--Type-Theory.1-2--Inductive-Types.html#17105" class="Bound">l</a><a id="17123" class="Symbol">)</a>

</pre>-->
<pre class="Agda">
<a id="17139" href="1--Type-Theory.1-2--Inductive-Types.html#17139" class="Function">_</a> <a id="17141" class="Symbol">=</a> <a id="17143" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="17158" class="Symbol">(</a><a id="17159" href="1--Type-Theory.1-2--Inductive-Types.html#16997" class="Function">length</a> <a id="17166" href="1--Type-Theory.1-2--Inductive-Types.html#15974" class="Function Operator">[</a> <a id="17168" href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a> <a id="17171" href="1--Type-Theory.1-2--Inductive-Types.html#15974" class="Function Operator">]</a><a id="17172" class="Symbol">)</a> <a id="17174" class="Number">1</a>
<a id="17176" href="1--Type-Theory.1-2--Inductive-Types.html#17176" class="Function">_</a> <a id="17178" class="Symbol">=</a> <a id="17180" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="17195" class="Symbol">(</a><a id="17196" href="1--Type-Theory.1-2--Inductive-Types.html#16997" class="Function">length</a> <a id="17203" class="Symbol">(</a><a id="17204" class="Number">1</a> <a id="17206" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="17209" class="Number">2</a> <a id="17211" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="17214" class="Number">3</a> <a id="17216" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="17219" href="1--Type-Theory.1-2--Inductive-Types.html#14773" class="InductiveConstructor">[]</a><a id="17221" class="Symbol">))</a> <a id="17224" class="Number">3</a>
</pre>
<p>In the other direction, a natural number can be seen as a list of tally marks.</p>
<pre class="Agda"><a id="ℕ→List⊤"></a><a id="17315" href="1--Type-Theory.1-2--Inductive-Types.html#17315" class="Function">ℕ→List⊤</a> <a id="17323" class="Symbol">:</a> <a id="17325" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="17327" class="Symbol">→</a> <a id="17329" href="1--Type-Theory.1-2--Inductive-Types.html#14742" class="Datatype">List</a> <a id="17334" href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a>
<a id="17336" class="Comment">-- Exercise:</a>
<a id="17349" class="Comment">-- ℕ→List⊤ n = {!!}</a>
</pre><!--
<pre class="Agda"><a id="17382" href="1--Type-Theory.1-2--Inductive-Types.html#17315" class="Function">ℕ→List⊤</a> <a id="17390" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="17395" class="Symbol">=</a> <a id="17397" href="1--Type-Theory.1-2--Inductive-Types.html#14773" class="InductiveConstructor">[]</a>
<a id="17400" href="1--Type-Theory.1-2--Inductive-Types.html#17315" class="Function">ℕ→List⊤</a> <a id="17408" class="Symbol">(</a><a id="17409" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="17413" href="1--Type-Theory.1-2--Inductive-Types.html#17413" class="Bound">n</a><a id="17414" class="Symbol">)</a> <a id="17416" class="Symbol">=</a> <a id="17418" href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a> <a id="17421" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="17424" class="Symbol">(</a><a id="17425" href="1--Type-Theory.1-2--Inductive-Types.html#17315" class="Function">ℕ→List⊤</a> <a id="17433" href="1--Type-Theory.1-2--Inductive-Types.html#17413" class="Bound">n</a><a id="17434" class="Symbol">)</a>

</pre>-->
<pre class="Agda">
<a id="17450" href="1--Type-Theory.1-2--Inductive-Types.html#17450" class="Function">_</a> <a id="17452" class="Symbol">=</a> <a id="17454" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="17469" class="Symbol">(</a><a id="17470" href="1--Type-Theory.1-2--Inductive-Types.html#17315" class="Function">ℕ→List⊤</a> <a id="17478" class="Number">0</a><a id="17479" class="Symbol">)</a> <a id="17481" href="1--Type-Theory.1-2--Inductive-Types.html#14773" class="InductiveConstructor">[]</a>
<a id="17484" href="1--Type-Theory.1-2--Inductive-Types.html#17484" class="Function">_</a> <a id="17486" class="Symbol">=</a> <a id="17488" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="17503" class="Symbol">(</a><a id="17504" href="1--Type-Theory.1-2--Inductive-Types.html#17315" class="Function">ℕ→List⊤</a> <a id="17512" class="Number">3</a><a id="17513" class="Symbol">)</a> <a id="17515" class="Symbol">(</a><a id="17516" href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a> <a id="17519" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="17522" href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a> <a id="17525" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="17528" href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a> <a id="17531" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="17534" href="1--Type-Theory.1-2--Inductive-Types.html#14773" class="InductiveConstructor">[]</a><a id="17536" class="Symbol">)</a>
</pre>
<p>Together with <code>length : List ⊤ → ℕ</code>, we have a bijection between the
type of natural numbers and the type of lists of tally marks.</p>
<p>As one final example, try using <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#16356" class="Function">++</a></code> to define a <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#17753" class="Function">reverse</a></code>
function.</p>
<pre class="Agda"><a id="reverse"></a><a id="17753" href="1--Type-Theory.1-2--Inductive-Types.html#17753" class="Function">reverse</a> <a id="17761" class="Symbol">:</a> <a id="17763" class="Symbol">{</a><a id="17764" href="1--Type-Theory.1-2--Inductive-Types.html#17764" class="Bound">A</a> <a id="17766" class="Symbol">:</a> <a id="17768" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="17772" class="Symbol">}</a> <a id="17774" class="Symbol">→</a> <a id="17776" href="1--Type-Theory.1-2--Inductive-Types.html#14742" class="Datatype">List</a> <a id="17781" href="1--Type-Theory.1-2--Inductive-Types.html#17764" class="Bound">A</a> <a id="17783" class="Symbol">→</a> <a id="17785" href="1--Type-Theory.1-2--Inductive-Types.html#14742" class="Datatype">List</a> <a id="17790" href="1--Type-Theory.1-2--Inductive-Types.html#17764" class="Bound">A</a>
<a id="17792" class="Comment">-- Exercise:</a>
<a id="17805" class="Comment">-- reverse x = {!!}</a>
</pre><!--
<pre class="Agda"><a id="17838" href="1--Type-Theory.1-2--Inductive-Types.html#17753" class="Function">reverse</a> <a id="17846" href="1--Type-Theory.1-2--Inductive-Types.html#14773" class="InductiveConstructor">[]</a> <a id="17849" class="Symbol">=</a> <a id="17851" href="1--Type-Theory.1-2--Inductive-Types.html#14773" class="InductiveConstructor">[]</a>
<a id="17854" href="1--Type-Theory.1-2--Inductive-Types.html#17753" class="Function">reverse</a> <a id="17862" class="Symbol">(</a><a id="17863" href="1--Type-Theory.1-2--Inductive-Types.html#17863" class="Bound">x</a> <a id="17865" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="17868" href="1--Type-Theory.1-2--Inductive-Types.html#17868" class="Bound">L</a><a id="17869" class="Symbol">)</a> <a id="17871" class="Symbol">=</a> <a id="17873" href="1--Type-Theory.1-2--Inductive-Types.html#17753" class="Function">reverse</a> <a id="17881" href="1--Type-Theory.1-2--Inductive-Types.html#17868" class="Bound">L</a> <a id="17883" href="1--Type-Theory.1-2--Inductive-Types.html#16356" class="Function Operator">++</a> <a id="17886" href="1--Type-Theory.1-2--Inductive-Types.html#15974" class="Function Operator">[</a> <a id="17888" href="1--Type-Theory.1-2--Inductive-Types.html#17863" class="Bound">x</a> <a id="17890" href="1--Type-Theory.1-2--Inductive-Types.html#15974" class="Function Operator">]</a>

</pre>-->
<pre class="Agda">
<a id="17906" href="1--Type-Theory.1-2--Inductive-Types.html#17906" class="Function">_</a> <a id="17908" class="Symbol">=</a> <a id="17910" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="17925" class="Symbol">(</a><a id="17926" href="1--Type-Theory.1-2--Inductive-Types.html#17753" class="Function">reverse</a> <a id="17934" href="1--Type-Theory.1-2--Inductive-Types.html#15974" class="Function Operator">[</a> <a id="17936" class="Number">1</a> <a id="17938" href="1--Type-Theory.1-2--Inductive-Types.html#15974" class="Function Operator">]</a><a id="17939" class="Symbol">)</a> <a id="17941" href="1--Type-Theory.1-2--Inductive-Types.html#15974" class="Function Operator">[</a> <a id="17943" class="Number">1</a> <a id="17945" href="1--Type-Theory.1-2--Inductive-Types.html#15974" class="Function Operator">]</a>
<a id="17947" href="1--Type-Theory.1-2--Inductive-Types.html#17947" class="Function">_</a> <a id="17949" class="Symbol">=</a> <a id="17951" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="17966" class="Symbol">(</a><a id="17967" href="1--Type-Theory.1-2--Inductive-Types.html#17753" class="Function">reverse</a> <a id="17975" class="Symbol">(</a><a id="17976" class="Number">1</a> <a id="17978" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="17981" class="Number">2</a> <a id="17983" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="17986" class="Number">3</a> <a id="17988" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="17991" href="1--Type-Theory.1-2--Inductive-Types.html#14773" class="InductiveConstructor">[]</a><a id="17993" class="Symbol">))</a> <a id="17996" class="Symbol">(</a><a id="17997" class="Number">3</a> <a id="17999" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="18002" class="Number">2</a> <a id="18004" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="18007" class="Number">1</a> <a id="18009" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">::</a> <a id="18012" href="1--Type-Theory.1-2--Inductive-Types.html#14773" class="InductiveConstructor">[]</a><a id="18014" class="Symbol">)</a>
</pre>
<h2 id="integers"><a class="header" href="#integers">Integers</a></h2>
<p>We can use the type of natural numbers as a stepping stone to the
integers. An integer is either a natural number or a <em>strictly</em>
negative integer. We have to be careful here, we don’t want to
accidentally have more than one way to represent 0! =Turning this into
an inductive definition:</p>
<pre class="Agda"><a id="18329" class="Keyword">data</a> <a id="ℤ"></a><a id="18334" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="18336" class="Symbol">:</a> <a id="18338" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="18343" class="Keyword">where</a>
  <a id="ℤ.pos"></a><a id="18351" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a>    <a id="18358" class="Symbol">:</a> <a id="18360" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="18362" class="Symbol">→</a> <a id="18364" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
  <a id="ℤ.negsuc"></a><a id="18368" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="18375" class="Symbol">:</a> <a id="18377" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="18379" class="Symbol">→</a> <a id="18381" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
</pre>
<p>The <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a></code> constructor represents the negative of the
successor of a natural number, so <code>negsuc n</code> represents <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>.</p>
<p>We can define integer versions of the various arithmetic operations
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#12321" class="Function">+ℕ</a></code>, <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#13603" class="Function">·ℕ</a></code>, and so on. First, we need a few helper functions. This
first one negates a natural number into an integer. We can’t just
define <code>negℕ n = negsuc n</code>, because this would send <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>!</p>
<pre class="Agda"><a id="negℕ"></a><a id="18796" href="1--Type-Theory.1-2--Inductive-Types.html#18796" class="Function">negℕ</a> <a id="18801" class="Symbol">:</a> <a id="18803" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="18805" class="Symbol">→</a> <a id="18807" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
<a id="18809" href="1--Type-Theory.1-2--Inductive-Types.html#18796" class="Function">negℕ</a> <a id="18814" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="18819" class="Symbol">=</a> <a id="18821" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="18825" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>
<a id="18830" href="1--Type-Theory.1-2--Inductive-Types.html#18796" class="Function">negℕ</a> <a id="18835" class="Symbol">(</a><a id="18836" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="18840" href="1--Type-Theory.1-2--Inductive-Types.html#18840" class="Bound">n</a><a id="18841" class="Symbol">)</a> <a id="18843" class="Symbol">=</a> <a id="18845" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="18852" href="1--Type-Theory.1-2--Inductive-Types.html#18840" class="Bound">n</a>
</pre>
<div class="info">
<p><span class="info-label">Aside:</span>
The following code snippet hooks <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a></code> into the same mechanism as
<code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code> that lets us write numerals rather than chains of <code class="Agda"><a href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a></code> and
<code class="Agda"><a href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a></code>. Pay no attention to the man behind the curtain!</p>
<pre class="Agda"><a id="19067" class="Keyword">instance</a>
  <a id="Number-ℤ"></a><a id="19078" href="1--Type-Theory.1-2--Inductive-Types.html#19078" class="Function">Number-ℤ</a> <a id="19087" class="Symbol">:</a> <a id="19089" href="Library.Prelude.html#4021" class="Record">Number</a> <a id="19096" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
  <a id="19100" href="1--Type-Theory.1-2--Inductive-Types.html#19078" class="Function">Number-ℤ</a> <a id="19109" class="Symbol">.</a><a id="19110" href="Library.Prelude.html#4076" class="Field">fromNat</a> <a id="19118" class="Symbol">=</a> <a id="19120" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a>

  <a id="Negative-ℤ"></a><a id="19127" href="1--Type-Theory.1-2--Inductive-Types.html#19127" class="Function">Negative-ℤ</a> <a id="19138" class="Symbol">:</a> <a id="19140" href="Library.Prelude.html#4144" class="Record">Negative</a> <a id="19149" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
  <a id="19153" href="1--Type-Theory.1-2--Inductive-Types.html#19127" class="Function">Negative-ℤ</a> <a id="19164" class="Symbol">.</a><a id="19165" href="Library.Prelude.html#4201" class="Field">fromNeg</a> <a id="19173" class="Symbol">=</a> <a id="19175" href="1--Type-Theory.1-2--Inductive-Types.html#18796" class="Function">negℕ</a>

<a id="19181" href="1--Type-Theory.1-2--Inductive-Types.html#19181" class="Function">_</a> <a id="19183" class="Symbol">=</a> <a id="19185" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="19200" class="Number">2</a> <a id="19202" class="Symbol">(</a><a id="19203" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="19207" class="Symbol">(</a><a id="19208" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="19212" class="Symbol">(</a><a id="19213" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="19217" class="Symbol">(</a><a id="19218" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="19222" class="Symbol">))))</a>
<a id="19227" href="1--Type-Theory.1-2--Inductive-Types.html#19227" class="Function">_</a> <a id="19229" class="Symbol">=</a> <a id="19231" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="19246" class="Number">-3</a> <a id="19249" class="Symbol">(</a><a id="19250" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="19257" class="Symbol">(</a><a id="19258" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="19262" class="Symbol">(</a><a id="19263" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="19267" class="Symbol">(</a><a id="19268" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="19272" class="Symbol">))))</a>
</pre>
</div>
<p>Next, the successor function which sends <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>, and similarly
the predecessor function which sends <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span> to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>.</p>
<pre class="Agda"><a id="sucℤ"></a><a id="19415" href="1--Type-Theory.1-2--Inductive-Types.html#19415" class="Function">sucℤ</a> <a id="19420" class="Symbol">:</a> <a id="19422" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="19424" class="Symbol">→</a> <a id="19426" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
<a id="19428" class="Comment">-- Exercise:</a>
<a id="19441" class="Comment">-- sucℤ z = {!!}</a>
</pre><!--
<pre class="Agda"><a id="19471" href="1--Type-Theory.1-2--Inductive-Types.html#19415" class="Function">sucℤ</a> <a id="19476" class="Symbol">(</a><a id="19477" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="19481" href="1--Type-Theory.1-2--Inductive-Types.html#19481" class="Bound">n</a><a id="19482" class="Symbol">)</a> <a id="19484" class="Symbol">=</a> <a id="19486" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="19490" class="Symbol">(</a><a id="19491" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="19495" href="1--Type-Theory.1-2--Inductive-Types.html#19481" class="Bound">n</a><a id="19496" class="Symbol">)</a>
<a id="19498" href="1--Type-Theory.1-2--Inductive-Types.html#19415" class="Function">sucℤ</a> <a id="19503" class="Symbol">(</a><a id="19504" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="19511" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="19515" class="Symbol">)</a> <a id="19517" class="Symbol">=</a> <a id="19519" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="19523" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>
<a id="19528" href="1--Type-Theory.1-2--Inductive-Types.html#19415" class="Function">sucℤ</a> <a id="19533" class="Symbol">(</a><a id="19534" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="19541" class="Symbol">(</a><a id="19542" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="19546" href="1--Type-Theory.1-2--Inductive-Types.html#19546" class="Bound">n</a><a id="19547" class="Symbol">))</a> <a id="19550" class="Symbol">=</a> <a id="19552" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="19559" href="1--Type-Theory.1-2--Inductive-Types.html#19546" class="Bound">n</a>

</pre>-->
<pre class="Agda">
<a id="19575" href="1--Type-Theory.1-2--Inductive-Types.html#19575" class="Function">_</a> <a id="19577" class="Symbol">=</a> <a id="19579" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="19594" class="Symbol">(</a><a id="19595" href="1--Type-Theory.1-2--Inductive-Types.html#19415" class="Function">sucℤ</a> <a id="19600" class="Number">19</a><a id="19602" class="Symbol">)</a> <a id="19604" class="Number">20</a>
<a id="19607" href="1--Type-Theory.1-2--Inductive-Types.html#19607" class="Function">_</a> <a id="19609" class="Symbol">=</a> <a id="19611" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="19626" class="Symbol">(</a><a id="19627" href="1--Type-Theory.1-2--Inductive-Types.html#19415" class="Function">sucℤ</a> <a id="19632" class="Number">-34</a><a id="19635" class="Symbol">)</a> <a id="19637" class="Number">-33</a>

<a id="predℤ"></a><a id="19642" href="1--Type-Theory.1-2--Inductive-Types.html#19642" class="Function">predℤ</a> <a id="19648" class="Symbol">:</a> <a id="19650" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="19652" class="Symbol">→</a> <a id="19654" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
<a id="19656" class="Comment">-- Exercise:</a>
<a id="19669" class="Comment">-- predℤ z = {!!}</a>
</pre><!--
<pre class="Agda"><a id="19700" href="1--Type-Theory.1-2--Inductive-Types.html#19642" class="Function">predℤ</a> <a id="19706" class="Symbol">(</a><a id="19707" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="19711" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="19715" class="Symbol">)</a> <a id="19717" class="Symbol">=</a> <a id="19719" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="19726" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>
<a id="19731" href="1--Type-Theory.1-2--Inductive-Types.html#19642" class="Function">predℤ</a> <a id="19737" class="Symbol">(</a><a id="19738" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="19742" class="Symbol">(</a><a id="19743" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="19747" href="1--Type-Theory.1-2--Inductive-Types.html#19747" class="Bound">n</a><a id="19748" class="Symbol">))</a> <a id="19751" class="Symbol">=</a> <a id="19753" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="19757" href="1--Type-Theory.1-2--Inductive-Types.html#19747" class="Bound">n</a>
<a id="19759" href="1--Type-Theory.1-2--Inductive-Types.html#19642" class="Function">predℤ</a> <a id="19765" class="Symbol">(</a><a id="19766" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="19773" href="1--Type-Theory.1-2--Inductive-Types.html#19773" class="Bound">n</a><a id="19774" class="Symbol">)</a> <a id="19776" class="Symbol">=</a> <a id="19778" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="19785" class="Symbol">(</a><a id="19786" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="19790" href="1--Type-Theory.1-2--Inductive-Types.html#19773" class="Bound">n</a><a id="19791" class="Symbol">)</a>

</pre>-->
<pre class="Agda">
<a id="19807" href="1--Type-Theory.1-2--Inductive-Types.html#19807" class="Function">_</a> <a id="19809" class="Symbol">=</a> <a id="19811" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="19826" class="Symbol">(</a><a id="19827" href="1--Type-Theory.1-2--Inductive-Types.html#19642" class="Function">predℤ</a> <a id="19833" class="Number">19</a><a id="19835" class="Symbol">)</a> <a id="19837" class="Number">18</a>
<a id="19840" href="1--Type-Theory.1-2--Inductive-Types.html#19840" class="Function">_</a> <a id="19842" class="Symbol">=</a> <a id="19844" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="19859" class="Symbol">(</a><a id="19860" href="1--Type-Theory.1-2--Inductive-Types.html#19642" class="Function">predℤ</a> <a id="19866" class="Number">-34</a><a id="19869" class="Symbol">)</a> <a id="19871" class="Number">-35</a>
</pre>
<p>This was all preparation for addition of integers. Since the integers
are a disjoint union of the natural numbers and the negative numbers,
it helps to handle these two cases separately. You will have to use
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#19415" class="Function">sucℤ</a></code> and <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#19642" class="Function">predℤ</a></code> in these definitions.</p>
<pre class="Agda"><a id="20138" class="Comment">-- This should correspond to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>, where <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> is a natural number</a>
<a id="_+pos_"></a><a id="20206" href="1--Type-Theory.1-2--Inductive-Types.html#20206" class="Function Operator">_+pos_</a> <a id="20213" class="Symbol">:</a> <a id="20215" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="20217" class="Symbol">→</a> <a id="20219" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="20221" class="Symbol">→</a> <a id="20223" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
<a id="20225" class="Comment">-- Exercise:</a>
<a id="20238" class="Comment">-- z +pos n = {!!}</a>
</pre><!--
<pre class="Agda"><a id="20270" href="1--Type-Theory.1-2--Inductive-Types.html#20270" class="Bound">z</a> <a id="20272" href="1--Type-Theory.1-2--Inductive-Types.html#20206" class="Function Operator">+pos</a> <a id="20277" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="20282" class="Symbol">=</a> <a id="20284" href="1--Type-Theory.1-2--Inductive-Types.html#20270" class="Bound">z</a>
<a id="20286" href="1--Type-Theory.1-2--Inductive-Types.html#20286" class="Bound">z</a> <a id="20288" href="1--Type-Theory.1-2--Inductive-Types.html#20206" class="Function Operator">+pos</a> <a id="20293" class="Symbol">(</a><a id="20294" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="20298" href="1--Type-Theory.1-2--Inductive-Types.html#20298" class="Bound">n</a><a id="20299" class="Symbol">)</a> <a id="20301" class="Symbol">=</a> <a id="20303" href="1--Type-Theory.1-2--Inductive-Types.html#19415" class="Function">sucℤ</a> <a id="20308" class="Symbol">(</a><a id="20309" href="1--Type-Theory.1-2--Inductive-Types.html#20286" class="Bound">z</a> <a id="20311" href="1--Type-Theory.1-2--Inductive-Types.html#20206" class="Function Operator">+pos</a> <a id="20316" href="1--Type-Theory.1-2--Inductive-Types.html#20298" class="Bound">n</a><a id="20317" class="Symbol">)</a>

</pre>-->
<pre class="Agda">
<a id="20333" class="Comment">-- This should correspond to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, where <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> is a natural number</a>
<a id="_+negsuc_"></a><a id="20406" href="1--Type-Theory.1-2--Inductive-Types.html#20406" class="Function Operator">_+negsuc_</a> <a id="20416" class="Symbol">:</a> <a id="20418" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="20420" class="Symbol">→</a> <a id="20422" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="20424" class="Symbol">→</a> <a id="20426" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
<a id="20428" class="Comment">-- Exercise:</a>
<a id="20441" class="Comment">-- z +negsuc n = {!!}</a>
</pre><!--
<pre class="Agda"><a id="20476" href="1--Type-Theory.1-2--Inductive-Types.html#20476" class="Bound">z</a> <a id="20478" href="1--Type-Theory.1-2--Inductive-Types.html#20406" class="Function Operator">+negsuc</a> <a id="20486" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="20491" class="Symbol">=</a> <a id="20493" href="1--Type-Theory.1-2--Inductive-Types.html#19642" class="Function">predℤ</a> <a id="20499" href="1--Type-Theory.1-2--Inductive-Types.html#20476" class="Bound">z</a>
<a id="20501" href="1--Type-Theory.1-2--Inductive-Types.html#20501" class="Bound">z</a> <a id="20503" href="1--Type-Theory.1-2--Inductive-Types.html#20406" class="Function Operator">+negsuc</a> <a id="20511" class="Symbol">(</a><a id="20512" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="20516" href="1--Type-Theory.1-2--Inductive-Types.html#20516" class="Bound">n</a><a id="20517" class="Symbol">)</a> <a id="20519" class="Symbol">=</a> <a id="20521" href="1--Type-Theory.1-2--Inductive-Types.html#19642" class="Function">predℤ</a> <a id="20527" class="Symbol">(</a><a id="20528" href="1--Type-Theory.1-2--Inductive-Types.html#20501" class="Bound">z</a> <a id="20530" href="1--Type-Theory.1-2--Inductive-Types.html#20406" class="Function Operator">+negsuc</a> <a id="20538" href="1--Type-Theory.1-2--Inductive-Types.html#20516" class="Bound">n</a><a id="20539" class="Symbol">)</a>

</pre>-->
<pre class="Agda">
<a id="_+ℤ_"></a><a id="20555" href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function Operator">_+ℤ_</a> <a id="20560" class="Symbol">:</a> <a id="20562" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="20564" class="Symbol">→</a> <a id="20566" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="20568" class="Symbol">→</a> <a id="20570" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
<a id="20572" href="1--Type-Theory.1-2--Inductive-Types.html#20572" class="Bound">m</a> <a id="20574" href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function Operator">+ℤ</a> <a id="20577" class="Symbol">(</a><a id="20578" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="20582" href="1--Type-Theory.1-2--Inductive-Types.html#20582" class="Bound">n</a><a id="20583" class="Symbol">)</a> <a id="20585" class="Symbol">=</a> <a id="20587" href="1--Type-Theory.1-2--Inductive-Types.html#20572" class="Bound">m</a> <a id="20589" href="1--Type-Theory.1-2--Inductive-Types.html#20206" class="Function Operator">+pos</a> <a id="20594" href="1--Type-Theory.1-2--Inductive-Types.html#20582" class="Bound">n</a>
<a id="20596" href="1--Type-Theory.1-2--Inductive-Types.html#20596" class="Bound">m</a> <a id="20598" href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function Operator">+ℤ</a> <a id="20601" class="Symbol">(</a><a id="20602" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="20609" href="1--Type-Theory.1-2--Inductive-Types.html#20609" class="Bound">n</a><a id="20610" class="Symbol">)</a> <a id="20612" class="Symbol">=</a> <a id="20614" href="1--Type-Theory.1-2--Inductive-Types.html#20596" class="Bound">m</a> <a id="20616" href="1--Type-Theory.1-2--Inductive-Types.html#20406" class="Function Operator">+negsuc</a> <a id="20624" href="1--Type-Theory.1-2--Inductive-Types.html#20609" class="Bound">n</a>

<a id="20627" href="1--Type-Theory.1-2--Inductive-Types.html#20627" class="Function">_</a> <a id="20629" class="Symbol">=</a> <a id="20631" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="20646" class="Symbol">(</a><a id="20647" class="Number">0</a> <a id="20649" href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function Operator">+ℤ</a> <a id="20652" class="Number">0</a><a id="20653" class="Symbol">)</a> <a id="20655" class="Number">0</a>
<a id="20657" href="1--Type-Theory.1-2--Inductive-Types.html#20657" class="Function">_</a> <a id="20659" class="Symbol">=</a> <a id="20661" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="20676" class="Symbol">(</a><a id="20677" class="Number">0</a> <a id="20679" href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function Operator">+ℤ</a> <a id="20682" class="Number">1</a><a id="20683" class="Symbol">)</a> <a id="20685" class="Number">1</a>
<a id="20687" href="1--Type-Theory.1-2--Inductive-Types.html#20687" class="Function">_</a> <a id="20689" class="Symbol">=</a> <a id="20691" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="20706" class="Symbol">(</a><a id="20707" class="Number">1</a> <a id="20709" href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function Operator">+ℤ</a> <a id="20712" class="Number">0</a><a id="20713" class="Symbol">)</a> <a id="20715" class="Number">1</a>
<a id="20717" href="1--Type-Theory.1-2--Inductive-Types.html#20717" class="Function">_</a> <a id="20719" class="Symbol">=</a> <a id="20721" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="20736" class="Symbol">(</a><a id="20737" class="Number">19</a> <a id="20740" href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function Operator">+ℤ</a> <a id="20743" class="Number">34</a><a id="20745" class="Symbol">)</a> <a id="20747" class="Number">53</a>
<a id="20750" href="1--Type-Theory.1-2--Inductive-Types.html#20750" class="Function">_</a> <a id="20752" class="Symbol">=</a> <a id="20754" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="20769" class="Symbol">(</a><a id="20770" class="Number">-19</a> <a id="20774" href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function Operator">+ℤ</a> <a id="20777" class="Number">34</a><a id="20779" class="Symbol">)</a> <a id="20781" class="Number">15</a>
</pre>
<p>We can negate an integer, and define the subtraction of integers in
terms of addition and negation.</p>
<pre class="Agda"><a id="-_"></a><a id="20894" href="1--Type-Theory.1-2--Inductive-Types.html#20894" class="Function Operator">-_</a> <a id="20897" class="Symbol">:</a> <a id="20899" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="20901" class="Symbol">→</a> <a id="20903" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
<a id="20905" class="Comment">-- Exercise:</a>
<a id="20918" class="Comment">-- - z = {!!}</a>
</pre><!--
<pre class="Agda"><a id="20945" href="1--Type-Theory.1-2--Inductive-Types.html#20894" class="Function Operator">-</a> <a id="20947" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="20951" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="20956" class="Symbol">=</a> <a id="20958" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="20962" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>
<a id="20967" href="1--Type-Theory.1-2--Inductive-Types.html#20894" class="Function Operator">-</a> <a id="20969" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="20973" class="Symbol">(</a><a id="20974" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="20978" href="1--Type-Theory.1-2--Inductive-Types.html#20978" class="Bound">n</a><a id="20979" class="Symbol">)</a> <a id="20981" class="Symbol">=</a> <a id="20983" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="20990" href="1--Type-Theory.1-2--Inductive-Types.html#20978" class="Bound">n</a>
<a id="20992" href="1--Type-Theory.1-2--Inductive-Types.html#20894" class="Function Operator">-</a> <a id="20994" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="21001" href="1--Type-Theory.1-2--Inductive-Types.html#21001" class="Bound">n</a> <a id="21003" class="Symbol">=</a> <a id="21005" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="21009" class="Symbol">(</a><a id="21010" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="21014" href="1--Type-Theory.1-2--Inductive-Types.html#21001" class="Bound">n</a><a id="21015" class="Symbol">)</a>

</pre>-->
<pre class="Agda">
<a id="21031" href="1--Type-Theory.1-2--Inductive-Types.html#21031" class="Function">_</a> <a id="21033" class="Symbol">=</a> <a id="21035" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="21050" class="Symbol">(</a><a id="21051" href="1--Type-Theory.1-2--Inductive-Types.html#20894" class="Function Operator">-</a> <a id="21053" class="Number">0</a><a id="21054" class="Symbol">)</a> <a id="21056" class="Number">0</a>
<a id="21058" href="1--Type-Theory.1-2--Inductive-Types.html#21058" class="Function">_</a> <a id="21060" class="Symbol">=</a> <a id="21062" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="21077" class="Symbol">(</a><a id="21078" href="1--Type-Theory.1-2--Inductive-Types.html#20894" class="Function Operator">-</a> <a id="21080" class="Number">19</a><a id="21082" class="Symbol">)</a> <a id="21084" class="Symbol">(</a><a id="21085" class="Number">-19</a><a id="21088" class="Symbol">)</a>
<a id="21090" href="1--Type-Theory.1-2--Inductive-Types.html#21090" class="Function">_</a> <a id="21092" class="Symbol">=</a> <a id="21094" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="21109" class="Symbol">(</a><a id="21110" href="1--Type-Theory.1-2--Inductive-Types.html#20894" class="Function Operator">-</a> <a id="21112" class="Symbol">(</a><a id="21113" class="Number">-34</a><a id="21116" class="Symbol">))</a> <a id="21119" class="Number">34</a>

<a id="_-ℤ_"></a><a id="21123" href="1--Type-Theory.1-2--Inductive-Types.html#21123" class="Function Operator">_-ℤ_</a> <a id="21128" class="Symbol">:</a> <a id="21130" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="21132" class="Symbol">→</a> <a id="21134" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="21136" class="Symbol">→</a> <a id="21138" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
<a id="21140" href="1--Type-Theory.1-2--Inductive-Types.html#21140" class="Bound">m</a> <a id="21142" href="1--Type-Theory.1-2--Inductive-Types.html#21123" class="Function Operator">-ℤ</a> <a id="21145" href="1--Type-Theory.1-2--Inductive-Types.html#21145" class="Bound">n</a> <a id="21147" class="Symbol">=</a> <a id="21149" href="1--Type-Theory.1-2--Inductive-Types.html#21140" class="Bound">m</a> <a id="21151" href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function Operator">+ℤ</a> <a id="21154" class="Symbol">(</a><a id="21155" href="1--Type-Theory.1-2--Inductive-Types.html#20894" class="Function Operator">-</a> <a id="21157" href="1--Type-Theory.1-2--Inductive-Types.html#21145" class="Bound">n</a><a id="21158" class="Symbol">)</a>
</pre>
<p>See if you can come up with the correct definition for multiplication
of integers. This can be done by case-splitting on only one of the
sides.</p>
<pre class="Agda"><a id="_·ℤ_"></a><a id="21314" href="1--Type-Theory.1-2--Inductive-Types.html#21314" class="Function Operator">_·ℤ_</a> <a id="21319" class="Symbol">:</a> <a id="21321" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="21323" class="Symbol">→</a> <a id="21325" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="21327" class="Symbol">→</a> <a id="21329" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
<a id="21331" class="Comment">-- Exercise:</a>
<a id="21344" class="Comment">-- n ·ℤ m = {!!}</a>
</pre><!--
<pre class="Agda"><a id="21374" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="21378" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="21383" href="1--Type-Theory.1-2--Inductive-Types.html#21314" class="Function Operator">·ℤ</a> <a id="21386" href="1--Type-Theory.1-2--Inductive-Types.html#21386" class="Bound">m</a> <a id="21388" class="Symbol">=</a> <a id="21390" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="21394" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>
<a id="21399" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="21403" class="Symbol">(</a><a id="21404" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="21408" href="1--Type-Theory.1-2--Inductive-Types.html#21408" class="Bound">n</a><a id="21409" class="Symbol">)</a> <a id="21411" href="1--Type-Theory.1-2--Inductive-Types.html#21314" class="Function Operator">·ℤ</a> <a id="21414" href="1--Type-Theory.1-2--Inductive-Types.html#21414" class="Bound">m</a> <a id="21416" class="Symbol">=</a> <a id="21418" href="1--Type-Theory.1-2--Inductive-Types.html#21414" class="Bound">m</a> <a id="21420" href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function Operator">+ℤ</a> <a id="21423" class="Symbol">(</a><a id="21424" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="21428" href="1--Type-Theory.1-2--Inductive-Types.html#21408" class="Bound">n</a> <a id="21430" href="1--Type-Theory.1-2--Inductive-Types.html#21314" class="Function Operator">·ℤ</a> <a id="21433" href="1--Type-Theory.1-2--Inductive-Types.html#21414" class="Bound">m</a><a id="21434" class="Symbol">)</a>
<a id="21436" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="21443" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="21448" href="1--Type-Theory.1-2--Inductive-Types.html#21314" class="Function Operator">·ℤ</a> <a id="21451" href="1--Type-Theory.1-2--Inductive-Types.html#21451" class="Bound">m</a> <a id="21453" class="Symbol">=</a> <a id="21455" href="1--Type-Theory.1-2--Inductive-Types.html#20894" class="Function Operator">-</a> <a id="21457" href="1--Type-Theory.1-2--Inductive-Types.html#21451" class="Bound">m</a>
<a id="21459" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="21466" class="Symbol">(</a><a id="21467" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="21471" href="1--Type-Theory.1-2--Inductive-Types.html#21471" class="Bound">n</a><a id="21472" class="Symbol">)</a> <a id="21474" href="1--Type-Theory.1-2--Inductive-Types.html#21314" class="Function Operator">·ℤ</a> <a id="21477" href="1--Type-Theory.1-2--Inductive-Types.html#21477" class="Bound">m</a> <a id="21479" class="Symbol">=</a> <a id="21481" href="1--Type-Theory.1-2--Inductive-Types.html#20894" class="Function Operator">-</a> <a id="21483" href="1--Type-Theory.1-2--Inductive-Types.html#21477" class="Bound">m</a> <a id="21485" href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function Operator">+ℤ</a> <a id="21488" class="Symbol">(</a><a id="21489" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="21496" href="1--Type-Theory.1-2--Inductive-Types.html#21471" class="Bound">n</a> <a id="21498" href="1--Type-Theory.1-2--Inductive-Types.html#21314" class="Function Operator">·ℤ</a> <a id="21501" href="1--Type-Theory.1-2--Inductive-Types.html#21477" class="Bound">m</a><a id="21502" class="Symbol">)</a>

</pre>-->
<pre class="Agda">
<a id="21518" href="1--Type-Theory.1-2--Inductive-Types.html#21518" class="Function">_</a> <a id="21520" class="Symbol">=</a> <a id="21522" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="21537" class="Symbol">(</a><a id="21538" class="Number">0</a> <a id="21540" href="1--Type-Theory.1-2--Inductive-Types.html#21314" class="Function Operator">·ℤ</a> <a id="21543" class="Number">0</a><a id="21544" class="Symbol">)</a> <a id="21546" class="Number">0</a>
<a id="21548" href="1--Type-Theory.1-2--Inductive-Types.html#21548" class="Function">_</a> <a id="21550" class="Symbol">=</a> <a id="21552" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="21567" class="Symbol">(</a><a id="21568" class="Number">2</a> <a id="21570" href="1--Type-Theory.1-2--Inductive-Types.html#21314" class="Function Operator">·ℤ</a> <a id="21573" class="Number">3</a><a id="21574" class="Symbol">)</a> <a id="21576" class="Number">6</a>
<a id="21578" href="1--Type-Theory.1-2--Inductive-Types.html#21578" class="Function">_</a> <a id="21580" class="Symbol">=</a> <a id="21582" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="21597" class="Symbol">(</a><a id="21598" class="Number">2</a> <a id="21600" href="1--Type-Theory.1-2--Inductive-Types.html#21314" class="Function Operator">·ℤ</a> <a id="21603" class="Number">-3</a><a id="21605" class="Symbol">)</a> <a id="21607" class="Number">-6</a>
<a id="21610" href="1--Type-Theory.1-2--Inductive-Types.html#21610" class="Function">_</a> <a id="21612" class="Symbol">=</a> <a id="21614" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="21629" class="Symbol">(</a><a id="21630" class="Number">-2</a> <a id="21633" href="1--Type-Theory.1-2--Inductive-Types.html#21314" class="Function Operator">·ℤ</a> <a id="21636" class="Number">3</a><a id="21637" class="Symbol">)</a> <a id="21639" class="Number">-6</a>
<a id="21642" href="1--Type-Theory.1-2--Inductive-Types.html#21642" class="Function">_</a> <a id="21644" class="Symbol">=</a> <a id="21646" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="21661" class="Symbol">(</a><a id="21662" class="Number">-2</a> <a id="21665" href="1--Type-Theory.1-2--Inductive-Types.html#21314" class="Function Operator">·ℤ</a> <a id="21668" class="Number">-3</a><a id="21670" class="Symbol">)</a> <a id="21672" class="Number">6</a>
</pre>
<p>Make sure to test this one via <code>C-c C-n</code>, especially the
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a></code> cases! They are easy to get wrong.</p>
<h2 id="recursion-principles"><a class="header" href="#recursion-principles">Recursion Principles</a></h2>
<p>As we mentioned above, these inductive data types are characterised by
their “induction principles”. In this lecture we focus on a simpler
version of this principle, “recursion”, and will return to induction
in Lecture 1-X.</p>
<p>The recursion principle for a type packs together the data that is
necessary to produce a function out of it into some other type. In the
case of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code>, to construct a function <code>Bool → A</code> for any type <code>A</code>
we just need two elements of <code>A</code> to serve as the values of the
function when the <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> is <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a></code> and <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a></code>. We can write out
the recursion principle for <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> as follows:</p>
<pre class="Agda"><a id="Bool-rec"></a><a id="22430" href="1--Type-Theory.1-2--Inductive-Types.html#22430" class="Function">Bool-rec</a> <a id="22439" class="Symbol">:</a> <a id="22441" class="Symbol">{</a><a id="22442" href="1--Type-Theory.1-2--Inductive-Types.html#22442" class="Bound">A</a> <a id="22444" class="Symbol">:</a> <a id="22446" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="22450" class="Symbol">}</a>
  <a id="22454" class="Symbol">→</a> <a id="22456" href="1--Type-Theory.1-2--Inductive-Types.html#22442" class="Bound">A</a>
  <a id="22460" class="Symbol">→</a> <a id="22462" href="1--Type-Theory.1-2--Inductive-Types.html#22442" class="Bound">A</a>
  <a id="22466" class="Symbol">→</a> <a id="22468" class="Symbol">(</a><a id="22469" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="22474" class="Symbol">→</a> <a id="22476" href="1--Type-Theory.1-2--Inductive-Types.html#22442" class="Bound">A</a><a id="22477" class="Symbol">)</a>
<a id="22479" href="1--Type-Theory.1-2--Inductive-Types.html#22430" class="Function">Bool-rec</a> <a id="22488" href="1--Type-Theory.1-2--Inductive-Types.html#22488" class="Bound">a1</a> <a id="22491" href="1--Type-Theory.1-2--Inductive-Types.html#22491" class="Bound">a2</a> <a id="22494" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="22499" class="Symbol">=</a> <a id="22501" href="1--Type-Theory.1-2--Inductive-Types.html#22488" class="Bound">a1</a>
<a id="22504" href="1--Type-Theory.1-2--Inductive-Types.html#22430" class="Function">Bool-rec</a> <a id="22513" href="1--Type-Theory.1-2--Inductive-Types.html#22513" class="Bound">a1</a> <a id="22516" href="1--Type-Theory.1-2--Inductive-Types.html#22516" class="Bound">a2</a> <a id="22519" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="22525" class="Symbol">=</a> <a id="22527" href="1--Type-Theory.1-2--Inductive-Types.html#22516" class="Bound">a2</a>
</pre>
<p>The <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> type is so simple that the name “recursion” feels
inappropriate: the recursion principle doesn’t actually do any
recursion! The name will make more sense when we do the same for
<code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code>.</p>
<div class="info">
<p><span class="info-label">Aside:</span>
The recursion principle for Booleans has a more familiar name: the
“if/then/else” pattern familiar from almost every programming
language:</p>
<pre class="Agda"><a id="if-then-else"></a><a id="22889" href="1--Type-Theory.1-2--Inductive-Types.html#22889" class="Function">if-then-else</a> <a id="22902" class="Symbol">:</a> <a id="22904" class="Symbol">{</a><a id="22905" href="1--Type-Theory.1-2--Inductive-Types.html#22905" class="Bound">A</a> <a id="22907" class="Symbol">:</a> <a id="22909" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="22913" class="Symbol">}</a>
  <a id="22917" class="Symbol">→</a> <a id="22919" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
  <a id="22926" class="Symbol">→</a> <a id="22928" href="1--Type-Theory.1-2--Inductive-Types.html#22905" class="Bound">A</a>
  <a id="22932" class="Symbol">→</a> <a id="22934" href="1--Type-Theory.1-2--Inductive-Types.html#22905" class="Bound">A</a>
  <a id="22938" class="Symbol">→</a> <a id="22940" href="1--Type-Theory.1-2--Inductive-Types.html#22905" class="Bound">A</a>
<a id="22942" href="1--Type-Theory.1-2--Inductive-Types.html#22889" class="Function">if-then-else</a> <a id="22955" href="1--Type-Theory.1-2--Inductive-Types.html#22955" class="Bound">b</a> <a id="22957" href="1--Type-Theory.1-2--Inductive-Types.html#22957" class="Bound">a1</a> <a id="22960" href="1--Type-Theory.1-2--Inductive-Types.html#22960" class="Bound">a2</a> <a id="22963" class="Symbol">=</a> <a id="22965" href="1--Type-Theory.1-2--Inductive-Types.html#22430" class="Function">Bool-rec</a> <a id="22974" href="1--Type-Theory.1-2--Inductive-Types.html#22957" class="Bound">a1</a> <a id="22977" href="1--Type-Theory.1-2--Inductive-Types.html#22960" class="Bound">a2</a> <a id="22980" href="1--Type-Theory.1-2--Inductive-Types.html#22955" class="Bound">b</a>
</pre>
</div>
<p>This function is one side of a universal mapping property. Given two
elements of <code>A</code>, we can make a function <code>Bool → A</code>. But from such a
function we can also extract the two elements of <code>A</code> we started with:</p>
<pre class="Agda"><a id="Bool-rec-fro"></a><a id="23203" href="1--Type-Theory.1-2--Inductive-Types.html#23203" class="Function">Bool-rec-fro</a> <a id="23216" class="Symbol">:</a> <a id="23218" class="Symbol">{</a><a id="23219" href="1--Type-Theory.1-2--Inductive-Types.html#23219" class="Bound">A</a> <a id="23221" class="Symbol">:</a> <a id="23223" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="23227" class="Symbol">}</a>
  <a id="23231" class="Symbol">→</a> <a id="23233" class="Symbol">(</a><a id="23234" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="23239" class="Symbol">→</a> <a id="23241" href="1--Type-Theory.1-2--Inductive-Types.html#23219" class="Bound">A</a><a id="23242" class="Symbol">)</a>
  <a id="23246" class="Symbol">→</a> <a id="23248" href="1--Type-Theory.1-2--Inductive-Types.html#23219" class="Bound">A</a> <a id="23250" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="23252" href="1--Type-Theory.1-2--Inductive-Types.html#23219" class="Bound">A</a>
<a id="23254" class="Comment">-- Exercise:</a>
<a id="23267" class="Comment">-- Bool-rec-fro f = {!!}</a>
</pre><!--
<pre class="Agda"><a id="23305" href="1--Type-Theory.1-2--Inductive-Types.html#23203" class="Function">Bool-rec-fro</a> <a id="23318" href="1--Type-Theory.1-2--Inductive-Types.html#23318" class="Bound">f</a> <a id="23320" class="Symbol">=</a> <a id="23322" href="1--Type-Theory.1-2--Inductive-Types.html#23318" class="Bound">f</a> <a id="23324" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="23329" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="23331" href="1--Type-Theory.1-2--Inductive-Types.html#23318" class="Bound">f</a> <a id="23333" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>

</pre>-->
<p>We won’t usually need to use the recursion principle <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#22430" class="Function">Bool-rec</a></code> by
that name: instead, we can just do an ordinary pattern match on an
argument of type <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code>. But, for some practice, try using
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#22430" class="Function">Bool-rec</a></code> to re-implement these:</p>
<pre class="Agda"><a id="not-fromRec"></a><a id="23595" href="1--Type-Theory.1-2--Inductive-Types.html#23595" class="Function">not-fromRec</a> <a id="23607" class="Symbol">:</a> <a id="23609" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="23614" class="Symbol">→</a> <a id="23616" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="23621" class="Comment">-- Exercise: (Don&#39;t pattern match on `x`!)</a>
<a id="23664" class="Comment">-- not-fromRec x = Bool-rec {!!} {!!} {!!}</a>
</pre><!--
<pre class="Agda"><a id="23720" href="1--Type-Theory.1-2--Inductive-Types.html#23595" class="Function">not-fromRec</a> <a id="23732" href="1--Type-Theory.1-2--Inductive-Types.html#23732" class="Bound">x</a> <a id="23734" class="Symbol">=</a> <a id="23736" href="1--Type-Theory.1-2--Inductive-Types.html#22430" class="Function">Bool-rec</a> <a id="23745" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="23751" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="23756" href="1--Type-Theory.1-2--Inductive-Types.html#23732" class="Bound">x</a>

</pre>-->
<pre class="Agda">
<a id="23772" class="Comment">-- You will need to use `Bool-rec` twice!</a>
<a id="or-fromRec"></a><a id="23814" href="1--Type-Theory.1-2--Inductive-Types.html#23814" class="Function">or-fromRec</a> <a id="23825" class="Symbol">:</a> <a id="23827" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="23832" class="Symbol">→</a> <a id="23834" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="23839" class="Symbol">→</a> <a id="23841" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="23846" class="Comment">-- Exercise: (Don&#39;t pattern match on either `x` or `y`!)</a>
<a id="23903" class="Comment">-- or-fromRec x y = Bool-rec {!!} {!!} {!!}</a>
</pre><!--
<pre class="Agda"><a id="23960" href="1--Type-Theory.1-2--Inductive-Types.html#23814" class="Function">or-fromRec</a> <a id="23971" href="1--Type-Theory.1-2--Inductive-Types.html#23971" class="Bound">x</a> <a id="23973" href="1--Type-Theory.1-2--Inductive-Types.html#23973" class="Bound">y</a> <a id="23975" class="Symbol">=</a> <a id="23977" href="1--Type-Theory.1-2--Inductive-Types.html#22430" class="Function">Bool-rec</a> <a id="23986" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="23991" class="Symbol">(</a><a id="23992" href="1--Type-Theory.1-2--Inductive-Types.html#22430" class="Function">Bool-rec</a> <a id="24001" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="24006" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="24012" href="1--Type-Theory.1-2--Inductive-Types.html#23973" class="Bound">y</a><a id="24013" class="Symbol">)</a> <a id="24015" href="1--Type-Theory.1-2--Inductive-Types.html#23971" class="Bound">x</a>

</pre>-->
<p>The recursion principle for the unit type is even simpler. To define a
function <code>⊤ → A</code>, it suffices to give an element of <code>A</code> (which is to
be the image of the unique element <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a></code>), and that’s it.</p>
<pre class="Agda"><a id="⊤-rec"></a><a id="24239" href="1--Type-Theory.1-2--Inductive-Types.html#24239" class="Function">⊤-rec</a> <a id="24245" class="Symbol">:</a> <a id="24247" class="Symbol">{</a><a id="24248" href="1--Type-Theory.1-2--Inductive-Types.html#24248" class="Bound">A</a> <a id="24250" class="Symbol">:</a> <a id="24252" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="24256" class="Symbol">}</a>
  <a id="24260" class="Symbol">→</a> <a id="24262" href="1--Type-Theory.1-2--Inductive-Types.html#24248" class="Bound">A</a>
  <a id="24266" class="Symbol">→</a> <a id="24268" class="Symbol">(</a><a id="24269" href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a> <a id="24271" class="Symbol">→</a> <a id="24273" href="1--Type-Theory.1-2--Inductive-Types.html#24248" class="Bound">A</a><a id="24274" class="Symbol">)</a>
<a id="24276" href="1--Type-Theory.1-2--Inductive-Types.html#24239" class="Function">⊤-rec</a> <a id="24282" href="1--Type-Theory.1-2--Inductive-Types.html#24282" class="Bound">a</a> <a id="24284" href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a> <a id="24287" class="Symbol">=</a> <a id="24289" href="1--Type-Theory.1-2--Inductive-Types.html#24282" class="Bound">a</a>
</pre>
<p>Again, we can go back: from such a function <code>⊤ → A</code>, we can recover
the original value of <code>A</code>:</p>
<pre class="Agda"><a id="⊤-rec-fro"></a><a id="24396" href="1--Type-Theory.1-2--Inductive-Types.html#24396" class="Function">⊤-rec-fro</a> <a id="24406" class="Symbol">:</a> <a id="24408" class="Symbol">{</a><a id="24409" href="1--Type-Theory.1-2--Inductive-Types.html#24409" class="Bound">A</a> <a id="24411" class="Symbol">:</a> <a id="24413" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="24417" class="Symbol">}</a>
  <a id="24421" class="Symbol">→</a> <a id="24423" class="Symbol">(</a><a id="24424" href="1--Type-Theory.1-2--Inductive-Types.html#8438" class="Datatype">⊤</a> <a id="24426" class="Symbol">→</a> <a id="24428" href="1--Type-Theory.1-2--Inductive-Types.html#24409" class="Bound">A</a><a id="24429" class="Symbol">)</a>
  <a id="24433" class="Symbol">→</a> <a id="24435" href="1--Type-Theory.1-2--Inductive-Types.html#24409" class="Bound">A</a>
<a id="24437" href="1--Type-Theory.1-2--Inductive-Types.html#24396" class="Function">⊤-rec-fro</a> <a id="24447" href="1--Type-Theory.1-2--Inductive-Types.html#24447" class="Bound">f</a> <a id="24449" class="Symbol">=</a> <a id="24451" href="1--Type-Theory.1-2--Inductive-Types.html#24447" class="Bound">f</a> <a id="24453" href="1--Type-Theory.1-2--Inductive-Types.html#8455" class="InductiveConstructor">tt</a>
</pre>
<p>More excitingly, we have the recursion principle for <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code>. To define
a function <code>ℕ → A</code>, we need an element of a <code>A</code> to use for <code class="Agda"><a href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a></code>,
and a function <code>A → A</code> that takes us from the value for <code>n</code> to the
value for <code>suc n</code>. By ordinary mathematical induction, this will be
enough to give a value to every element of <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code>.</p>
<pre class="Agda"><a id="ℕ-rec"></a><a id="24790" href="1--Type-Theory.1-2--Inductive-Types.html#24790" class="Function">ℕ-rec</a> <a id="24796" class="Symbol">:</a> <a id="24798" class="Symbol">{</a><a id="24799" href="1--Type-Theory.1-2--Inductive-Types.html#24799" class="Bound">A</a> <a id="24801" class="Symbol">:</a> <a id="24803" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="24807" class="Symbol">}</a>
  <a id="24811" class="Symbol">→</a> <a id="24813" href="1--Type-Theory.1-2--Inductive-Types.html#24799" class="Bound">A</a>                 <a id="24831" class="Comment">-- The base casea</a>
  <a id="24851" class="Symbol">→</a> <a id="24853" class="Symbol">(</a><a id="24854" href="1--Type-Theory.1-2--Inductive-Types.html#24799" class="Bound">A</a> <a id="24856" class="Symbol">→</a> <a id="24858" href="1--Type-Theory.1-2--Inductive-Types.html#24799" class="Bound">A</a><a id="24859" class="Symbol">)</a>           <a id="24871" class="Comment">-- The recursion law</a>
  <a id="24894" class="Symbol">→</a> <a id="24896" class="Symbol">(</a><a id="24897" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="24899" class="Symbol">→</a> <a id="24901" href="1--Type-Theory.1-2--Inductive-Types.html#24799" class="Bound">A</a><a id="24902" class="Symbol">)</a>
<a id="24904" href="1--Type-Theory.1-2--Inductive-Types.html#24790" class="Function">ℕ-rec</a> <a id="24910" href="1--Type-Theory.1-2--Inductive-Types.html#24910" class="Bound">a</a> <a id="24912" href="1--Type-Theory.1-2--Inductive-Types.html#24912" class="Bound">r</a> <a id="24914" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="24919" class="Symbol">=</a> <a id="24921" href="1--Type-Theory.1-2--Inductive-Types.html#24910" class="Bound">a</a>
<a id="24923" href="1--Type-Theory.1-2--Inductive-Types.html#24790" class="Function">ℕ-rec</a> <a id="24929" href="1--Type-Theory.1-2--Inductive-Types.html#24929" class="Bound">a</a> <a id="24931" href="1--Type-Theory.1-2--Inductive-Types.html#24931" class="Bound">r</a> <a id="24933" class="Symbol">(</a><a id="24934" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="24938" href="1--Type-Theory.1-2--Inductive-Types.html#24938" class="Bound">n</a><a id="24939" class="Symbol">)</a> <a id="24941" class="Symbol">=</a> <a id="24943" href="1--Type-Theory.1-2--Inductive-Types.html#24931" class="Bound">r</a> <a id="24945" class="Symbol">(</a><a id="24946" href="1--Type-Theory.1-2--Inductive-Types.html#24790" class="Function">ℕ-rec</a> <a id="24952" href="1--Type-Theory.1-2--Inductive-Types.html#24929" class="Bound">a</a> <a id="24954" href="1--Type-Theory.1-2--Inductive-Types.html#24931" class="Bound">r</a> <a id="24956" href="1--Type-Theory.1-2--Inductive-Types.html#24938" class="Bound">n</a><a id="24957" class="Symbol">)</a>
</pre>
<p>Try re-implementing <code class="Agda"><a href="1--Type-Theory.1-1--Types-and-Functions.html#4177" class="Function">double</a></code> using <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#24790" class="Function">ℕ-rec</a></code>:</p>
<pre class="Agda"><a id="double&#39;"></a><a id="25017" href="1--Type-Theory.1-2--Inductive-Types.html#25017" class="Function">double&#39;</a> <a id="25025" class="Symbol">:</a> <a id="25027" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="25029" class="Symbol">→</a> <a id="25031" href="Library.Prelude.html#3629" class="Datatype">ℕ</a>
<a id="25033" class="Comment">-- Exercise:</a>
<a id="25046" class="Comment">-- double&#39; = ℕ-rec {!!} {!!}</a>
</pre><!--
<pre class="Agda"><a id="25088" href="1--Type-Theory.1-2--Inductive-Types.html#25017" class="Function">double&#39;</a> <a id="25096" class="Symbol">=</a> <a id="25098" href="1--Type-Theory.1-2--Inductive-Types.html#24790" class="Function">ℕ-rec</a> <a id="25104" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="25109" class="Symbol">(λ</a> <a id="25112" href="1--Type-Theory.1-2--Inductive-Types.html#25112" class="Bound">n</a> <a id="25114" class="Symbol">→</a> <a id="25116" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="25120" class="Symbol">(</a><a id="25121" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="25125" href="1--Type-Theory.1-2--Inductive-Types.html#25112" class="Bound">n</a><a id="25126" class="Symbol">))</a>

</pre>-->
<p>When pattern matching, in the <code class="Agda"><a href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a></code> case we are allowed access to
access to the previous <code>n</code>: without this, functions like <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#14305" class="Function">predℕ</a></code> are
a bit irritating to write. (Try it!)</p>
<p>We can define an improved version of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#24790" class="Function">ℕ-rec</a></code> that gives access to
the current <code>n</code> in the inductive step.</p>
<pre class="Agda"><a id="ℕ-rec&#39;"></a><a id="25436" href="1--Type-Theory.1-2--Inductive-Types.html#25436" class="Function">ℕ-rec&#39;</a> <a id="25443" class="Symbol">:</a> <a id="25445" class="Symbol">{</a><a id="25446" href="1--Type-Theory.1-2--Inductive-Types.html#25446" class="Bound">A</a> <a id="25448" class="Symbol">:</a> <a id="25450" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="25454" class="Symbol">}</a>
  <a id="25458" class="Symbol">→</a> <a id="25460" href="1--Type-Theory.1-2--Inductive-Types.html#25446" class="Bound">A</a>
  <a id="25464" class="Symbol">→</a> <a id="25466" class="Symbol">(</a><a id="25467" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="25469" class="Symbol">→</a> <a id="25471" href="1--Type-Theory.1-2--Inductive-Types.html#25446" class="Bound">A</a> <a id="25473" class="Symbol">→</a> <a id="25475" href="1--Type-Theory.1-2--Inductive-Types.html#25446" class="Bound">A</a><a id="25476" class="Symbol">)</a>
  <a id="25480" class="Symbol">→</a> <a id="25482" class="Symbol">(</a><a id="25483" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="25485" class="Symbol">→</a> <a id="25487" href="1--Type-Theory.1-2--Inductive-Types.html#25446" class="Bound">A</a><a id="25488" class="Symbol">)</a>
<a id="25490" class="Comment">-- Exercise:</a>
<a id="25503" class="Comment">-- ℕ-rec&#39; a r zero = {!!}</a>
<a id="25529" class="Comment">-- ℕ-rec&#39; a r (suc n) = {!!}</a>
</pre><!--
<pre class="Agda"><a id="25571" href="1--Type-Theory.1-2--Inductive-Types.html#25436" class="Function">ℕ-rec&#39;</a> <a id="25578" href="1--Type-Theory.1-2--Inductive-Types.html#25578" class="Bound">a</a> <a id="25580" href="1--Type-Theory.1-2--Inductive-Types.html#25580" class="Bound">r</a> <a id="25582" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="25587" class="Symbol">=</a> <a id="25589" href="1--Type-Theory.1-2--Inductive-Types.html#25578" class="Bound">a</a>
<a id="25591" href="1--Type-Theory.1-2--Inductive-Types.html#25436" class="Function">ℕ-rec&#39;</a> <a id="25598" href="1--Type-Theory.1-2--Inductive-Types.html#25598" class="Bound">a</a> <a id="25600" href="1--Type-Theory.1-2--Inductive-Types.html#25600" class="Bound">r</a> <a id="25602" class="Symbol">(</a><a id="25603" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="25607" href="1--Type-Theory.1-2--Inductive-Types.html#25607" class="Bound">n</a><a id="25608" class="Symbol">)</a> <a id="25610" class="Symbol">=</a> <a id="25612" href="1--Type-Theory.1-2--Inductive-Types.html#25600" class="Bound">r</a> <a id="25614" href="1--Type-Theory.1-2--Inductive-Types.html#25607" class="Bound">n</a> <a id="25616" class="Symbol">(</a><a id="25617" href="1--Type-Theory.1-2--Inductive-Types.html#25436" class="Function">ℕ-rec&#39;</a> <a id="25624" href="1--Type-Theory.1-2--Inductive-Types.html#25598" class="Bound">a</a> <a id="25626" href="1--Type-Theory.1-2--Inductive-Types.html#25600" class="Bound">r</a> <a id="25628" href="1--Type-Theory.1-2--Inductive-Types.html#25607" class="Bound">n</a><a id="25629" class="Symbol">)</a>

</pre>-->
<p>For an extra challenge, try defining this only in terms of the less powerful
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#24790" class="Function">ℕ-rec</a></code>!</p>
<pre class="Agda"><a id="ℕ-rec&#39;&#39;"></a><a id="25742" href="1--Type-Theory.1-2--Inductive-Types.html#25742" class="Function">ℕ-rec&#39;&#39;</a> <a id="25750" class="Symbol">:</a> <a id="25752" class="Symbol">{</a><a id="25753" href="1--Type-Theory.1-2--Inductive-Types.html#25753" class="Bound">A</a> <a id="25755" class="Symbol">:</a> <a id="25757" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="25761" class="Symbol">}</a>
  <a id="25765" class="Symbol">→</a> <a id="25767" href="1--Type-Theory.1-2--Inductive-Types.html#25753" class="Bound">A</a>                 <a id="25785" class="Comment">-- The base case</a>
  <a id="25804" class="Symbol">→</a> <a id="25806" class="Symbol">(</a><a id="25807" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="25809" class="Symbol">→</a> <a id="25811" href="1--Type-Theory.1-2--Inductive-Types.html#25753" class="Bound">A</a> <a id="25813" class="Symbol">→</a> <a id="25815" href="1--Type-Theory.1-2--Inductive-Types.html#25753" class="Bound">A</a><a id="25816" class="Symbol">)</a>       <a id="25824" class="Comment">-- The recursion law</a>
  <a id="25847" class="Symbol">→</a> <a id="25849" class="Symbol">(</a><a id="25850" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="25852" class="Symbol">→</a> <a id="25854" href="1--Type-Theory.1-2--Inductive-Types.html#25753" class="Bound">A</a><a id="25855" class="Symbol">)</a>
<a id="25857" class="Comment">-- Exercise:</a>
<a id="25870" class="Comment">-- ℕ-rec&#39;&#39; a r n = ℕ-rec {!!} {!!} {!!}</a>
</pre><!--
<pre class="Agda"><a id="25923" href="1--Type-Theory.1-2--Inductive-Types.html#25742" class="Function">ℕ-rec&#39;&#39;</a> <a id="25931" href="1--Type-Theory.1-2--Inductive-Types.html#25931" class="Bound">a</a> <a id="25933" href="1--Type-Theory.1-2--Inductive-Types.html#25933" class="Bound">r</a> <a id="25935" href="1--Type-Theory.1-2--Inductive-Types.html#25935" class="Bound">n</a> <a id="25937" class="Symbol">=</a>
  <a id="25941" href="1--Type-Theory.1-2--Inductive-Types.html#24790" class="Function">ℕ-rec</a> <a id="25947" class="Symbol">(</a><a id="25948" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="25953" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="25955" href="1--Type-Theory.1-2--Inductive-Types.html#25931" class="Bound">a</a><a id="25956" class="Symbol">)</a>
        <a id="25966" class="Symbol">(λ</a> <a id="25969" href="1--Type-Theory.1-2--Inductive-Types.html#25969" class="Bound">x</a> <a id="25971" class="Symbol">→</a> <a id="25973" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="25977" class="Symbol">(</a><a id="25978" href="1--Type-Theory.1-2--Inductive-Types.html#25969" class="Bound">x</a> <a id="25980" class="Symbol">.</a><a id="25981" href="Library.Prelude.html#1106" class="Field">fst</a><a id="25984" class="Symbol">)</a> <a id="25986" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="25988" href="1--Type-Theory.1-2--Inductive-Types.html#25933" class="Bound">r</a> <a id="25990" class="Symbol">(</a><a id="25991" href="1--Type-Theory.1-2--Inductive-Types.html#25969" class="Bound">x</a> <a id="25993" class="Symbol">.</a><a id="25994" href="Library.Prelude.html#1106" class="Field">fst</a><a id="25997" class="Symbol">)</a> <a id="25999" class="Symbol">(</a><a id="26000" href="1--Type-Theory.1-2--Inductive-Types.html#25969" class="Bound">x</a> <a id="26002" class="Symbol">.</a><a id="26003" href="Library.Prelude.html#1118" class="Field">snd</a><a id="26006" class="Symbol">))</a>
        <a id="26017" href="1--Type-Theory.1-2--Inductive-Types.html#25935" class="Bound">n</a>
        <a id="26027" class="Symbol">.</a><a id="26028" href="Library.Prelude.html#1118" class="Field">snd</a>

</pre>-->
<h2 id="fixities"><a class="header" href="#fixities">Fixities</a></h2>
<p>These final lines specify the precedence that each operator has, so
that <code>a + b · c</code> is interpreted as <code>a + (b · c)</code>. They also specify
whether it associates to the left or the right, so that <code>a + b + c</code> is
interpreted as <code>(a + b) + c</code>, and <code>a :: b :: []</code> is interpreted as
<code>a :: (b :: [])</code>.</p>
<pre class="Agda"><a id="26361" class="Keyword">infix</a>  <a id="26368" class="Number">8</a> <a id="26370" href="1--Type-Theory.1-2--Inductive-Types.html#20894" class="Function Operator">-_</a>
<a id="26373" class="Keyword">infixl</a> <a id="26380" class="Number">7</a> <a id="26382" href="1--Type-Theory.1-2--Inductive-Types.html#13603" class="Function Operator">_·ℕ_</a> <a id="26387" href="1--Type-Theory.1-2--Inductive-Types.html#21314" class="Function Operator">_·ℤ_</a>
<a id="26392" class="Keyword">infixl</a> <a id="26399" class="Number">6</a> <a id="26401" href="1--Type-Theory.1-2--Inductive-Types.html#12321" class="Function Operator">_+ℕ_</a> <a id="26406" href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function Operator">_+ℤ_</a> <a id="26411" href="1--Type-Theory.1-2--Inductive-Types.html#21123" class="Function Operator">_-ℤ_</a>

<a id="26417" class="Keyword">infixr</a> <a id="26424" class="Number">5</a> <a id="26426" href="1--Type-Theory.1-2--Inductive-Types.html#14823" class="InductiveConstructor Operator">_::_</a>
<a id="26431" class="Keyword">infixr</a> <a id="26438" class="Number">5</a> <a id="26440" href="1--Type-Theory.1-2--Inductive-Types.html#16356" class="Function Operator">_++_</a>
</pre>
<h2 id="references-and-further-reading"><a class="header" href="#references-and-further-reading">References and Further Reading</a></h2>
<p>coverage checker
Elaboration:
https://jesper.sikanda.be/files/elaborating-dependent-copattern-matching.pdf
https://pl.ewi.tudelft.nl/master-projects/master/2022/10/25/kayleigh-lieverse/
https://jesper.sikanda.be/files/thesis-final-digital.pdf
https://link.springer.com/chapter/10.1007/11780274_27</p>

                  </main>
                  <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                  </div>
                </div>
            </div>
        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>


    </div>
    </body>
</html>
