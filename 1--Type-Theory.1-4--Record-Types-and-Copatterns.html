<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>1.4: Record Types and Copatterns - Introduction to Homotopy Type Theory in Cubical Agda</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/Agda.css">
        <link rel="stylesheet" href="theme/css/Agda-highlight.css">
        <link rel="stylesheet" href="theme/pagetoc.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="chapter-item affix "><a href="INSTALLING_AGDA.html">Installing Agda</a></li><li class="chapter-item affix "><a href="USING_AGDA.html">Using Agda</a></li><li class="chapter-item affix "><li class="part-title">Type Theory</li><li class="chapter-item "><a href="1--Type-Theory.1-1--Types-and-Functions.html">1.1: Types and Functions</a></li><li class="chapter-item "><a href="1--Type-Theory.1-2--Inductive-Types.html">1.2: Inductive Types</a></li><li class="chapter-item "><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html">1.3: Universes and More Inductive Types</a></li><li class="chapter-item expanded "><a href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html" class="active">1.4: Record Types and Copatterns</a></li><li class="chapter-item "><a href="1--Type-Theory.1-5--Propositions-as-Types.html">1.5: Propositions as Types</a></li><li class="chapter-item affix "><li class="part-title">Paths and Identifications</li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-1--Paths.html">2.1: Paths</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html">2.2: Equivalences and Path Algebra</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html">2.3: Substitution and J</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html">2.4: Composition and Filling</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-5--Transport.html">2.5: Transport</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-6--Univalence.html">2.6: Univalence</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-7--Propositions.html">2.7: Propositions</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-8--Sets-and-Higher-Types.html">2.8: Sets and Higher Types</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-9--Contractible-Maps.html">2.9: Contractible Maps</a></li><li class="chapter-item affix "><li class="part-title">Topics</li><li class="chapter-item "><a href="3--Topics.3-1--Structure-Identity-Principle.html">3.1: The Structure Identity Principle</a></li><li class="chapter-item "><a href="3--Topics.3-2--Modalities.html">3.2: Modalities</a></li><li class="chapter-item "><a href="3--Topics.3-3--Constructive-Logic.html">3.3: Constructive Logic</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Behind-the-Scenes</li><li class="chapter-item "><a href="Library.Primitive.html">Primitives</a></li><li class="chapter-item "><a href="Library.Prelude.html">Prelude</a></li><li class="chapter-item "><a href="Library.Univalence.html">Univalence</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="UNICODE_DICTIONARY.html">Unicode Dictionary</a></li><li class="chapter-item affix "><a href="ACKNOWLEDGEMENTS.html">Acknowledgements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <!-- <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li> -->
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Homotopy Type Theory in Cubical Agda</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/CQTS/introduction-to-cubical" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                  <main>
                    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<!--
<pre class="Agda"><a id="10" class="Keyword">module</a> <a id="17" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html" class="Module">1--Type-Theory.1-4--Record-Types-and-Copatterns</a> <a id="65" class="Keyword">where</a>

<a id="72" class="Keyword">open</a> <a id="77" class="Keyword">import</a> <a id="84" href="Library.Prelude.html" class="Module">Library.Prelude</a>
<a id="100" class="Keyword">open</a> <a id="105" class="Keyword">import</a> <a id="112" href="1--Type-Theory.1-1--Types-and-Functions.html" class="Module">1--Type-Theory.1-1--Types-and-Functions</a>
<a id="152" class="Keyword">open</a> <a id="157" class="Keyword">import</a> <a id="164" href="1--Type-Theory.1-2--Inductive-Types.html" class="Module">1--Type-Theory.1-2--Inductive-Types</a>
<a id="200" class="Keyword">open</a> <a id="205" class="Keyword">import</a> <a id="212" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html" class="Module">1--Type-Theory.1-3--Universes-and-More-Inductive-Types</a>
</pre>-->
<h1 id="lecture-1-4-record-types-and-copatterns"><a class="header" href="#lecture-1-4-record-types-and-copatterns">Lecture 1-4: Record Types and Copatterns</a></h1>
<p>mvrnote: somewhat under construction</p>
<p>On occasion we will want to package together some collection of data
into a single larger type. This is an extremely common pattern in
ordinary programming: think of <code>struct</code>s in C or C++, <code>dataclass</code>es in
Python, or simply rows in a database.</p>
<p>We already have a way of doing this by nesting Σ-types, which we have
had a taste of in <code class="Agda"><a href="1--Type-Theory.1-1--Types-and-Functions.html#34212" class="Function">Σ-assoc-toⁱ</a></code> and <code class="Agda"><a href="1--Type-Theory.1-1--Types-and-Functions.html#34549" class="Function">Σ-assoc-froⁱ</a></code>. But Agda
provides a facility known as <em>record</em> types which make these compound
types much more pleasant to use, and which are the topic of this
(fairly short) lecture.</p>
<h2 id="defining-records"><a class="header" href="#defining-records">Defining Records</a></h2>
<p>Whereas an inductive type is specified by a list of constructors, a
record type is specified by a list of <em>fields</em> and their types. An
element of the record type will consist of an element of each of the
field types.</p>
<p>Suppose for some reason we want to package a natural number, Boolean,
and element of the unit type into a single type.</p>
<pre class="Agda"><a id="1263" class="Keyword">record</a> <a id="Trio"></a><a id="1270" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1270" class="Record">Trio</a> <a id="1275" class="Symbol">:</a> <a id="1277" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="1282" class="Keyword">where</a>
  <a id="1290" class="Keyword">field</a>
    <a id="Trio.one"></a><a id="1300" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1300" class="Field">one</a> <a id="1304" class="Symbol">:</a> <a id="1306" href="Library.Prelude.html#3629" class="Datatype">ℕ</a>
    <a id="Trio.two"></a><a id="1312" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1312" class="Field">two</a> <a id="1316" class="Symbol">:</a> <a id="1318" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
    <a id="Trio.thr"></a><a id="1327" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1327" class="Field">thr</a> <a id="1331" class="Symbol">:</a> <a id="1333" href="1--Type-Theory.1-2--Inductive-Types.html#8426" class="Datatype">⊤</a>
</pre>
<p>The following line allows us to refer to <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#3546" class="InductiveConstructor">one</a></code>, <code class="Agda"><a href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1312" class="Field">two</a></code> and <code class="Agda"><a href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1327" class="Field">thr</a></code>
without qualifying them as <code>Trio.one</code>, <code>Trio.two</code> and <code>Trio.thr</code>
everywhere. We will be <code>open</code>ing all our records, so we’ll have to
make sure we give the fields descriptive names.</p>
<pre class="Agda"><a id="1595" class="Keyword">open</a> <a id="1600" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1270" class="Module">Trio</a>
</pre>
<p>Accessing the fields of a record is done by using the field names as
projections, as we saw for Σ-types in Lecture 1-1.</p>
<pre class="Agda"><a id="get-one"></a><a id="1735" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1735" class="Function">get-one</a> <a id="1743" class="Symbol">:</a> <a id="1745" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1270" class="Record">Trio</a> <a id="1750" class="Symbol">→</a> <a id="1752" href="Library.Prelude.html#3629" class="Datatype">ℕ</a>
<a id="1754" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1735" class="Function">get-one</a> <a id="1762" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1762" class="Bound">p</a> <a id="1764" class="Symbol">=</a> <a id="1766" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1762" class="Bound">p</a> <a id="1768" class="Symbol">.</a><a id="1769" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1300" class="Field">one</a>

<a id="get-two"></a><a id="1774" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1774" class="Function">get-two</a> <a id="1782" class="Symbol">:</a> <a id="1784" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1270" class="Record">Trio</a> <a id="1789" class="Symbol">→</a> <a id="1791" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="1796" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1774" class="Function">get-two</a> <a id="1804" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1804" class="Bound">p</a> <a id="1806" class="Symbol">=</a> <a id="1808" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1804" class="Bound">p</a> <a id="1810" class="Symbol">.</a><a id="1811" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1312" class="Field">two</a>

<a id="get-thr"></a><a id="1816" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1816" class="Function">get-thr</a> <a id="1824" class="Symbol">:</a> <a id="1826" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1270" class="Record">Trio</a> <a id="1831" class="Symbol">→</a> <a id="1833" href="1--Type-Theory.1-2--Inductive-Types.html#8426" class="Datatype">⊤</a>
<a id="1835" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1816" class="Function">get-thr</a> <a id="1843" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1843" class="Bound">p</a> <a id="1845" class="Symbol">=</a> <a id="1847" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1843" class="Bound">p</a> <a id="1849" class="Symbol">.</a><a id="1850" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1327" class="Field">thr</a>
</pre>
<p>It is occasionally useful to refer to a projection as a function out
of the record, for example when composing the function with something
else or passing it to a higher-order function. This can be done by
leaving off the dot.</p>
<pre class="Agda"><a id="one-isZero"></a><a id="2091" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#2091" class="Function">one-isZero</a> <a id="2102" class="Symbol">:</a> <a id="2104" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1270" class="Record">Trio</a> <a id="2109" class="Symbol">→</a> <a id="2111" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="2116" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#2091" class="Function">one-isZero</a> <a id="2127" class="Symbol">=</a> <a id="2129" href="1--Type-Theory.1-2--Inductive-Types.html#10730" class="Function">isZero</a> <a id="2136" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#3978" class="Function Operator">∘</a> <a id="2138" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1300" class="Field">one</a>
</pre>
<p>This is shorthand for an anonymous function that does the projection
properly.</p>
<pre class="Agda"><a id="2231" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#2231" class="Function">_</a> <a id="2233" class="Symbol">=</a> <a id="2235" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="2250" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1300" class="Field">one</a> <a id="2254" class="Symbol">(λ</a> <a id="2257" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#2257" class="Bound">p</a> <a id="2259" class="Symbol">→</a> <a id="2261" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#2257" class="Bound">p</a> <a id="2263" class="Symbol">.</a><a id="2264" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1300" class="Field">one</a><a id="2267" class="Symbol">)</a>
</pre>
<p>Constructing an element of a record type is done via a mirror-image
process to case-splitting on inductive types. For each field of the
record, we provide a value for that field.</p>
<pre class="Agda"><a id="favourite-trio"></a><a id="2458" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#2458" class="Function">favourite-trio</a> <a id="2473" class="Symbol">:</a> <a id="2475" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1270" class="Record">Trio</a>
<a id="2480" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#2458" class="Function">favourite-trio</a> <a id="2495" class="Symbol">=</a> <a id="2497" class="Keyword">record</a>
  <a id="2506" class="Symbol">{</a> <a id="2508" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1300" class="Field">one</a> <a id="2512" class="Symbol">=</a> <a id="2514" class="Number">19</a>
  <a id="2519" class="Symbol">;</a> <a id="2521" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1312" class="Field">two</a> <a id="2525" class="Symbol">=</a> <a id="2527" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
  <a id="2534" class="Symbol">;</a> <a id="2536" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1327" class="Field">thr</a> <a id="2540" class="Symbol">=</a> <a id="2542" href="1--Type-Theory.1-2--Inductive-Types.html#8443" class="InductiveConstructor">tt</a>
  <a id="2547" class="Symbol">}</a>
</pre>
<p>Records have their own computation rule. If you have a <code>record</code>
expression and project one of its fields, you get exactly what was
placed in that field:</p>
<pre class="Agda"><a id="2712" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#2712" class="Function">_</a> <a id="2714" class="Symbol">=</a> <a id="2716" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a>
    <a id="2735" class="Symbol">(</a><a id="2736" class="Keyword">record</a>
     <a id="2748" class="Symbol">{</a> <a id="2750" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1300" class="Field">one</a> <a id="2754" class="Symbol">=</a> <a id="2756" class="Number">19</a>
     <a id="2764" class="Symbol">;</a> <a id="2766" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1312" class="Field">two</a> <a id="2770" class="Symbol">=</a> <a id="2772" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
     <a id="2782" class="Symbol">;</a> <a id="2784" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1327" class="Field">thr</a> <a id="2788" class="Symbol">=</a> <a id="2790" href="1--Type-Theory.1-2--Inductive-Types.html#8443" class="InductiveConstructor">tt</a>
     <a id="2798" class="Symbol">}</a> <a id="2800" class="Symbol">.</a><a id="2801" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1300" class="Field">one</a><a id="2804" class="Symbol">)</a>
    <a id="2810" class="Number">19</a>

<a id="2814" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#2814" class="Function">_</a> <a id="2816" class="Symbol">=</a> <a id="2818" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a>
    <a id="2837" class="Symbol">(</a><a id="2838" class="Keyword">record</a>
     <a id="2850" class="Symbol">{</a> <a id="2852" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1300" class="Field">one</a> <a id="2856" class="Symbol">=</a> <a id="2858" class="Number">19</a>
     <a id="2866" class="Symbol">;</a> <a id="2868" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1312" class="Field">two</a> <a id="2872" class="Symbol">=</a> <a id="2874" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
     <a id="2884" class="Symbol">;</a> <a id="2886" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1327" class="Field">thr</a> <a id="2890" class="Symbol">=</a> <a id="2892" href="1--Type-Theory.1-2--Inductive-Types.html#8443" class="InductiveConstructor">tt</a>
     <a id="2900" class="Symbol">}</a> <a id="2902" class="Symbol">.</a><a id="2903" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1312" class="Field">two</a><a id="2906" class="Symbol">)</a>
    <a id="2912" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
</pre>
<p>Using records has some downsides over iterated Σ-types. When we prove
general facts about Σ-types, they will not automatically apply to any
of the record types we have defined. We will have to manually convert
to and from the corresponding Σ-type to make use of those proofs, via
maps along the lines of the following.</p>
<pre class="Agda"><a id="Trio-to"></a><a id="3246" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3246" class="Function">Trio-to</a> <a id="3254" class="Symbol">:</a> <a id="3256" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1270" class="Record">Trio</a> <a id="3261" class="Symbol">→</a> <a id="3263" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="3265" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="3267" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="3272" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="3274" href="1--Type-Theory.1-2--Inductive-Types.html#8426" class="Datatype">⊤</a>
<a id="3276" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3246" class="Function">Trio-to</a> <a id="3284" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3284" class="Bound">t</a> <a id="3286" class="Symbol">=</a> <a id="3288" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3284" class="Bound">t</a> <a id="3290" class="Symbol">.</a><a id="3291" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1300" class="Field">one</a> <a id="3295" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="3297" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3284" class="Bound">t</a> <a id="3299" class="Symbol">.</a><a id="3300" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1312" class="Field">two</a> <a id="3304" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="3306" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3284" class="Bound">t</a> <a id="3308" class="Symbol">.</a><a id="3309" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1327" class="Field">thr</a>

<a id="Trio-fro"></a><a id="3314" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3314" class="Function">Trio-fro</a> <a id="3323" class="Symbol">:</a> <a id="3325" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="3327" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="3329" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="3334" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="3336" href="1--Type-Theory.1-2--Inductive-Types.html#8426" class="Datatype">⊤</a> <a id="3338" class="Symbol">→</a> <a id="3340" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1270" class="Record">Trio</a>
<a id="3345" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3314" class="Function">Trio-fro</a> <a id="3354" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3354" class="Bound">s</a> <a id="3356" class="Symbol">=</a> <a id="3358" class="Keyword">record</a>
  <a id="3367" class="Symbol">{</a> <a id="3369" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1300" class="Field">one</a> <a id="3373" class="Symbol">=</a> <a id="3375" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3354" class="Bound">s</a> <a id="3377" class="Symbol">.</a><a id="3378" href="Library.Prelude.html#1106" class="Field">fst</a>
  <a id="3384" class="Symbol">;</a> <a id="3386" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1312" class="Field">two</a> <a id="3390" class="Symbol">=</a> <a id="3392" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3354" class="Bound">s</a> <a id="3394" class="Symbol">.</a><a id="3395" href="Library.Prelude.html#1118" class="Field">snd</a> <a id="3399" class="Symbol">.</a><a id="3400" href="Library.Prelude.html#1106" class="Field">fst</a>
  <a id="3406" class="Symbol">;</a> <a id="3408" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1327" class="Field">thr</a> <a id="3412" class="Symbol">=</a> <a id="3414" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3354" class="Bound">s</a> <a id="3416" class="Symbol">.</a><a id="3417" href="Library.Prelude.html#1118" class="Field">snd</a> <a id="3421" class="Symbol">.</a><a id="3422" href="Library.Prelude.html#1118" class="Field">snd</a>
  <a id="3428" class="Symbol">}</a>
</pre>
<p>Packing some values into a record like this is a common situation.
Agda lets us name a constructor for a record type, so that we don’t
have to use non-descriptive <code>record</code> keyword each time. This has to be
done at the moment the record type is declared, so here is a new
version of <code class="Agda"><a href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1270" class="Record">Trio</a></code> where we have done this:</p>
<pre class="Agda"><a id="3756" class="Keyword">record</a> <a id="Trio&#39;"></a><a id="3763" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3763" class="Record">Trio&#39;</a> <a id="3769" class="Symbol">:</a> <a id="3771" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="3776" class="Keyword">where</a>
  <a id="3784" class="Keyword">constructor</a> <a id="trio&#39;"></a><a id="3796" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3796" class="InductiveConstructor">trio&#39;</a>
  <a id="3804" class="Keyword">field</a>
    <a id="Trio&#39;.one&#39;"></a><a id="3814" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3814" class="Field">one&#39;</a> <a id="3819" class="Symbol">:</a> <a id="3821" href="Library.Prelude.html#3629" class="Datatype">ℕ</a>
    <a id="Trio&#39;.two&#39;"></a><a id="3827" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3827" class="Field">two&#39;</a> <a id="3832" class="Symbol">:</a> <a id="3834" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
    <a id="Trio&#39;.thr&#39;"></a><a id="3843" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3843" class="Field">thr&#39;</a> <a id="3848" class="Symbol">:</a> <a id="3850" href="1--Type-Theory.1-2--Inductive-Types.html#8426" class="Datatype">⊤</a>

<a id="3853" class="Keyword">open</a> <a id="3858" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3763" class="Module">Trio&#39;</a>
</pre>
<p>The constructor <code class="Agda"><a href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3796" class="InductiveConstructor">trio’</a></code> is now a function that accepts the fields
of the <code class="Agda"><a href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3763" class="Record">Trio’</a></code> record one at a time, and gives back a trio.</p>
<pre class="Agda"><a id="favourite-trio&#39;"></a><a id="4004" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#4004" class="Function">favourite-trio&#39;</a> <a id="4020" class="Symbol">:</a> <a id="4022" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3763" class="Record">Trio&#39;</a>
<a id="4028" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#4004" class="Function">favourite-trio&#39;</a> <a id="4044" class="Symbol">=</a> <a id="4046" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#3796" class="InductiveConstructor">trio&#39;</a> <a id="4052" class="Number">19</a> <a id="4055" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="4060" href="1--Type-Theory.1-2--Inductive-Types.html#8443" class="InductiveConstructor">tt</a>
</pre>
<h2 id="uniqueness-principle"><a class="header" href="#uniqueness-principle">Uniqueness Principle</a></h2>
<p>Records have one additional rule which can come in handy: a
<em>uniqueness</em> principle. This states that any element of a record type
can be unpacked into its fields and repacked into a record, and the
result is identical to the record we started with. One gloss on this
is that there is no extra information that can be carried by an
element of a record type: the fields are sufficient to capture
everything.</p>
<pre class="Agda"><a id="4505" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#4505" class="Function">_</a> <a id="4507" class="Symbol">=</a> <a id="4509" class="Symbol">λ</a> <a id="4511" class="Symbol">(</a><a id="4512" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#4512" class="Bound">t</a> <a id="4514" class="Symbol">:</a> <a id="4516" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1270" class="Record">Trio</a><a id="4520" class="Symbol">)</a> <a id="4522" class="Symbol">→</a> <a id="4524" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a>
      <a id="4545" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#4512" class="Bound">t</a>
      <a id="4553" class="Keyword">record</a>
       <a id="4567" class="Symbol">{</a> <a id="4569" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1300" class="Field">one</a> <a id="4573" class="Symbol">=</a> <a id="4575" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#4512" class="Bound">t</a> <a id="4577" class="Symbol">.</a><a id="4578" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1300" class="Field">one</a>
       <a id="4589" class="Symbol">;</a> <a id="4591" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1312" class="Field">two</a> <a id="4595" class="Symbol">=</a> <a id="4597" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#4512" class="Bound">t</a> <a id="4599" class="Symbol">.</a><a id="4600" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1312" class="Field">two</a>
       <a id="4611" class="Symbol">;</a> <a id="4613" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1327" class="Field">thr</a> <a id="4617" class="Symbol">=</a> <a id="4619" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#4512" class="Bound">t</a> <a id="4621" class="Symbol">.</a><a id="4622" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1327" class="Field">thr</a>
       <a id="4633" class="Symbol">}</a>
</pre>
<p>For an inductive type like <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code>, a simple uniqueness principle
would look something like the following:</p>
<pre><code>_ = λ (b : Bool) → test-identical
      b
      (case b of λ
       { true  → true
       ; false → false
       })
</code></pre>
<p>That is, every Boolean element can be replaced by one where you do
case analysis on the Boolean immediately.</p>
<p>Unfortunately, it is not possible to support this kind of uniqueness
principle for inductive types and maintain other desirable properties
of the type system. We’ve taken for granted that Agda can check that
our definitions match the types that we claim they have, and it
doesn’t get stuck in an infinite loop or give up. As innocent as this
uniqueness principle looks, general uniqueness for inductive types
ruins the “decidability” of typechecking. (See the references below).</p>
<p>Worse (arguably), a uniqueness principle for all inductive types
destroys all the “higher dimensional” structure of types, which was
one of the motivations for creating Homotopy Type Theory in the first
place!</p>
<p>There is some consolation: we can still prove that, for example, any
element of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> must equal <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a></code> or <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a></code>, as we do later
in <code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#13347" class="Function">≡Bool-LEM</a></code>. We just can’t arrange things so Agda knows
automatically that every Boolean is literally identical to one of
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a></code> or <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a></code>.</p>
<p>To summarise this section, there is a nice duality between inductive
types and record types.</p>
<div class="table-wrapper"><table><thead><tr><th>Inductive Types</th><th>Record Types</th></tr></thead><tbody>
<tr><td>Specified by the types of <em>constructors</em></td><td>Specified by the types of <em>fields</em></td></tr>
<tr><td>Created by choosing <em>one</em> constructor</td><td>Created by giving a value for <em>every</em> field</td></tr>
<tr><td>Eliminated by giving a value for <em>every</em> constructor</td><td>Eliminated by choosing <em>one</em> field</td></tr>
<tr><td>Eliminating a constructor computes to the corresponding value</td><td>Projecting the constructor computes to the corresponding value</td></tr>
<tr><td>-</td><td>A record is uniquely determined by its projections</td></tr>
</tbody></table>
</div>
<h2 id="copatterns"><a class="header" href="#copatterns">Copatterns</a></h2>
<p>There is an analogy with another type constructor we would like to
make: records are quite similar to functions, in that you define one
them by explaining what happens when you eliminate it.</p>
<p>Let’s extend the above table:</p>
<div class="table-wrapper"><table><thead><tr><th>Record Types</th><th>Function Types</th></tr></thead><tbody>
<tr><td>Specified by the types of <em>fields</em></td><td>Specified by the types of <em>argument and result</em></td></tr>
<tr><td>Created by giving a value for <em>every</em> field</td><td>Created by giving a value for <em>any possible</em> argument</td></tr>
<tr><td>Eliminated by choosing <em>one</em> field</td><td>Eliminated by choosing <em>one</em> argument</td></tr>
<tr><td>Projecting the constructor computes to the corresponding value</td><td>Applying a λ computes to the corresponding value</td></tr>
<tr><td>A record is uniquely determined by its projections</td><td>A function is uniquely determined by its applications</td></tr>
</tbody></table>
</div>
<p>Agda takes this analogy seriously, and lets us create records using
the built-in definition syntax we have been using from the start. Just
as the definition of a function gives an equation for what happens
when you apply the function, in this style the definition of a record
gives an equation for what happens when you project the record.</p>
<pre class="Agda"><a id="favourite-trio&#39;&#39;"></a><a id="8438" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#8438" class="Function">favourite-trio&#39;&#39;</a> <a id="8455" class="Symbol">:</a> <a id="8457" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1270" class="Record">Trio</a>
<a id="8462" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#8438" class="Function">favourite-trio&#39;&#39;</a> <a id="8479" class="Symbol">.</a><a id="8480" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1300" class="Field">one</a> <a id="8484" class="Symbol">=</a> <a id="8486" class="Number">19</a>
<a id="8489" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#8438" class="Function">favourite-trio&#39;&#39;</a> <a id="8506" class="Symbol">.</a><a id="8507" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1312" class="Field">two</a> <a id="8511" class="Symbol">=</a> <a id="8513" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
<a id="8518" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#8438" class="Function">favourite-trio&#39;&#39;</a> <a id="8535" class="Symbol">.</a><a id="8536" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#1327" class="Field">thr</a> <a id="8540" class="Symbol">=</a> <a id="8542" href="1--Type-Theory.1-2--Inductive-Types.html#8443" class="InductiveConstructor">tt</a>
</pre>
<p>Definition clauses like this are called <em>copatterns</em>. Ordinary pattern
matching explains what a function does when its input is a particular
constructor. Copattern matching explains what a function does its
output used by a particular <em>eliminator</em>.</p>
<p>Using copatterns can really help when working with nested record
types, as we do later in this course. Just as patterns can be nested
to pull apart nested inductive types (look at, for example,
<code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#14984" class="Function">⊎-assoc-to</a></code>), copatterns can construct nested record types:</p>
<pre class="Agda"><a id="trio×-again"></a><a id="9062" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9062" class="Function">trio×-again</a> <a id="9074" class="Symbol">:</a> <a id="9076" class="Symbol">{</a><a id="9077" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9077" class="Bound">A</a> <a id="9079" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9079" class="Bound">B</a> <a id="9081" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9081" class="Bound">C</a> <a id="9083" class="Symbol">:</a> <a id="9085" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="9089" class="Symbol">}</a> <a id="9091" class="Symbol">→</a> <a id="9093" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9077" class="Bound">A</a> <a id="9095" class="Symbol">→</a> <a id="9097" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9079" class="Bound">B</a> <a id="9099" class="Symbol">→</a> <a id="9101" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9081" class="Bound">C</a> <a id="9103" class="Symbol">→</a> <a id="9105" class="Symbol">((</a><a id="9107" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9077" class="Bound">A</a> <a id="9109" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="9111" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9079" class="Bound">B</a><a id="9112" class="Symbol">)</a> <a id="9114" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="9116" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9081" class="Bound">C</a><a id="9117" class="Symbol">)</a>
<a id="9119" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9062" class="Function">trio×-again</a> <a id="9131" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9131" class="Bound">a</a> <a id="9133" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9133" class="Bound">b</a> <a id="9135" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9135" class="Bound">c</a> <a id="9137" class="Symbol">.</a><a id="9138" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="9142" class="Symbol">.</a><a id="9143" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="9147" class="Symbol">=</a> <a id="9149" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9131" class="Bound">a</a>
<a id="9151" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9062" class="Function">trio×-again</a> <a id="9163" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9163" class="Bound">a</a> <a id="9165" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9165" class="Bound">b</a> <a id="9167" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9167" class="Bound">c</a> <a id="9169" class="Symbol">.</a><a id="9170" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="9174" class="Symbol">.</a><a id="9175" href="Library.Prelude.html#1118" class="Field">snd</a> <a id="9179" class="Symbol">=</a> <a id="9181" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9165" class="Bound">b</a>
<a id="9183" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9062" class="Function">trio×-again</a> <a id="9195" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9195" class="Bound">a</a> <a id="9197" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9197" class="Bound">b</a> <a id="9199" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9199" class="Bound">c</a> <a id="9201" class="Symbol">.</a><a id="9202" href="Library.Prelude.html#1118" class="Field">snd</a>      <a id="9211" class="Symbol">=</a> <a id="9213" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9199" class="Bound">c</a>
</pre>
<p>mvrnote: https://agda.readthedocs.io/en/v2.7.0.1/language/pattern-synonyms.html</p>
<div class="info">
<p><span class="info-label">Aside:</span>
In the type-theory literature, types which are determined by their
eliminators are often called <em>negative</em> types, as opposed to
<em>positive</em> types such as inductive types, which are determined by
their constructors. mvrnote: more</p>
</div>
<h2 id="-as-a-record-and-Σ-as-an-inductive-type"><a class="header" href="#-as-a-record-and-Σ-as-an-inductive-type">⊤ as a Record and Σ as an Inductive Type</a></h2>
<p>For some types, there is wiggle room in when to use an inductive type
vs a record type. For example, we could have defined the unit type
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8426" class="Datatype">⊤</a></code> as a record without any fields:</p>
<pre class="Agda"><a id="9772" class="Keyword">record</a> <a id="Record-⊤"></a><a id="9779" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9779" class="Record">Record-⊤</a> <a id="9788" class="Symbol">:</a> <a id="9790" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="9795" class="Keyword">where</a>
  <a id="9803" class="Keyword">constructor</a> <a id="Record-tt"></a><a id="9815" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9815" class="InductiveConstructor">Record-tt</a>
  <a id="9827" class="Comment">-- No fields!</a>
</pre>
<p>The named constructor <code class="Agda"><a href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9815" class="InductiveConstructor">Record-tt</a></code> is a function that accepts the
fields in order and gives an element of <code class="Agda"><a href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9779" class="Record">Record-⊤</a></code>. But there are no
fields, so already <code>Record-tt : Record-⊤</code>.</p>
<p>This definition has the advantage that, because of the uniqueness that
comes with record types, <em>any</em> element of <code class="Agda"><a href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9779" class="Record">Record-⊤</a></code> is identical to
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8443" class="InductiveConstructor">tt</a></code> without needing to do a pattern match to reveal this fact.</p>
<pre class="Agda"><a id="10241" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10241" class="Function">_</a> <a id="10243" class="Symbol">=</a> <a id="10245" class="Symbol">λ</a> <a id="10247" class="Symbol">(</a><a id="10248" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10248" class="Bound">u</a> <a id="10250" class="Symbol">:</a> <a id="10252" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9779" class="Record">Record-⊤</a><a id="10260" class="Symbol">)</a> <a id="10262" class="Symbol">→</a> <a id="10264" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="10279" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10248" class="Bound">u</a> <a id="10281" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#9815" class="InductiveConstructor">Record-tt</a>
<a id="10291" class="Comment">-- Fails!</a>
<a id="10301" class="Comment">-- _ = λ (u : ⊤) → test-identical u tt</a>
</pre>
<p>This is occasionally helpful, but missing it is not a big deal.</p>
<p>Back in Lecture 1-1 (and revisited in Lecture 1-X), we saw the operations
<code class="Agda"><a href="1--Type-Theory.1-1--Types-and-Functions.html#25855" class="Function">×-curry</a></code> and <code class="Agda"><a href="1--Type-Theory.1-1--Types-and-Functions.html#26219" class="Function">×-uncurry</a></code> which are mutual inverses. Putting
dependency aside, these state that to produce a map out of a pair type
<code>A × B → C</code>, it is enough to produce a map <code>A → B → C</code>. This looks
awfully like the universal mapping property of an inductive type, and
indeed we can create another version of the <code class="Agda"><a href="Library.Prelude.html#1692" class="Function">×</a></code> type as follows.</p>
<pre class="Agda"><a id="10829" class="Keyword">data</a> <a id="Inductive-×"></a><a id="10834" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10834" class="Datatype">Inductive-×</a> <a id="10846" class="Symbol">{</a><a id="10847" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10847" class="Bound">ℓ</a> <a id="10849" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10849" class="Bound">ℓ&#39;</a> <a id="10852" class="Symbol">:</a> <a id="10854" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="10859" class="Symbol">}</a> <a id="10861" class="Symbol">(</a><a id="10862" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10862" class="Bound">A</a> <a id="10864" class="Symbol">:</a> <a id="10866" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="10871" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10847" class="Bound">ℓ</a><a id="10872" class="Symbol">)</a> <a id="10874" class="Symbol">(</a><a id="10875" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10875" class="Bound">B</a> <a id="10877" class="Symbol">:</a> <a id="10879" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="10884" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10849" class="Bound">ℓ&#39;</a><a id="10886" class="Symbol">)</a> <a id="10888" class="Symbol">:</a> <a id="10890" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="10895" class="Symbol">(</a><a id="10896" href="Library.Primitive.html#1128" class="Primitive">ℓ-max</a> <a id="10902" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10847" class="Bound">ℓ</a> <a id="10904" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10849" class="Bound">ℓ&#39;</a><a id="10906" class="Symbol">)</a> <a id="10908" class="Keyword">where</a>
  <a id="Inductive-×.comma"></a><a id="10916" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10916" class="InductiveConstructor">comma</a> <a id="10922" class="Symbol">:</a> <a id="10924" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10862" class="Bound">A</a> <a id="10926" class="Symbol">→</a> <a id="10928" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10875" class="Bound">B</a> <a id="10930" class="Symbol">→</a> <a id="10932" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10834" class="Datatype">Inductive-×</a> <a id="10944" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10862" class="Bound">A</a> <a id="10946" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10875" class="Bound">B</a>

<a id="Inductive-fst"></a><a id="10949" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10949" class="Function">Inductive-fst</a> <a id="10963" class="Symbol">:</a> <a id="10965" class="Symbol">{</a><a id="10966" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10966" class="Bound">A</a> <a id="10968" class="Symbol">:</a> <a id="10970" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="10974" class="Symbol">}</a> <a id="10976" class="Symbol">{</a><a id="10977" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10977" class="Bound">B</a> <a id="10979" class="Symbol">:</a> <a id="10981" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="10985" class="Symbol">}</a> <a id="10987" class="Symbol">→</a> <a id="10989" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10834" class="Datatype">Inductive-×</a> <a id="11001" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10966" class="Bound">A</a> <a id="11003" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10977" class="Bound">B</a> <a id="11005" class="Symbol">→</a> <a id="11007" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10966" class="Bound">A</a>
<a id="11009" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10949" class="Function">Inductive-fst</a> <a id="11023" class="Symbol">(</a><a id="11024" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10916" class="InductiveConstructor">comma</a> <a id="11030" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#11030" class="Bound">a</a> <a id="11032" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#11032" class="Bound">b</a><a id="11033" class="Symbol">)</a> <a id="11035" class="Symbol">=</a> <a id="11037" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#11030" class="Bound">a</a>

<a id="Inductive-snd"></a><a id="11040" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#11040" class="Function">Inductive-snd</a> <a id="11054" class="Symbol">:</a> <a id="11056" class="Symbol">{</a><a id="11057" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#11057" class="Bound">A</a> <a id="11059" class="Symbol">:</a> <a id="11061" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="11065" class="Symbol">}</a> <a id="11067" class="Symbol">{</a><a id="11068" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#11068" class="Bound">B</a> <a id="11070" class="Symbol">:</a> <a id="11072" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="11076" class="Symbol">}</a> <a id="11078" class="Symbol">→</a> <a id="11080" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10834" class="Datatype">Inductive-×</a> <a id="11092" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#11057" class="Bound">A</a> <a id="11094" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#11068" class="Bound">B</a> <a id="11096" class="Symbol">→</a> <a id="11098" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#11068" class="Bound">B</a>
<a id="11100" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#11040" class="Function">Inductive-snd</a> <a id="11114" class="Symbol">(</a><a id="11115" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#10916" class="InductiveConstructor">comma</a> <a id="11121" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#11121" class="Bound">a</a> <a id="11123" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#11123" class="Bound">b</a><a id="11124" class="Symbol">)</a> <a id="11126" class="Symbol">=</a> <a id="11128" href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html#11123" class="Bound">b</a>
</pre>
<p>mvrnote not too burdensome</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>https://agda.readthedocs.io/en/latest/language/record-types.html
https://plfa.github.io/Connectives/
focussing?</p>
<p>eta for positive types</p>

                  </main>
                  <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                  </div>
                </div>
            </div>
        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>


    </div>
    </body>
</html>
