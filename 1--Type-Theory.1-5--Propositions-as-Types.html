<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>1.5: Propositions as Types - Introduction to Homotopy Type Theory in Cubical Agda</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/Agda.css">
        <link rel="stylesheet" href="theme/css/Agda-highlight.css">
        <link rel="stylesheet" href="theme/pagetoc.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="chapter-item affix "><a href="INSTALLING_AGDA.html">Installing Agda</a></li><li class="chapter-item affix "><a href="USING_AGDA.html">Using Agda</a></li><li class="chapter-item affix "><li class="part-title">Type Theory</li><li class="chapter-item "><a href="1--Type-Theory.1-1--Types-and-Functions.html">1.1: Types and Functions</a></li><li class="chapter-item "><a href="1--Type-Theory.1-2--Inductive-Types.html">1.2: Inductive Types</a></li><li class="chapter-item "><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html">1.3: Universes and More Inductive Types</a></li><li class="chapter-item "><a href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html">1.4: Record Types and Copatterns</a></li><li class="chapter-item expanded "><a href="1--Type-Theory.1-5--Propositions-as-Types.html" class="active">1.5: Propositions as Types</a></li><li class="chapter-item affix "><li class="part-title">Paths and Identifications</li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-1--Paths.html">2.1: Paths</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html">2.2: Equivalences and Path Algebra</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html">2.3: Substitution and J</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html">2.4: Composition and Filling</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-5--Transport.html">2.5: Transport</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-6--Univalence.html">2.6: Univalence</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-7--Propositions.html">2.7: Propositions</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-8--Sets-and-Higher-Types.html">2.8: Sets and Higher Types</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-9--Contractible-Maps.html">2.9: Contractible Maps</a></li><li class="chapter-item affix "><li class="part-title">Topics</li><li class="chapter-item "><a href="3--Topics.3-1--Structure-Identity-Principle.html">3.1: The Structure Identity Principle</a></li><li class="chapter-item "><a href="3--Topics.3-2--Modalities.html">3.2: Modalities</a></li><li class="chapter-item "><a href="3--Topics.3-3--Constructive-Logic.html">3.3: Constructive Logic</a></li><li class="chapter-item affix "><li class="part-title">Behind-the-Scenes</li><li class="chapter-item "><a href="Library.Primitive.html">Primitives</a></li><li class="chapter-item "><a href="Library.Prelude.html">Prelude</a></li><li class="chapter-item "><a href="Library.Univalence.html">Univalence</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="UNICODE_DICTIONARY.html">Unicode Dictionary</a></li><li class="chapter-item affix "><a href="ACKNOWLEDGEMENTS.html">Acknowledgements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <!-- <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li> -->
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Homotopy Type Theory in Cubical Agda</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/CQTS/introduction-to-cubical" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                  <main>
                    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<!--
<pre class="Agda"><a id="10" class="Keyword">module</a> <a id="17" href="1--Type-Theory.1-5--Propositions-as-Types.html" class="Module">1--Type-Theory.1-5--Propositions-as-Types</a> <a id="59" class="Keyword">where</a>

<a id="66" class="Keyword">open</a> <a id="71" class="Keyword">import</a> <a id="78" href="Library.Prelude.html" class="Module">Library.Prelude</a>
<a id="94" class="Keyword">open</a> <a id="99" class="Keyword">import</a> <a id="106" href="1--Type-Theory.1-1--Types-and-Functions.html" class="Module">1--Type-Theory.1-1--Types-and-Functions</a>
<a id="146" class="Keyword">open</a> <a id="151" class="Keyword">import</a> <a id="158" href="1--Type-Theory.1-2--Inductive-Types.html" class="Module">1--Type-Theory.1-2--Inductive-Types</a>
<a id="194" class="Keyword">open</a> <a id="199" class="Keyword">import</a> <a id="206" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html" class="Module">1--Type-Theory.1-3--Universes-and-More-Inductive-Types</a>
</pre>-->
<h1 id="lecture-1-5-propositions-as-types"><a class="header" href="#lecture-1-5-propositions-as-types">Lecture 1-5: Propositions as Types</a></h1>
<p>In the previous lectures we saw how to define some familiar data types
— Booleans, natural numbers, integers — and how to define some of
their familiar operations. But to do mathematics, we need to be able
to prove things about these types.</p>
<p>One way to formalize a proposition is as an element of the Booleans.
We’ve already seen several functions into the Booleans, like
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#12646" class="Function">isEven</a></code>, <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8107" class="Function">isWeekend</a></code>, <code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8532" class="Function">isLeft</a></code>, and so on. This way of
representing propositions is common in other programming languages,
but there is another, more powerful way of formalizing propositions
which is made possible by dependent types: we think of types as
themselves expressing propositions.</p>
<p>A proposition, informally speaking, is a mathematical statement for
which we know what would constitute a proof. To prove that 6 is even,
for example, we could divide it evenly. The statement “6 is even” is a
thus a proposition: we know what it would mean to prove it. Proving
that that a day <code>d</code> is on a weekend would mean showing that <code>d</code> is
Saturday or Sunday, so “<code>d</code> is on a weekend” is also a proposition,
this time a proposition about an unspecified element <code>d</code>.</p>
<p>This notion of proposition remains sensible when the thing we want to
prove is not actually true: a proof that 7 is even would also consist
of a demonstration that we can divide it evenly into two whole
numbers, but this time we can’t actually achieve that goal.</p>
<p>In this lecture, we give a first pass at a type theoretic notion of
proposition, something we will refine later in Lecture 2-X.</p>
<h2 id="propositions-as-types"><a class="header" href="#propositions-as-types">Propositions as Types</a></h2>
<p>The core of the idea is that a proposition will be encoded as a type,
and to prove the proposition will be to give an element of that type.</p>
<p>First, we have type versions of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a></code> and <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a></code>.</p>
<pre class="Agda"><a id="TrueP"></a><a id="2077" href="1--Type-Theory.1-5--Propositions-as-Types.html#2077" class="Function">TrueP</a> <a id="2083" class="Symbol">:</a> <a id="2085" href="Library.Primitive.html#422" class="Primitive">Type</a>
<a id="2090" href="1--Type-Theory.1-5--Propositions-as-Types.html#2077" class="Function">TrueP</a> <a id="2096" class="Symbol">=</a> <a id="2098" href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a>

<a id="FalseP"></a><a id="2101" href="1--Type-Theory.1-5--Propositions-as-Types.html#2101" class="Function">FalseP</a> <a id="2108" class="Symbol">:</a> <a id="2110" href="Library.Primitive.html#422" class="Primitive">Type</a>
<a id="2115" href="1--Type-Theory.1-5--Propositions-as-Types.html#2101" class="Function">FalseP</a> <a id="2122" class="Symbol">=</a> <a id="2124" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a>
</pre>
<p>The type <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a></code> has an element <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8988" class="InductiveConstructor">tt</a></code>; under the interpretation that
proofs of propositions are the elements of the types representing
those propositions, this means we can prove that <code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#2077" class="Function">TrueP</a></code> holds. On
the other hand, <code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a></code> has no elements, and therefore we can’t prove
that <code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#2101" class="Function">FalseP</a></code> holds — at least, not without assuming some
contradictory hypotheses.</p>
<p>We can turn each Boolean value into its corresponding type:</p>
<pre class="Agda"><a id="IsTrue"></a><a id="2556" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="2563" class="Symbol">:</a> <a id="2565" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="2570" class="Symbol">→</a> <a id="2572" href="Library.Primitive.html#422" class="Primitive">Type</a>
<a id="2577" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="2584" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="2590" class="Symbol">=</a> <a id="2592" href="1--Type-Theory.1-5--Propositions-as-Types.html#2077" class="Function">TrueP</a>
<a id="2598" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="2605" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="2611" class="Symbol">=</a> <a id="2613" href="1--Type-Theory.1-5--Propositions-as-Types.html#2101" class="Function">FalseP</a>
</pre>
<p>An amazing feature of propositions-as-types idea is that many of the
operations on types we have seen in the last few lectures become
familiar operations on propositions.</p>
<p>In ordinary logic, to prove <code>P and Q</code> we need to prove <code>P</code> and to
prove <code>Q</code>. That is, a proof of <code>P and Q</code> consists of a pair of proofs,
one for <code>P</code> and one for <code>Q</code>. We can turn this directly into a
definition.</p>
<pre class="Agda"><a id="_andP_"></a><a id="3013" href="1--Type-Theory.1-5--Propositions-as-Types.html#3013" class="Function Operator">_andP_</a> <a id="3020" class="Symbol">:</a> <a id="3022" class="Symbol">{</a><a id="3023" href="1--Type-Theory.1-5--Propositions-as-Types.html#3023" class="Bound">ℓ</a> <a id="3025" href="1--Type-Theory.1-5--Propositions-as-Types.html#3025" class="Bound">ℓ&#39;</a> <a id="3028" class="Symbol">:</a> <a id="3030" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="3035" class="Symbol">}</a> <a id="3037" class="Symbol">→</a> <a id="3039" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="3044" href="1--Type-Theory.1-5--Propositions-as-Types.html#3023" class="Bound">ℓ</a> <a id="3046" class="Symbol">→</a> <a id="3048" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="3053" href="1--Type-Theory.1-5--Propositions-as-Types.html#3025" class="Bound">ℓ&#39;</a> <a id="3056" class="Symbol">→</a> <a id="3058" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="3063" class="Symbol">(</a><a id="3064" href="Library.Primitive.html#1128" class="Primitive">ℓ-max</a> <a id="3070" href="1--Type-Theory.1-5--Propositions-as-Types.html#3023" class="Bound">ℓ</a> <a id="3072" href="1--Type-Theory.1-5--Propositions-as-Types.html#3025" class="Bound">ℓ&#39;</a><a id="3074" class="Symbol">)</a>
<a id="3076" href="1--Type-Theory.1-5--Propositions-as-Types.html#3076" class="Bound">P</a> <a id="3078" href="1--Type-Theory.1-5--Propositions-as-Types.html#3013" class="Function Operator">andP</a> <a id="3083" href="1--Type-Theory.1-5--Propositions-as-Types.html#3083" class="Bound">Q</a> <a id="3085" class="Symbol">=</a> <a id="3087" href="1--Type-Theory.1-5--Propositions-as-Types.html#3076" class="Bound">P</a> <a id="3089" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="3091" href="1--Type-Theory.1-5--Propositions-as-Types.html#3083" class="Bound">Q</a>
</pre>
<p>Now consider implication. Implication means that, assuming you have a
proof of <code>P</code>, you can get a proof of <code>Q</code>. This is exactly what
functions do, so we can also turn this into a definition:</p>
<pre class="Agda"><a id="_impliesP_"></a><a id="3294" href="1--Type-Theory.1-5--Propositions-as-Types.html#3294" class="Function Operator">_impliesP_</a> <a id="3305" class="Symbol">:</a> <a id="3307" class="Symbol">{</a><a id="3308" href="1--Type-Theory.1-5--Propositions-as-Types.html#3308" class="Bound">ℓ</a> <a id="3310" href="1--Type-Theory.1-5--Propositions-as-Types.html#3310" class="Bound">ℓ&#39;</a> <a id="3313" class="Symbol">:</a> <a id="3315" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="3320" class="Symbol">}</a> <a id="3322" class="Symbol">→</a> <a id="3324" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="3329" href="1--Type-Theory.1-5--Propositions-as-Types.html#3308" class="Bound">ℓ</a> <a id="3331" class="Symbol">→</a> <a id="3333" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="3338" href="1--Type-Theory.1-5--Propositions-as-Types.html#3310" class="Bound">ℓ&#39;</a> <a id="3341" class="Symbol">→</a> <a id="3343" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="3348" class="Symbol">(</a><a id="3349" href="Library.Primitive.html#1128" class="Primitive">ℓ-max</a> <a id="3355" href="1--Type-Theory.1-5--Propositions-as-Types.html#3308" class="Bound">ℓ</a> <a id="3357" href="1--Type-Theory.1-5--Propositions-as-Types.html#3310" class="Bound">ℓ&#39;</a><a id="3359" class="Symbol">)</a>
<a id="3361" href="1--Type-Theory.1-5--Propositions-as-Types.html#3361" class="Bound">P</a> <a id="3363" href="1--Type-Theory.1-5--Propositions-as-Types.html#3294" class="Function Operator">impliesP</a> <a id="3372" href="1--Type-Theory.1-5--Propositions-as-Types.html#3372" class="Bound">Q</a> <a id="3374" class="Symbol">=</a> <a id="3376" href="1--Type-Theory.1-5--Propositions-as-Types.html#3361" class="Bound">P</a> <a id="3378" class="Symbol">→</a> <a id="3380" href="1--Type-Theory.1-5--Propositions-as-Types.html#3372" class="Bound">Q</a>
</pre>
<p>Once we have these as building blocks, we can start to construct other
logical operations. When two propositions imply each other, we say
that they are <em>logically equivalent</em>:</p>
<pre class="Agda"><a id="_iffP_"></a><a id="3568" href="1--Type-Theory.1-5--Propositions-as-Types.html#3568" class="Function Operator">_iffP_</a> <a id="3575" class="Symbol">:</a> <a id="3577" class="Symbol">{</a><a id="3578" href="1--Type-Theory.1-5--Propositions-as-Types.html#3578" class="Bound">ℓ</a> <a id="3580" href="1--Type-Theory.1-5--Propositions-as-Types.html#3580" class="Bound">ℓ&#39;</a> <a id="3583" class="Symbol">:</a> <a id="3585" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="3590" class="Symbol">}</a> <a id="3592" class="Symbol">→</a> <a id="3594" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="3599" href="1--Type-Theory.1-5--Propositions-as-Types.html#3578" class="Bound">ℓ</a> <a id="3601" class="Symbol">→</a> <a id="3603" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="3608" href="1--Type-Theory.1-5--Propositions-as-Types.html#3580" class="Bound">ℓ&#39;</a> <a id="3611" class="Symbol">→</a> <a id="3613" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="3618" class="Symbol">(</a><a id="3619" href="Library.Primitive.html#1128" class="Primitive">ℓ-max</a> <a id="3625" href="1--Type-Theory.1-5--Propositions-as-Types.html#3578" class="Bound">ℓ</a> <a id="3627" href="1--Type-Theory.1-5--Propositions-as-Types.html#3580" class="Bound">ℓ&#39;</a><a id="3629" class="Symbol">)</a>
<a id="3631" href="1--Type-Theory.1-5--Propositions-as-Types.html#3631" class="Bound">P</a> <a id="3633" href="1--Type-Theory.1-5--Propositions-as-Types.html#3568" class="Function Operator">iffP</a> <a id="3638" href="1--Type-Theory.1-5--Propositions-as-Types.html#3638" class="Bound">Q</a> <a id="3640" class="Symbol">=</a> <a id="3642" class="Symbol">(</a><a id="3643" href="1--Type-Theory.1-5--Propositions-as-Types.html#3631" class="Bound">P</a> <a id="3645" class="Symbol">→</a> <a id="3647" href="1--Type-Theory.1-5--Propositions-as-Types.html#3638" class="Bound">Q</a><a id="3648" class="Symbol">)</a> <a id="3650" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="3652" class="Symbol">(</a><a id="3653" href="1--Type-Theory.1-5--Propositions-as-Types.html#3638" class="Bound">Q</a> <a id="3655" class="Symbol">→</a> <a id="3657" href="1--Type-Theory.1-5--Propositions-as-Types.html#3631" class="Bound">P</a><a id="3658" class="Symbol">)</a>
</pre>
<p>As a sanity check, we can show that these operations on types
correspond correctly with the analogous operations on Booleans via
<code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a></code>. Prove the following by case-splitting on the arguments and
filling in both sides of the logical equivalence. On the left of the
<code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#3568" class="Function">iffP</a></code> we use the ordinary operation on Booleans, and on the right
we use the corresponding operation on propositions-as-types.</p>
<pre class="Agda"><a id="and→Type"></a><a id="4069" href="1--Type-Theory.1-5--Propositions-as-Types.html#4069" class="Function">and→Type</a> <a id="4078" class="Symbol">:</a> <a id="4080" class="Symbol">(</a><a id="4081" href="1--Type-Theory.1-5--Propositions-as-Types.html#4081" class="Bound">a</a> <a id="4083" href="1--Type-Theory.1-5--Propositions-as-Types.html#4083" class="Bound">b</a> <a id="4085" class="Symbol">:</a> <a id="4087" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="4091" class="Symbol">)</a> <a id="4093" class="Symbol">→</a> <a id="4095" class="Symbol">(</a><a id="4096" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="4103" class="Symbol">(</a><a id="4104" href="1--Type-Theory.1-5--Propositions-as-Types.html#4081" class="Bound">a</a> <a id="4106" href="1--Type-Theory.1-2--Inductive-Types.html#2824" class="Function Operator">and</a> <a id="4110" href="1--Type-Theory.1-5--Propositions-as-Types.html#4083" class="Bound">b</a><a id="4111" class="Symbol">))</a> <a id="4114" href="1--Type-Theory.1-5--Propositions-as-Types.html#3568" class="Function Operator">iffP</a> <a id="4119" class="Symbol">((</a><a id="4121" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="4128" href="1--Type-Theory.1-5--Propositions-as-Types.html#4081" class="Bound">a</a><a id="4129" class="Symbol">)</a> <a id="4131" href="1--Type-Theory.1-5--Propositions-as-Types.html#3013" class="Function Operator">andP</a> <a id="4136" class="Symbol">(</a><a id="4137" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="4144" href="1--Type-Theory.1-5--Propositions-as-Types.html#4083" class="Bound">b</a><a id="4145" class="Symbol">))</a>
<a id="4148" class="Comment">-- Exercise:</a>
<a id="4161" class="Comment">-- and→Type a b = {!!}</a>

<a id="implies→Type"></a><a id="4692" href="1--Type-Theory.1-5--Propositions-as-Types.html#4692" class="Function">implies→Type</a> <a id="4705" class="Symbol">:</a> <a id="4707" class="Symbol">(</a><a id="4708" href="1--Type-Theory.1-5--Propositions-as-Types.html#4708" class="Bound">a</a> <a id="4710" href="1--Type-Theory.1-5--Propositions-as-Types.html#4710" class="Bound">b</a> <a id="4712" class="Symbol">:</a> <a id="4714" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="4718" class="Symbol">)</a> <a id="4720" class="Symbol">→</a> <a id="4722" class="Symbol">(</a><a id="4723" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="4730" class="Symbol">(</a><a id="4731" href="1--Type-Theory.1-5--Propositions-as-Types.html#4708" class="Bound">a</a> <a id="4733" href="1--Type-Theory.1-2--Inductive-Types.html#7416" class="Function Operator">implies</a> <a id="4741" href="1--Type-Theory.1-5--Propositions-as-Types.html#4710" class="Bound">b</a><a id="4742" class="Symbol">))</a> <a id="4745" href="1--Type-Theory.1-5--Propositions-as-Types.html#3568" class="Function Operator">iffP</a> <a id="4750" class="Symbol">((</a><a id="4752" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="4759" href="1--Type-Theory.1-5--Propositions-as-Types.html#4708" class="Bound">a</a><a id="4760" class="Symbol">)</a> <a id="4762" href="1--Type-Theory.1-5--Propositions-as-Types.html#3294" class="Function Operator">impliesP</a> <a id="4771" class="Symbol">(</a><a id="4772" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="4779" href="1--Type-Theory.1-5--Propositions-as-Types.html#4710" class="Bound">b</a><a id="4780" class="Symbol">))</a>
<a id="4783" class="Comment">-- Exercise:</a>
<a id="4796" class="Comment">-- implies→Type a b = {!!}</a>
</pre>
<p>We interpret negation as a special case of implication: “not P” is the
same as “P implies false”, and again we make this our definition.</p>
<pre class="Agda"><a id="¬_"></a><a id="5483" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬_</a> <a id="5486" class="Symbol">:</a> <a id="5488" class="Symbol">{</a><a id="5489" href="1--Type-Theory.1-5--Propositions-as-Types.html#5489" class="Bound">ℓ</a> <a id="5491" class="Symbol">:</a> <a id="5493" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="5498" class="Symbol">}</a> <a id="5500" class="Symbol">→</a> <a id="5502" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="5507" href="1--Type-Theory.1-5--Propositions-as-Types.html#5489" class="Bound">ℓ</a> <a id="5509" class="Symbol">→</a> <a id="5511" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="5516" href="1--Type-Theory.1-5--Propositions-as-Types.html#5489" class="Bound">ℓ</a>
<a id="5518" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬_</a> <a id="5521" href="1--Type-Theory.1-5--Propositions-as-Types.html#5521" class="Bound">P</a> <a id="5523" class="Symbol">=</a> <a id="5525" href="1--Type-Theory.1-5--Propositions-as-Types.html#5521" class="Bound">P</a> <a id="5527" class="Symbol">→</a> <a id="5529" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a>

<a id="5532" class="Comment">-- This makes `¬` go on the outside of most formulas</a>
<a id="5585" class="Keyword">infix</a> <a id="5591" class="Number">3</a> <a id="5593" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬_</a>
</pre>
<p>We had better also make sure this means what we think it does!</p>
<pre class="Agda"><a id="not→Type"></a><a id="5669" href="1--Type-Theory.1-5--Propositions-as-Types.html#5669" class="Function">not→Type</a> <a id="5678" class="Symbol">:</a> <a id="5680" class="Symbol">(</a><a id="5681" href="1--Type-Theory.1-5--Propositions-as-Types.html#5681" class="Bound">a</a> <a id="5683" class="Symbol">:</a> <a id="5685" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="5689" class="Symbol">)</a> <a id="5691" class="Symbol">→</a> <a id="5693" class="Symbol">(</a><a id="5694" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="5701" class="Symbol">(</a><a id="5702" href="1--Type-Theory.1-2--Inductive-Types.html#1637" class="Function">not</a> <a id="5706" href="1--Type-Theory.1-5--Propositions-as-Types.html#5681" class="Bound">a</a><a id="5707" class="Symbol">))</a> <a id="5710" href="1--Type-Theory.1-5--Propositions-as-Types.html#3568" class="Function Operator">iffP</a> <a id="5715" class="Symbol">(</a><a id="5716" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="5718" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="5725" href="1--Type-Theory.1-5--Propositions-as-Types.html#5681" class="Bound">a</a><a id="5726" class="Symbol">)</a>
<a id="5728" class="Comment">-- Exercise:</a>
<a id="5741" class="Comment">-- not→Type a = ?</a>
</pre>
<p>A basic principle of negation is contraposition: if <code>P</code> implies <code>Q</code>
then whenever <code>Q</code> is false, certainly <code>P</code> must be false too.</p>
<p>This gives us an opportunity to introduce another useful Agda hotkey.
If you place your cursor in the below hole and press <code>C-c C-,</code>, Agda
will tell you that the goal has type <code>¬ Q → ¬ P</code>. This is certainly
true, but the path forwards is a little obscured. It helps if we
<em>unfold</em> the definition of <code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function">¬</a></code> in the goal, which we can ask
Agda to do by pressing <code>C-u C-u C-c C-,</code> in Emacs, or <code>C-y C-,</code> in
VSCode.</p>
<p>It is revealed that the goal has type <code>(Q → ∅) → P → ∅</code>. This makes it
clear that <code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#6702" class="Function">¬-contra</a></code> should take two arguments, one with type
<code>Q → ∅</code>, and the other with type <code>P</code>.</p>
<pre class="Agda"><a id="¬-contra"></a><a id="6702" href="1--Type-Theory.1-5--Propositions-as-Types.html#6702" class="Function">¬-contra</a> <a id="6711" class="Symbol">:</a> <a id="6713" class="Symbol">{</a><a id="6714" href="1--Type-Theory.1-5--Propositions-as-Types.html#6714" class="Bound">ℓ</a> <a id="6716" href="1--Type-Theory.1-5--Propositions-as-Types.html#6716" class="Bound">ℓ&#39;</a> <a id="6719" class="Symbol">:</a> <a id="6721" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="6726" class="Symbol">}</a> <a id="6728" class="Symbol">→</a> <a id="6730" class="Symbol">{</a><a id="6731" href="1--Type-Theory.1-5--Propositions-as-Types.html#6731" class="Bound">P</a> <a id="6733" class="Symbol">:</a> <a id="6735" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="6740" href="1--Type-Theory.1-5--Propositions-as-Types.html#6714" class="Bound">ℓ</a><a id="6741" class="Symbol">}</a> <a id="6743" class="Symbol">→</a> <a id="6745" class="Symbol">{</a><a id="6746" href="1--Type-Theory.1-5--Propositions-as-Types.html#6746" class="Bound">Q</a> <a id="6748" class="Symbol">:</a> <a id="6750" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="6755" href="1--Type-Theory.1-5--Propositions-as-Types.html#6716" class="Bound">ℓ&#39;</a><a id="6757" class="Symbol">}</a>
  <a id="6761" class="Symbol">→</a> <a id="6763" class="Symbol">(</a><a id="6764" href="1--Type-Theory.1-5--Propositions-as-Types.html#6731" class="Bound">P</a> <a id="6766" class="Symbol">→</a> <a id="6768" href="1--Type-Theory.1-5--Propositions-as-Types.html#6746" class="Bound">Q</a><a id="6769" class="Symbol">)</a>
  <a id="6773" class="Symbol">→</a> <a id="6775" class="Symbol">(</a><a id="6776" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="6778" href="1--Type-Theory.1-5--Propositions-as-Types.html#6746" class="Bound">Q</a> <a id="6780" class="Symbol">→</a> <a id="6782" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="6784" href="1--Type-Theory.1-5--Propositions-as-Types.html#6731" class="Bound">P</a><a id="6785" class="Symbol">)</a>
<a id="6787" class="Comment">-- Exercise:</a>
<a id="6800" class="Comment">-- ¬-contra f = {!!}</a>
</pre>
<p>The logic of propositions-as-types is not exactly the same as the
logic of Booleans, however. The reason has to do with double negation:
recall that for the Booleans, <code>not not b</code> is always equal to <code>b</code> which
you can check by just trying both possibilities. Working with
propositions-as-types, we can show one direction of that equivalence:</p>
<pre class="Agda"><a id="implies¬¬"></a><a id="7225" href="1--Type-Theory.1-5--Propositions-as-Types.html#7225" class="Function">implies¬¬</a> <a id="7235" class="Symbol">:</a> <a id="7237" class="Symbol">{</a><a id="7238" href="1--Type-Theory.1-5--Propositions-as-Types.html#7238" class="Bound">ℓ</a> <a id="7240" class="Symbol">:</a> <a id="7242" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="7247" class="Symbol">}</a> <a id="7249" class="Symbol">→</a> <a id="7251" class="Symbol">{</a><a id="7252" href="1--Type-Theory.1-5--Propositions-as-Types.html#7252" class="Bound">P</a> <a id="7254" class="Symbol">:</a> <a id="7256" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="7261" href="1--Type-Theory.1-5--Propositions-as-Types.html#7238" class="Bound">ℓ</a><a id="7262" class="Symbol">}</a> 
  <a id="7267" class="Symbol">→</a> <a id="7269" class="Symbol">(</a><a id="7270" href="1--Type-Theory.1-5--Propositions-as-Types.html#7252" class="Bound">P</a> <a id="7272" class="Symbol">→</a> <a id="7274" class="Symbol">(</a><a id="7275" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="7277" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="7279" href="1--Type-Theory.1-5--Propositions-as-Types.html#7252" class="Bound">P</a><a id="7280" class="Symbol">))</a>
<a id="7283" class="Comment">-- Exercise:</a>
<a id="7296" class="Comment">-- implies¬¬ p = ?</a>
</pre>
<p>But, we cannot show that <code>¬ ¬ A → A</code> in general!</p>
<pre class="Agda"><a id="7423" class="Comment">-- Uncomment to try if you want!</a>
<a id="7456" class="Comment">-- impossible-¬¬implies : {ℓ : Level} (P : Type ℓ) → (¬ ¬ P) → P</a>
<a id="7521" class="Comment">-- impossible-¬¬implies P nnp = {!!}</a>
</pre>
<p>One way to understand the difference between <code>¬ ¬ P</code> and <code>P</code> is that
we think of <code>p : P</code> as giving <em>evidence</em> that the proposition <code>P</code>
holds. What <code>¬ ¬ P</code> says is that to assume <code>P</code> were false would lead
to a contradiction, but this does not on its own conjure any direct
evidence for <code>P</code>. This quirk of logic in type theory makes it a
<em>constructive</em> logic — there is a difference between providing (or
“constructing”) evidence for a proposition and proving that its
falsehood would be absurd — as opposed to the “classical” logic of
the Booleans.</p>
<p>It seems that we’re at risk of <code>¬</code>s piling up endlessly if the above
implication only works in one direction. But in fact, as soon as we
have three <code>¬</code>s, we can cancel two of them.</p>
<pre class="Agda"><a id="¬¬¬implies¬"></a><a id="8302" href="1--Type-Theory.1-5--Propositions-as-Types.html#8302" class="Function">¬¬¬implies¬</a> <a id="8314" class="Symbol">:</a> <a id="8316" class="Symbol">{</a><a id="8317" href="1--Type-Theory.1-5--Propositions-as-Types.html#8317" class="Bound">ℓ</a> <a id="8319" class="Symbol">:</a> <a id="8321" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="8326" class="Symbol">}</a> <a id="8328" class="Symbol">→</a> <a id="8330" class="Symbol">{</a><a id="8331" href="1--Type-Theory.1-5--Propositions-as-Types.html#8331" class="Bound">P</a> <a id="8333" class="Symbol">:</a> <a id="8335" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="8340" href="1--Type-Theory.1-5--Propositions-as-Types.html#8317" class="Bound">ℓ</a><a id="8341" class="Symbol">}</a> 
  <a id="8346" class="Symbol">→</a> <a id="8348" class="Symbol">(</a><a id="8349" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="8351" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="8353" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="8355" href="1--Type-Theory.1-5--Propositions-as-Types.html#8331" class="Bound">P</a><a id="8356" class="Symbol">)</a> <a id="8358" class="Symbol">→</a> <a id="8360" class="Symbol">(</a><a id="8361" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="8363" href="1--Type-Theory.1-5--Propositions-as-Types.html#8331" class="Bound">P</a><a id="8364" class="Symbol">)</a>
<a id="8366" class="Comment">-- Exercise:</a>
<a id="8379" class="Comment">-- ¬¬¬implies¬ nnnp = ?</a>
</pre>
<p>As a challenge, prove that it’s impossible for <code>P</code> and <code>¬ P</code> to be
logically equivalence. Again, it may help to see what to do next if
you unfold the definitions.</p>
<pre class="Agda"><a id="¬-not-same"></a><a id="8643" href="1--Type-Theory.1-5--Propositions-as-Types.html#8643" class="Function">¬-not-same</a> <a id="8654" class="Symbol">:</a> <a id="8656" class="Symbol">{</a><a id="8657" href="1--Type-Theory.1-5--Propositions-as-Types.html#8657" class="Bound">ℓ</a> <a id="8659" class="Symbol">:</a> <a id="8661" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="8666" class="Symbol">}</a> <a id="8668" class="Symbol">→</a> <a id="8670" class="Symbol">{</a><a id="8671" href="1--Type-Theory.1-5--Propositions-as-Types.html#8671" class="Bound">P</a> <a id="8673" class="Symbol">:</a> <a id="8675" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="8680" href="1--Type-Theory.1-5--Propositions-as-Types.html#8657" class="Bound">ℓ</a><a id="8681" class="Symbol">}</a> 
  <a id="8686" class="Symbol">→</a> <a id="8688" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="8690" class="Symbol">(</a><a id="8691" href="1--Type-Theory.1-5--Propositions-as-Types.html#8671" class="Bound">P</a> <a id="8693" href="1--Type-Theory.1-5--Propositions-as-Types.html#3568" class="Function Operator">iffP</a> <a id="8698" class="Symbol">(</a><a id="8699" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="8701" href="1--Type-Theory.1-5--Propositions-as-Types.html#8671" class="Bound">P</a><a id="8702" class="Symbol">))</a>
<a id="8705" class="Comment">-- Exercise: </a>
<a id="8719" class="Comment">-- ¬-not-same (l , r) = ?</a>
</pre>
<h2 id="or"><a class="header" href="#or">Or</a></h2>
<p>This pattern of relating logical operations to type operations
continues with <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function">or</a></code>e but runs into a subtle hiccup. Our first
attempt at a type avatar of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function">or</a></code> is <code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype">⊎</a></code>, the disjoint union. This
makes some sense: to prove <code>P or Q</code> should consist of either a proof
of <code>P</code> or a proof of <code>Q</code>.</p>
<p>First, let’s define maps both ways.</p>
<pre class="Agda"><a id="or→Type-fro"></a><a id="9178" href="1--Type-Theory.1-5--Propositions-as-Types.html#9178" class="Function">or→Type-fro</a> <a id="9190" class="Symbol">:</a> <a id="9192" class="Symbol">(</a><a id="9193" href="1--Type-Theory.1-5--Propositions-as-Types.html#9193" class="Bound">a</a> <a id="9195" href="1--Type-Theory.1-5--Propositions-as-Types.html#9195" class="Bound">b</a> <a id="9197" class="Symbol">:</a> <a id="9199" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="9203" class="Symbol">)</a> <a id="9205" class="Symbol">→</a> <a id="9207" class="Symbol">(</a><a id="9208" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="9215" href="1--Type-Theory.1-5--Propositions-as-Types.html#9193" class="Bound">a</a> <a id="9217" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="9219" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="9226" href="1--Type-Theory.1-5--Propositions-as-Types.html#9195" class="Bound">b</a><a id="9227" class="Symbol">)</a> <a id="9229" class="Symbol">→</a> <a id="9231" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="9238" class="Symbol">(</a><a id="9239" href="1--Type-Theory.1-5--Propositions-as-Types.html#9193" class="Bound">a</a> <a id="9241" href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function Operator">or</a> <a id="9244" href="1--Type-Theory.1-5--Propositions-as-Types.html#9195" class="Bound">b</a><a id="9245" class="Symbol">)</a>
<a id="9247" class="Comment">-- Exercise:</a>
<a id="9260" class="Comment">-- or→Type-fro a b p = {!!}</a>

<a id="or→Type-to"></a><a id="9803" href="1--Type-Theory.1-5--Propositions-as-Types.html#9803" class="Function">or→Type-to</a> <a id="9814" class="Symbol">:</a> <a id="9816" class="Symbol">(</a><a id="9817" href="1--Type-Theory.1-5--Propositions-as-Types.html#9817" class="Bound">a</a> <a id="9819" href="1--Type-Theory.1-5--Propositions-as-Types.html#9819" class="Bound">b</a> <a id="9821" class="Symbol">:</a> <a id="9823" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="9827" class="Symbol">)</a> <a id="9829" class="Symbol">→</a> <a id="9831" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="9838" class="Symbol">(</a><a id="9839" href="1--Type-Theory.1-5--Propositions-as-Types.html#9817" class="Bound">a</a> <a id="9841" href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function Operator">or</a> <a id="9844" href="1--Type-Theory.1-5--Propositions-as-Types.html#9819" class="Bound">b</a><a id="9845" class="Symbol">)</a> <a id="9847" class="Symbol">→</a> <a id="9849" class="Symbol">(</a><a id="9850" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="9857" href="1--Type-Theory.1-5--Propositions-as-Types.html#9817" class="Bound">a</a> <a id="9859" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="9861" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="9868" href="1--Type-Theory.1-5--Propositions-as-Types.html#9819" class="Bound">b</a><a id="9869" class="Symbol">)</a>
<a id="9871" class="Comment">-- Exercise:</a>
<a id="9884" class="Comment">-- or→Type-to a b p = {!!}</a>
</pre>
<p>What this shows is that <code>IsTrue (a or b)</code> and <code>(IsTrue a) ⊎ (IsTrue b)</code>
are logically equivalent, that is, one <code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#3568" class="Function">iffP</a></code> the other. But
now: define the map backwards again, but making the opposite choice in
the case <code>or→Type-to' true true</code>.</p>
<pre class="Agda"><a id="or→Type-to&#39;"></a><a id="10396" href="1--Type-Theory.1-5--Propositions-as-Types.html#10396" class="Function">or→Type-to&#39;</a> <a id="10408" class="Symbol">:</a> <a id="10410" class="Symbol">(</a><a id="10411" href="1--Type-Theory.1-5--Propositions-as-Types.html#10411" class="Bound">a</a> <a id="10413" href="1--Type-Theory.1-5--Propositions-as-Types.html#10413" class="Bound">b</a> <a id="10415" class="Symbol">:</a> <a id="10417" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="10421" class="Symbol">)</a> <a id="10423" class="Symbol">→</a> <a id="10425" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="10432" class="Symbol">(</a><a id="10433" href="1--Type-Theory.1-5--Propositions-as-Types.html#10411" class="Bound">a</a> <a id="10435" href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function Operator">or</a> <a id="10438" href="1--Type-Theory.1-5--Propositions-as-Types.html#10413" class="Bound">b</a><a id="10439" class="Symbol">)</a> <a id="10441" class="Symbol">→</a> <a id="10443" class="Symbol">((</a><a id="10445" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="10452" href="1--Type-Theory.1-5--Propositions-as-Types.html#10411" class="Bound">a</a><a id="10453" class="Symbol">)</a> <a id="10455" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="10457" class="Symbol">(</a><a id="10458" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="10465" href="1--Type-Theory.1-5--Propositions-as-Types.html#10413" class="Bound">b</a><a id="10466" class="Symbol">))</a>
<a id="10469" class="Comment">-- Exercise:</a>
<a id="10482" class="Comment">-- or→Type-to&#39; a b p = {!!}</a>
</pre>
<p>So having an element of <code>(IsTrue a) ⊎ (IsTrue b)</code>, is <em>more</em>
information than simply knowing that at least one of <code>a</code> or <code>b</code> is
true: if <em>both</em> <code>a</code> and <code>b</code> are true, the element of <code>(IsTrue a) ⊎ (IsTrue b)</code> has to make a choice between the two sides. So, the type
no longer merely expresses the truth of a proposition.</p>
<p>What we ought to learn from this is that not <em>every</em> type should be
thought of as a proposition. Some types, like <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code>, say, are better
thought of as sets that have many different elements. What we are
noticing with <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function">or</a></code> is that the disjoint union of two propositions
can contain a non-trivial amount of information. We actually saw this
earlier, when we proved that <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> is bijective with <code>⊤ ⊎ ⊤</code>.</p>
<p>This is the refinement that we will eventually make in Lecture 2-X, to
pick out which types are the ones we should think of as propositions:
types that have at most one element. This unique element, if it exists
at all, is thought of as “the fact that the proposition is true”. At
that point we will also properly define the operation which
corresponds to the proposition <code>P or Q</code>.</p>
<p>Nevertheless, <code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype">⊎</a></code> is close enough to <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function">or</a></code> for our
current purposes. Try proving De Morgan’s laws, which may be
familiar from ordinary propositional logic. For the last one, we get
stuck in a similar way to <code>impossible-¬¬implies</code> above. In that case,
how are we supposed to know which of <code class="Agda"><a href="3--Topics.3-2--Modalities.html#8098" class="InductiveConstructor">inl</a></code> or <code class="Agda"><a href="3--Topics.3-2--Modalities.html#8119" class="InductiveConstructor">inr</a></code> to
pick?</p>
<pre class="Agda"><a id="DeMorgan-law-1"></a><a id="12188" href="1--Type-Theory.1-5--Propositions-as-Types.html#12188" class="Function">DeMorgan-law-1</a> <a id="12203" class="Symbol">:</a> <a id="12205" class="Symbol">{</a><a id="12206" href="1--Type-Theory.1-5--Propositions-as-Types.html#12206" class="Bound">P</a> <a id="12208" href="1--Type-Theory.1-5--Propositions-as-Types.html#12208" class="Bound">Q</a> <a id="12210" class="Symbol">:</a> <a id="12212" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="12216" class="Symbol">}</a> <a id="12218" class="Symbol">→</a> <a id="12220" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="12222" class="Symbol">(</a><a id="12223" href="1--Type-Theory.1-5--Propositions-as-Types.html#12206" class="Bound">P</a> <a id="12225" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="12227" href="1--Type-Theory.1-5--Propositions-as-Types.html#12208" class="Bound">Q</a><a id="12228" class="Symbol">)</a> <a id="12230" class="Symbol">→</a> <a id="12232" class="Symbol">(</a><a id="12233" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="12235" href="1--Type-Theory.1-5--Propositions-as-Types.html#12206" class="Bound">P</a><a id="12236" class="Symbol">)</a> <a id="12238" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="12240" class="Symbol">(</a><a id="12241" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="12243" href="1--Type-Theory.1-5--Propositions-as-Types.html#12208" class="Bound">Q</a><a id="12244" class="Symbol">)</a>
<a id="12246" class="Comment">-- Exercise:</a>
<a id="12259" class="Comment">-- DeMorgan-law-1 npq = {!!}</a>

<a id="DeMorgan-law-2"></a><a id="12379" href="1--Type-Theory.1-5--Propositions-as-Types.html#12379" class="Function">DeMorgan-law-2</a> <a id="12394" class="Symbol">:</a> <a id="12396" class="Symbol">{</a><a id="12397" href="1--Type-Theory.1-5--Propositions-as-Types.html#12397" class="Bound">P</a> <a id="12399" href="1--Type-Theory.1-5--Propositions-as-Types.html#12399" class="Bound">Q</a> <a id="12401" class="Symbol">:</a> <a id="12403" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="12407" class="Symbol">}</a> <a id="12409" class="Symbol">→</a> <a id="12411" class="Symbol">(</a><a id="12412" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="12414" href="1--Type-Theory.1-5--Propositions-as-Types.html#12397" class="Bound">P</a><a id="12415" class="Symbol">)</a> <a id="12417" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="12419" class="Symbol">(</a><a id="12420" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="12422" href="1--Type-Theory.1-5--Propositions-as-Types.html#12399" class="Bound">Q</a><a id="12423" class="Symbol">)</a> <a id="12425" class="Symbol">→</a> <a id="12427" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="12429" class="Symbol">(</a><a id="12430" href="1--Type-Theory.1-5--Propositions-as-Types.html#12397" class="Bound">P</a> <a id="12432" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="12434" href="1--Type-Theory.1-5--Propositions-as-Types.html#12399" class="Bound">Q</a><a id="12435" class="Symbol">)</a>
<a id="12437" class="Comment">-- Exercise:</a>
<a id="12450" class="Comment">-- DeMorgan-law-2 (np , nq) pq = {!!}</a>

<a id="DeMorgan-law-3"></a><a id="12623" href="1--Type-Theory.1-5--Propositions-as-Types.html#12623" class="Function">DeMorgan-law-3</a> <a id="12638" class="Symbol">:</a> <a id="12640" class="Symbol">{</a><a id="12641" href="1--Type-Theory.1-5--Propositions-as-Types.html#12641" class="Bound">P</a> <a id="12643" href="1--Type-Theory.1-5--Propositions-as-Types.html#12643" class="Bound">Q</a> <a id="12645" class="Symbol">:</a> <a id="12647" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="12651" class="Symbol">}</a> <a id="12653" class="Symbol">→</a> <a id="12655" class="Symbol">(</a><a id="12656" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="12658" href="1--Type-Theory.1-5--Propositions-as-Types.html#12641" class="Bound">P</a><a id="12659" class="Symbol">)</a> <a id="12661" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="12663" class="Symbol">(</a><a id="12664" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="12666" href="1--Type-Theory.1-5--Propositions-as-Types.html#12643" class="Bound">Q</a><a id="12667" class="Symbol">)</a> <a id="12669" class="Symbol">→</a> <a id="12671" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="12673" class="Symbol">(</a><a id="12674" href="1--Type-Theory.1-5--Propositions-as-Types.html#12641" class="Bound">P</a> <a id="12676" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="12678" href="1--Type-Theory.1-5--Propositions-as-Types.html#12643" class="Bound">Q</a><a id="12679" class="Symbol">)</a>
<a id="12681" class="Comment">-- Exercise:</a>
<a id="12694" class="Comment">-- DeMorgan-law-3 npnq (p , q) = {!!}</a>

<a id="12865" class="Comment">-- Uncomment to see where you get stuck if you want!</a>
<a id="12918" class="Comment">-- impossible-DeMorgan-law-4 : {P Q : Type} → ¬ (P × Q) → (¬ P) ⊎ (¬ Q)</a>
<a id="12990" class="Comment">-- impossible-DeMorgan-law-4 npq = {!!}</a>
</pre>
<h2 id="equality"><a class="header" href="#equality">Equality</a></h2>
<p>The most fundamental proposition concerning the data types we have
seen so far is <em>equality</em>. We can define equality for Booleans
by case-splitting as follows:</p>
<pre class="Agda"><a id="_≡Bool_"></a><a id="13214" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">_≡Bool_</a> <a id="13222" class="Symbol">:</a> <a id="13224" class="Symbol">(</a><a id="13225" href="1--Type-Theory.1-5--Propositions-as-Types.html#13225" class="Bound">a</a> <a id="13227" href="1--Type-Theory.1-5--Propositions-as-Types.html#13227" class="Bound">b</a> <a id="13229" class="Symbol">:</a> <a id="13231" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="13235" class="Symbol">)</a> <a id="13237" class="Symbol">→</a> <a id="13239" href="Library.Primitive.html#422" class="Primitive">Type</a>
<a id="13244" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="13250" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="13256" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="13262" class="Symbol">=</a> <a id="13264" href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a>
<a id="13266" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="13272" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="13278" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="13284" class="Symbol">=</a> <a id="13286" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a>
<a id="13288" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="13294" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="13300" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="13306" class="Symbol">=</a> <a id="13308" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a>
<a id="13310" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="13316" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="13322" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="13328" class="Symbol">=</a> <a id="13330" href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a>
</pre>
<p>That is, there is a unique proof that <code>true ≡Bool true</code>, no proofs
that <code>true ≡Bool false</code>, and so on. This kind of equality defined by
pattern-matching is often called “observational” equality.</p>
<p>Now how do we prove an equality of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code>s? We just inhabit the
relevant type:</p>
<pre class="Agda"><a id="true-equals-true"></a><a id="13619" href="1--Type-Theory.1-5--Propositions-as-Types.html#13619" class="Function">true-equals-true</a> <a id="13636" class="Symbol">:</a> <a id="13638" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="13643" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="13649" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
<a id="13654" href="1--Type-Theory.1-5--Propositions-as-Types.html#13619" class="Function">true-equals-true</a> <a id="13671" class="Symbol">=</a> <a id="13673" href="1--Type-Theory.1-2--Inductive-Types.html#8988" class="InductiveConstructor">tt</a>
</pre>
<p>What if the Boolean value involved is a variable, or some complicated
expression? By case splitting, we can hopefully simplify the goal into
one of the trivial cases as above, that is, we just do recursion on
the data type! (Using recursion to prove a proposition is often called
“induction”, we will make this more precise in the next section.)</p>
<p>Here’s an example. With this notion of equality, every <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> is
either equal to <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a></code> or to <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a></code>. This is the Law of Excluded
Middle for Booleans logic; there is no middle option!</p>
<pre class="Agda"><a id="≡Bool-LEM"></a><a id="14224" href="1--Type-Theory.1-5--Propositions-as-Types.html#14224" class="Function">≡Bool-LEM</a> <a id="14234" class="Symbol">:</a> <a id="14236" class="Symbol">(</a><a id="14237" href="1--Type-Theory.1-5--Propositions-as-Types.html#14237" class="Bound">a</a> <a id="14239" class="Symbol">:</a> <a id="14241" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="14245" class="Symbol">)</a> <a id="14247" class="Symbol">→</a> <a id="14249" class="Symbol">(</a><a id="14250" href="1--Type-Theory.1-5--Propositions-as-Types.html#14237" class="Bound">a</a> <a id="14252" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="14258" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a><a id="14262" class="Symbol">)</a> <a id="14264" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="14266" class="Symbol">(</a><a id="14267" href="1--Type-Theory.1-5--Propositions-as-Types.html#14237" class="Bound">a</a> <a id="14269" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="14275" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a><a id="14280" class="Symbol">)</a>
<a id="14282" href="1--Type-Theory.1-5--Propositions-as-Types.html#14224" class="Function">≡Bool-LEM</a> <a id="14292" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="14297" class="Symbol">=</a> <a id="14299" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8339" class="InductiveConstructor">inl</a> <a id="14303" href="1--Type-Theory.1-2--Inductive-Types.html#8988" class="InductiveConstructor">tt</a>
<a id="14306" href="1--Type-Theory.1-5--Propositions-as-Types.html#14224" class="Function">≡Bool-LEM</a> <a id="14316" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="14322" class="Symbol">=</a> <a id="14324" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8357" class="InductiveConstructor">inr</a> <a id="14328" href="1--Type-Theory.1-2--Inductive-Types.html#8988" class="InductiveConstructor">tt</a>
</pre>
<p>By pattern matching, we can prove that observational equality is a
reflexive, symmetric, and transitive relation on Booleans.</p>
<pre class="Agda"><a id="≡Bool-refl"></a><a id="14467" href="1--Type-Theory.1-5--Propositions-as-Types.html#14467" class="Function">≡Bool-refl</a> <a id="14478" class="Symbol">:</a> <a id="14480" class="Symbol">(</a><a id="14481" href="1--Type-Theory.1-5--Propositions-as-Types.html#14481" class="Bound">a</a> <a id="14483" class="Symbol">:</a> <a id="14485" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="14489" class="Symbol">)</a> <a id="14491" class="Symbol">→</a> <a id="14493" href="1--Type-Theory.1-5--Propositions-as-Types.html#14481" class="Bound">a</a> <a id="14495" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="14501" href="1--Type-Theory.1-5--Propositions-as-Types.html#14481" class="Bound">a</a>
<a id="14503" class="Comment">-- Exercise:</a>
<a id="14516" class="Comment">-- ≡Bool-refl a = {!!}</a>

<a id="≡Bool-sym"></a><a id="14637" href="1--Type-Theory.1-5--Propositions-as-Types.html#14637" class="Function">≡Bool-sym</a> <a id="14647" class="Symbol">:</a> <a id="14649" class="Symbol">(</a><a id="14650" href="1--Type-Theory.1-5--Propositions-as-Types.html#14650" class="Bound">a</a> <a id="14652" href="1--Type-Theory.1-5--Propositions-as-Types.html#14652" class="Bound">b</a> <a id="14654" class="Symbol">:</a> <a id="14656" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="14660" class="Symbol">)</a>
  <a id="14664" class="Symbol">→</a> <a id="14666" href="1--Type-Theory.1-5--Propositions-as-Types.html#14650" class="Bound">a</a> <a id="14668" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="14674" href="1--Type-Theory.1-5--Propositions-as-Types.html#14652" class="Bound">b</a>
  <a id="14678" class="Symbol">→</a> <a id="14680" href="1--Type-Theory.1-5--Propositions-as-Types.html#14652" class="Bound">b</a> <a id="14682" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="14688" href="1--Type-Theory.1-5--Propositions-as-Types.html#14650" class="Bound">a</a>
<a id="14690" class="Comment">-- Exercise:</a>
<a id="14703" class="Comment">-- ≡Bool-sym a b p = {!!}</a>

<a id="≡Bool-trans"></a><a id="14944" href="1--Type-Theory.1-5--Propositions-as-Types.html#14944" class="Function">≡Bool-trans</a> <a id="14956" class="Symbol">:</a> <a id="14958" class="Symbol">(</a><a id="14959" href="1--Type-Theory.1-5--Propositions-as-Types.html#14959" class="Bound">a</a> <a id="14961" href="1--Type-Theory.1-5--Propositions-as-Types.html#14961" class="Bound">b</a> <a id="14963" href="1--Type-Theory.1-5--Propositions-as-Types.html#14963" class="Bound">c</a> <a id="14965" class="Symbol">:</a> <a id="14967" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="14971" class="Symbol">)</a>
  <a id="14975" class="Symbol">→</a> <a id="14977" href="1--Type-Theory.1-5--Propositions-as-Types.html#14959" class="Bound">a</a> <a id="14979" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="14985" href="1--Type-Theory.1-5--Propositions-as-Types.html#14961" class="Bound">b</a>
  <a id="14989" class="Symbol">→</a> <a id="14991" href="1--Type-Theory.1-5--Propositions-as-Types.html#14961" class="Bound">b</a> <a id="14993" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="14999" href="1--Type-Theory.1-5--Propositions-as-Types.html#14963" class="Bound">c</a>
  <a id="15003" class="Symbol">→</a> <a id="15005" href="1--Type-Theory.1-5--Propositions-as-Types.html#14959" class="Bound">a</a> <a id="15007" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="15013" href="1--Type-Theory.1-5--Propositions-as-Types.html#14963" class="Bound">c</a>
<a id="15015" class="Comment">-- Exercise:</a>
<a id="15028" class="Comment">-- ≡Bool-trans a b c p q = {!!}</a>
</pre>
<p>We can also show that all of our logical operations preserve the
relation of equality, as expected. Like the previous, these can be
proven purely by splitting into all the possible cases, so we won’t
make you do them all.</p>
<pre class="Agda"><a id="not-≡Bool"></a><a id="15782" href="1--Type-Theory.1-5--Propositions-as-Types.html#15782" class="Function">not-≡Bool</a> <a id="15792" class="Symbol">:</a> <a id="15794" class="Symbol">(</a><a id="15795" href="1--Type-Theory.1-5--Propositions-as-Types.html#15795" class="Bound">a</a> <a id="15797" href="1--Type-Theory.1-5--Propositions-as-Types.html#15797" class="Bound">b</a> <a id="15799" class="Symbol">:</a> <a id="15801" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="15805" class="Symbol">)</a>
  <a id="15809" class="Symbol">→</a> <a id="15811" href="1--Type-Theory.1-5--Propositions-as-Types.html#15795" class="Bound">a</a> <a id="15813" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="15819" href="1--Type-Theory.1-5--Propositions-as-Types.html#15797" class="Bound">b</a>
  <a id="15823" class="Symbol">→</a> <a id="15825" class="Symbol">(</a><a id="15826" href="1--Type-Theory.1-2--Inductive-Types.html#1637" class="Function">not</a> <a id="15830" href="1--Type-Theory.1-5--Propositions-as-Types.html#15795" class="Bound">a</a><a id="15831" class="Symbol">)</a> <a id="15833" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="15839" class="Symbol">(</a><a id="15840" href="1--Type-Theory.1-2--Inductive-Types.html#1637" class="Function">not</a> <a id="15844" href="1--Type-Theory.1-5--Propositions-as-Types.html#15797" class="Bound">b</a><a id="15845" class="Symbol">)</a>
<a id="15847" href="1--Type-Theory.1-5--Propositions-as-Types.html#15782" class="Function">not-≡Bool</a> <a id="15857" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="15862" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="15867" href="1--Type-Theory.1-2--Inductive-Types.html#8988" class="InductiveConstructor">tt</a> <a id="15870" class="Symbol">=</a> <a id="15872" href="1--Type-Theory.1-2--Inductive-Types.html#8988" class="InductiveConstructor">tt</a>
<a id="15875" href="1--Type-Theory.1-5--Propositions-as-Types.html#15782" class="Function">not-≡Bool</a> <a id="15885" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="15890" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="15896" class="Symbol">()</a>
<a id="15899" href="1--Type-Theory.1-5--Propositions-as-Types.html#15782" class="Function">not-≡Bool</a> <a id="15909" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="15915" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="15920" class="Symbol">()</a>
<a id="15923" href="1--Type-Theory.1-5--Propositions-as-Types.html#15782" class="Function">not-≡Bool</a> <a id="15933" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="15939" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="15945" href="1--Type-Theory.1-2--Inductive-Types.html#8988" class="InductiveConstructor">tt</a> <a id="15948" class="Symbol">=</a> <a id="15950" href="1--Type-Theory.1-2--Inductive-Types.html#8988" class="InductiveConstructor">tt</a>

<a id="and-≡Bool"></a><a id="15954" href="1--Type-Theory.1-5--Propositions-as-Types.html#15954" class="Function">and-≡Bool</a> <a id="15964" class="Symbol">:</a> <a id="15966" class="Symbol">(</a><a id="15967" href="1--Type-Theory.1-5--Propositions-as-Types.html#15967" class="Bound">a1</a> <a id="15970" href="1--Type-Theory.1-5--Propositions-as-Types.html#15970" class="Bound">a2</a> <a id="15973" href="1--Type-Theory.1-5--Propositions-as-Types.html#15973" class="Bound">b1</a> <a id="15976" href="1--Type-Theory.1-5--Propositions-as-Types.html#15976" class="Bound">b2</a> <a id="15979" class="Symbol">:</a> <a id="15981" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="15985" class="Symbol">)</a>
  <a id="15989" class="Symbol">→</a> <a id="15991" class="Symbol">(</a><a id="15992" href="1--Type-Theory.1-5--Propositions-as-Types.html#15967" class="Bound">a1</a> <a id="15995" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="16001" href="1--Type-Theory.1-5--Propositions-as-Types.html#15970" class="Bound">a2</a><a id="16003" class="Symbol">)</a>
  <a id="16007" class="Symbol">→</a> <a id="16009" class="Symbol">(</a><a id="16010" href="1--Type-Theory.1-5--Propositions-as-Types.html#15973" class="Bound">b1</a> <a id="16013" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="16019" href="1--Type-Theory.1-5--Propositions-as-Types.html#15976" class="Bound">b2</a><a id="16021" class="Symbol">)</a>
  <a id="16025" class="Symbol">→</a> <a id="16027" class="Symbol">(</a><a id="16028" href="1--Type-Theory.1-5--Propositions-as-Types.html#15967" class="Bound">a1</a> <a id="16031" href="1--Type-Theory.1-2--Inductive-Types.html#2824" class="Function Operator">and</a> <a id="16035" href="1--Type-Theory.1-5--Propositions-as-Types.html#15973" class="Bound">b1</a><a id="16037" class="Symbol">)</a> <a id="16039" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="16045" class="Symbol">(</a><a id="16046" href="1--Type-Theory.1-5--Propositions-as-Types.html#15970" class="Bound">a2</a> <a id="16049" href="1--Type-Theory.1-2--Inductive-Types.html#2824" class="Function Operator">and</a> <a id="16053" href="1--Type-Theory.1-5--Propositions-as-Types.html#15976" class="Bound">b2</a><a id="16055" class="Symbol">)</a>
<a id="16057" class="Comment">-- Exercise:</a>
<a id="16070" class="Comment">-- and-≡Bool a1 a2 b1 b2 p q = {!!}</a>
</pre>
<p>We can similarly define equality of natural numbers.</p>
<pre class="Agda"><a id="_≡ℕ_"></a><a id="17221" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">_≡ℕ_</a> <a id="17226" class="Symbol">:</a> <a id="17228" class="Symbol">(</a><a id="17229" href="1--Type-Theory.1-5--Propositions-as-Types.html#17229" class="Bound">n</a> <a id="17231" href="1--Type-Theory.1-5--Propositions-as-Types.html#17231" class="Bound">m</a> <a id="17233" class="Symbol">:</a> <a id="17235" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="17236" class="Symbol">)</a> <a id="17238" class="Symbol">→</a> <a id="17240" href="Library.Primitive.html#422" class="Primitive">Type</a>

<a id="17246" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>  <a id="17252" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="17255" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>  <a id="17261" class="Symbol">=</a> <a id="17263" href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a>
<a id="17265" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>  <a id="17271" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="17274" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="17278" href="1--Type-Theory.1-5--Propositions-as-Types.html#17278" class="Bound">m</a> <a id="17280" class="Symbol">=</a> <a id="17282" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a>
<a id="17284" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="17288" href="1--Type-Theory.1-5--Propositions-as-Types.html#17288" class="Bound">n</a> <a id="17290" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="17293" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>  <a id="17299" class="Symbol">=</a> <a id="17301" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a>
<a id="17303" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="17307" href="1--Type-Theory.1-5--Propositions-as-Types.html#17307" class="Bound">n</a> <a id="17309" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="17312" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="17316" href="1--Type-Theory.1-5--Propositions-as-Types.html#17316" class="Bound">m</a> <a id="17318" class="Symbol">=</a> <a id="17320" href="1--Type-Theory.1-5--Propositions-as-Types.html#17307" class="Bound">n</a> <a id="17322" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="17325" href="1--Type-Theory.1-5--Propositions-as-Types.html#17316" class="Bound">m</a>

<a id="17328" class="Keyword">infix</a> <a id="17334" class="Number">4</a> <a id="17336" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">_≡ℕ_</a>
</pre>
<p>And show that it is a reflexive, symmetric, and transitive relation.
The difference in the proofs is that because <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code> is a
recursive datatype, some of the cases in the proofs will need to be recursive
too.</p>
<pre class="Agda"><a id="≡ℕ-refl"></a><a id="17559" href="1--Type-Theory.1-5--Propositions-as-Types.html#17559" class="Function">≡ℕ-refl</a> <a id="17567" class="Symbol">:</a> <a id="17569" class="Symbol">(</a><a id="17570" href="1--Type-Theory.1-5--Propositions-as-Types.html#17570" class="Bound">n</a> <a id="17572" class="Symbol">:</a> <a id="17574" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="17575" class="Symbol">)</a> <a id="17577" class="Symbol">→</a> <a id="17579" href="1--Type-Theory.1-5--Propositions-as-Types.html#17570" class="Bound">n</a> <a id="17581" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="17584" href="1--Type-Theory.1-5--Propositions-as-Types.html#17570" class="Bound">n</a>
<a id="17586" class="Comment">-- Exercise:</a>
<a id="17599" class="Comment">-- ≡ℕ-refl n = ?</a>

<a id="≡ℕ-sym"></a><a id="17717" href="1--Type-Theory.1-5--Propositions-as-Types.html#17717" class="Function">≡ℕ-sym</a> <a id="17724" class="Symbol">:</a> <a id="17726" class="Symbol">(</a><a id="17727" href="1--Type-Theory.1-5--Propositions-as-Types.html#17727" class="Bound">n</a> <a id="17729" href="1--Type-Theory.1-5--Propositions-as-Types.html#17729" class="Bound">m</a> <a id="17731" class="Symbol">:</a> <a id="17733" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="17734" class="Symbol">)</a>
  <a id="17738" class="Symbol">→</a> <a id="17740" href="1--Type-Theory.1-5--Propositions-as-Types.html#17727" class="Bound">n</a> <a id="17742" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="17745" href="1--Type-Theory.1-5--Propositions-as-Types.html#17729" class="Bound">m</a>
  <a id="17749" class="Symbol">→</a> <a id="17751" href="1--Type-Theory.1-5--Propositions-as-Types.html#17729" class="Bound">m</a> <a id="17753" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="17756" href="1--Type-Theory.1-5--Propositions-as-Types.html#17727" class="Bound">n</a>
<a id="17758" class="Comment">-- Exercise:</a>
<a id="17771" class="Comment">-- ≡ℕ-sym n m p = ?</a>

<a id="≡ℕ-trans"></a><a id="18010" href="1--Type-Theory.1-5--Propositions-as-Types.html#18010" class="Function">≡ℕ-trans</a> <a id="18019" class="Symbol">:</a> <a id="18021" class="Symbol">(</a><a id="18022" href="1--Type-Theory.1-5--Propositions-as-Types.html#18022" class="Bound">n</a> <a id="18024" href="1--Type-Theory.1-5--Propositions-as-Types.html#18024" class="Bound">m</a> <a id="18026" href="1--Type-Theory.1-5--Propositions-as-Types.html#18026" class="Bound">k</a> <a id="18028" class="Symbol">:</a> <a id="18030" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="18031" class="Symbol">)</a>
  <a id="18035" class="Symbol">→</a> <a id="18037" href="1--Type-Theory.1-5--Propositions-as-Types.html#18022" class="Bound">n</a> <a id="18039" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="18042" href="1--Type-Theory.1-5--Propositions-as-Types.html#18024" class="Bound">m</a>
  <a id="18046" class="Symbol">→</a> <a id="18048" href="1--Type-Theory.1-5--Propositions-as-Types.html#18024" class="Bound">m</a> <a id="18050" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="18053" href="1--Type-Theory.1-5--Propositions-as-Types.html#18026" class="Bound">k</a>
  <a id="18057" class="Symbol">→</a> <a id="18059" href="1--Type-Theory.1-5--Propositions-as-Types.html#18022" class="Bound">n</a> <a id="18061" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="18064" href="1--Type-Theory.1-5--Propositions-as-Types.html#18026" class="Bound">k</a>
<a id="18066" class="Comment">-- Exercise:</a>
<a id="18079" class="Comment">-- ≡ℕ-trans n m k p q = {!!}</a>
</pre>
<p>Next, we can show that addition is unital (that is, has an identity
element), and associative. These are all very easy by recursion.
Remember that you don’t <em>have</em> to case split on an argument just
because you can, <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#8468" class="Function">+ℕ-assoc</a></code> is much simpler if you don’t!</p>
<pre class="Agda"><a id="+ℕ-≡ℕ-idl"></a><a id="18885" href="1--Type-Theory.1-5--Propositions-as-Types.html#18885" class="Function">+ℕ-≡ℕ-idl</a> <a id="18895" class="Symbol">:</a> <a id="18897" class="Symbol">(</a><a id="18898" href="1--Type-Theory.1-5--Propositions-as-Types.html#18898" class="Bound">n</a> <a id="18900" class="Symbol">:</a> <a id="18902" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="18903" class="Symbol">)</a> <a id="18905" class="Symbol">→</a> <a id="18907" class="Symbol">(</a><a id="18908" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="18913" href="1--Type-Theory.1-2--Inductive-Types.html#12858" class="Function Operator">+ℕ</a> <a id="18916" href="1--Type-Theory.1-5--Propositions-as-Types.html#18898" class="Bound">n</a><a id="18917" class="Symbol">)</a> <a id="18919" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="18922" href="1--Type-Theory.1-5--Propositions-as-Types.html#18898" class="Bound">n</a>
<a id="18924" class="Comment">-- Exercise:</a>
<a id="18937" class="Comment">-- +ℕ-≡ℕ-idl n = {!!}</a>

<a id="+ℕ-≡ℕ-idr"></a><a id="19011" href="1--Type-Theory.1-5--Propositions-as-Types.html#19011" class="Function">+ℕ-≡ℕ-idr</a> <a id="19021" class="Symbol">:</a> <a id="19023" class="Symbol">(</a><a id="19024" href="1--Type-Theory.1-5--Propositions-as-Types.html#19024" class="Bound">n</a> <a id="19026" class="Symbol">:</a> <a id="19028" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="19029" class="Symbol">)</a> <a id="19031" class="Symbol">→</a> <a id="19033" class="Symbol">(</a><a id="19034" href="1--Type-Theory.1-5--Propositions-as-Types.html#19024" class="Bound">n</a> <a id="19036" href="1--Type-Theory.1-2--Inductive-Types.html#12858" class="Function Operator">+ℕ</a> <a id="19039" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="19043" class="Symbol">)</a> <a id="19045" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="19048" href="1--Type-Theory.1-5--Propositions-as-Types.html#19024" class="Bound">n</a>
<a id="19050" class="Comment">-- Exercise:</a>
<a id="19063" class="Comment">-- +ℕ-≡ℕ-idr n = {!!}</a>

<a id="+ℕ-≡ℕ-assoc"></a><a id="19192" href="1--Type-Theory.1-5--Propositions-as-Types.html#19192" class="Function">+ℕ-≡ℕ-assoc</a> <a id="19204" class="Symbol">:</a> <a id="19206" class="Symbol">(</a><a id="19207" href="1--Type-Theory.1-5--Propositions-as-Types.html#19207" class="Bound">n</a> <a id="19209" href="1--Type-Theory.1-5--Propositions-as-Types.html#19209" class="Bound">m</a> <a id="19211" href="1--Type-Theory.1-5--Propositions-as-Types.html#19211" class="Bound">k</a> <a id="19213" class="Symbol">:</a> <a id="19215" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="19216" class="Symbol">)</a> <a id="19218" class="Symbol">→</a> <a id="19220" class="Symbol">(</a><a id="19221" href="1--Type-Theory.1-5--Propositions-as-Types.html#19207" class="Bound">n</a> <a id="19223" href="1--Type-Theory.1-2--Inductive-Types.html#12858" class="Function Operator">+ℕ</a> <a id="19226" class="Symbol">(</a><a id="19227" href="1--Type-Theory.1-5--Propositions-as-Types.html#19209" class="Bound">m</a> <a id="19229" href="1--Type-Theory.1-2--Inductive-Types.html#12858" class="Function Operator">+ℕ</a> <a id="19232" href="1--Type-Theory.1-5--Propositions-as-Types.html#19211" class="Bound">k</a><a id="19233" class="Symbol">))</a> <a id="19236" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="19239" class="Symbol">((</a><a id="19241" href="1--Type-Theory.1-5--Propositions-as-Types.html#19207" class="Bound">n</a> <a id="19243" href="1--Type-Theory.1-2--Inductive-Types.html#12858" class="Function Operator">+ℕ</a> <a id="19246" href="1--Type-Theory.1-5--Propositions-as-Types.html#19209" class="Bound">m</a><a id="19247" class="Symbol">)</a> <a id="19249" href="1--Type-Theory.1-2--Inductive-Types.html#12858" class="Function Operator">+ℕ</a> <a id="19252" href="1--Type-Theory.1-5--Propositions-as-Types.html#19211" class="Bound">k</a><a id="19253" class="Symbol">)</a>
<a id="19255" class="Comment">-- Exercise:</a>
<a id="19268" class="Comment">-- +ℕ-≡ℕ-assoc n m k = {!!}</a>
</pre>
<p>Finally, we can show that addition is commutative. This one is
trickier, and we will have to glue together some of the facts we
proved above. In both parts, it is easiest if you <em>don’t</em> pattern
match on both arguments.</p>
<pre class="Agda"><a id="+ℕ-≡ℕ-comm-helper"></a><a id="19663" href="1--Type-Theory.1-5--Propositions-as-Types.html#19663" class="Function">+ℕ-≡ℕ-comm-helper</a> <a id="19681" class="Symbol">:</a> <a id="19683" class="Symbol">(</a><a id="19684" href="1--Type-Theory.1-5--Propositions-as-Types.html#19684" class="Bound">n</a> <a id="19686" href="1--Type-Theory.1-5--Propositions-as-Types.html#19686" class="Bound">m</a> <a id="19688" class="Symbol">:</a> <a id="19690" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="19691" class="Symbol">)</a> <a id="19693" class="Symbol">→</a> <a id="19695" class="Symbol">(</a><a id="19696" href="1--Type-Theory.1-5--Propositions-as-Types.html#19684" class="Bound">n</a> <a id="19698" href="1--Type-Theory.1-2--Inductive-Types.html#12858" class="Function Operator">+ℕ</a> <a id="19701" class="Symbol">(</a><a id="19702" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="19706" href="1--Type-Theory.1-5--Propositions-as-Types.html#19686" class="Bound">m</a><a id="19707" class="Symbol">))</a> <a id="19710" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="19713" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="19717" class="Symbol">(</a><a id="19718" href="1--Type-Theory.1-5--Propositions-as-Types.html#19684" class="Bound">n</a> <a id="19720" href="1--Type-Theory.1-2--Inductive-Types.html#12858" class="Function Operator">+ℕ</a> <a id="19723" href="1--Type-Theory.1-5--Propositions-as-Types.html#19686" class="Bound">m</a><a id="19724" class="Symbol">)</a>
<a id="19726" class="Comment">-- Exercise:</a>
<a id="19739" class="Comment">-- +ℕ-≡ℕ-comm-helper n m = {!!}</a>

<a id="+ℕ-≡ℕ-comm"></a><a id="19915" href="1--Type-Theory.1-5--Propositions-as-Types.html#19915" class="Function">+ℕ-≡ℕ-comm</a> <a id="19926" class="Symbol">:</a> <a id="19928" class="Symbol">(</a><a id="19929" href="1--Type-Theory.1-5--Propositions-as-Types.html#19929" class="Bound">n</a> <a id="19931" href="1--Type-Theory.1-5--Propositions-as-Types.html#19931" class="Bound">m</a> <a id="19933" class="Symbol">:</a> <a id="19935" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="19936" class="Symbol">)</a> <a id="19938" class="Symbol">→</a> <a id="19940" class="Symbol">(</a><a id="19941" href="1--Type-Theory.1-5--Propositions-as-Types.html#19929" class="Bound">n</a> <a id="19943" href="1--Type-Theory.1-2--Inductive-Types.html#12858" class="Function Operator">+ℕ</a> <a id="19946" href="1--Type-Theory.1-5--Propositions-as-Types.html#19931" class="Bound">m</a><a id="19947" class="Symbol">)</a> <a id="19949" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="19952" class="Symbol">(</a><a id="19953" href="1--Type-Theory.1-5--Propositions-as-Types.html#19931" class="Bound">m</a> <a id="19955" href="1--Type-Theory.1-2--Inductive-Types.html#12858" class="Function Operator">+ℕ</a> <a id="19958" href="1--Type-Theory.1-5--Propositions-as-Types.html#19929" class="Bound">n</a><a id="19959" class="Symbol">)</a>
<a id="19961" class="Comment">-- Exercise:</a>
<a id="19974" class="Comment">-- +ℕ-≡ℕ-comm n m = {!!}</a>
</pre>
<p>It would be tedious if we had to define the specific notion of
equality we wanted for every type that we ever define. It’s also not
entirely exactly how to do it in more difficult cases.</p>
<p>For example, to say that elements in the disjoint union <code>A ⊎ B</code> are
equal, we would want to say that if <code>a = a'</code> then <code>inl a = inl a'</code> and
if <code>b = b'</code> then <code>inr b = inr b'</code>, and that it is never the case that
<code>inl a = inr b</code> since the union is disjoint. But
without knowing specifically what the types <code>A</code> and <code>B</code> are, we
don’t know what equality means for them.</p>
<p>Remarkably, it is possible to give a uniform notion of “equality” for
any type — this is the subject of Part 2 of these notes. As
we’ll see shortly, this general notion of <em>paths</em> between of elements
of general types will not always be a proposition — paths will often
be interesting pieces of data in their own right.</p>
<h2 id="induction-principles"><a class="header" href="#induction-principles">Induction Principles</a></h2>
<p>In the above we proofs we were secretly using an upgraded form of the
recursion principles for <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> and <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code> known as “induction
principles”. The difference is that where recursion principles allowed
us to define ordinary functions out of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code>, <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code>, etc.,
induction principles allow us to define <em>dependent</em> functions out of
these types into a type family of our choosing.</p>
<p><code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> is the easiest. Here a type family <code>C : Bool → Type ℓ</code>,
simply picks out two (possibly different) types, <code>C true</code> and <code>C false</code>. The recursion principle is upgraded to use one element of each
of these types rather than two elements of the same type:</p>
<pre class="Agda"><a id="Bool-ind"></a><a id="21757" href="1--Type-Theory.1-5--Propositions-as-Types.html#21757" class="Function">Bool-ind</a> <a id="21766" class="Symbol">:</a> <a id="21768" class="Symbol">{</a><a id="21769" href="1--Type-Theory.1-5--Propositions-as-Types.html#21769" class="Bound">ℓ</a> <a id="21771" class="Symbol">:</a> <a id="21773" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="21778" class="Symbol">}</a> <a id="21780" class="Symbol">{</a><a id="21781" href="1--Type-Theory.1-5--Propositions-as-Types.html#21781" class="Bound">C</a> <a id="21783" class="Symbol">:</a> <a id="21785" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="21790" class="Symbol">→</a> <a id="21792" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="21797" href="1--Type-Theory.1-5--Propositions-as-Types.html#21769" class="Bound">ℓ</a><a id="21798" class="Symbol">}</a>
  <a id="21802" class="Symbol">→</a> <a id="21804" href="1--Type-Theory.1-5--Propositions-as-Types.html#21781" class="Bound">C</a> <a id="21806" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
  <a id="21813" class="Symbol">→</a> <a id="21815" href="1--Type-Theory.1-5--Propositions-as-Types.html#21781" class="Bound">C</a> <a id="21817" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
  <a id="21825" class="Symbol">→</a> <a id="21827" class="Symbol">((</a><a id="21829" href="1--Type-Theory.1-5--Propositions-as-Types.html#21829" class="Bound">x</a> <a id="21831" class="Symbol">:</a> <a id="21833" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="21837" class="Symbol">)</a> <a id="21839" class="Symbol">→</a> <a id="21841" href="1--Type-Theory.1-5--Propositions-as-Types.html#21781" class="Bound">C</a> <a id="21843" href="1--Type-Theory.1-5--Propositions-as-Types.html#21829" class="Bound">x</a><a id="21844" class="Symbol">)</a>
<a id="21846" class="Comment">-- Exercise:</a>
<a id="21859" class="Comment">-- Bool-ind c₁ c₂ x = {!!}</a>
</pre>
<p>Try writing out the (even simpler) induction principle for the unit
type.</p>
<pre class="Agda"><a id="22076" class="Comment">-- Exercise:</a>
<a id="22089" class="Comment">-- ⊤-ind : {ℓ : Level}</a>
<a id="22112" class="Comment">--   → {A : ⊤ → Type ℓ}</a>
<a id="22136" class="Comment">--   → {!!}</a>
<a id="22148" class="Comment">--   → {!!}</a>

<a id="22339" href="1--Type-Theory.1-5--Propositions-as-Types.html#22160" class="Function">⊤-ind</a> <a id="22345" href="1--Type-Theory.1-5--Propositions-as-Types.html#22345" class="Bound">a</a> <a id="22347" href="1--Type-Theory.1-2--Inductive-Types.html#8988" class="InductiveConstructor">tt</a> <a id="22350" class="Symbol">=</a> <a id="22352" href="1--Type-Theory.1-5--Propositions-as-Types.html#22345" class="Bound">a</a>
</pre>
<p>The recursion principle for <code>A ⊎ B</code> is upgraded to an induction
principle in a similar way. Back in <code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#9979" class="Function">⊎-rec</a></code>, the inputs
were maps <code>A → C</code> and <code>B → C</code>. If <code>C</code> is now a type family dependent
on <code>A ⊎ B</code>, these maps have to land in <code>C x</code>, where <code>x</code> is some element of <code>A ⊎ B</code>.
Luckily, there are candidates for what <code>x</code> should be in both cases: take the
<code class="Agda"><a href="3--Topics.3-2--Modalities.html#8098" class="InductiveConstructor">inl</a></code> or <code class="Agda"><a href="3--Topics.3-2--Modalities.html#8119" class="InductiveConstructor">inr</a></code> of the input <code>a : A</code> or <code>b : B</code> respectively.</p>
<pre class="Agda"><a id="⊎-ind"></a><a id="22781" href="1--Type-Theory.1-5--Propositions-as-Types.html#22781" class="Function">⊎-ind</a> <a id="22787" class="Symbol">:</a> <a id="22789" class="Symbol">{</a><a id="22790" href="1--Type-Theory.1-5--Propositions-as-Types.html#22790" class="Bound">ℓ</a> <a id="22792" href="1--Type-Theory.1-5--Propositions-as-Types.html#22792" class="Bound">ℓ&#39;</a> <a id="22795" href="1--Type-Theory.1-5--Propositions-as-Types.html#22795" class="Bound">ℓ&#39;&#39;</a> <a id="22799" class="Symbol">:</a> <a id="22801" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="22806" class="Symbol">}</a> <a id="22808" class="Symbol">{</a><a id="22809" href="1--Type-Theory.1-5--Propositions-as-Types.html#22809" class="Bound">A</a> <a id="22811" class="Symbol">:</a> <a id="22813" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="22818" href="1--Type-Theory.1-5--Propositions-as-Types.html#22790" class="Bound">ℓ</a><a id="22819" class="Symbol">}</a> <a id="22821" class="Symbol">{</a><a id="22822" href="1--Type-Theory.1-5--Propositions-as-Types.html#22822" class="Bound">B</a> <a id="22824" class="Symbol">:</a> <a id="22826" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="22831" href="1--Type-Theory.1-5--Propositions-as-Types.html#22792" class="Bound">ℓ&#39;</a><a id="22833" class="Symbol">}</a> <a id="22835" class="Symbol">{</a><a id="22836" href="1--Type-Theory.1-5--Propositions-as-Types.html#22836" class="Bound">C</a> <a id="22838" class="Symbol">:</a> <a id="22840" href="1--Type-Theory.1-5--Propositions-as-Types.html#22809" class="Bound">A</a> <a id="22842" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="22844" href="1--Type-Theory.1-5--Propositions-as-Types.html#22822" class="Bound">B</a> <a id="22846" class="Symbol">→</a> <a id="22848" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="22853" href="1--Type-Theory.1-5--Propositions-as-Types.html#22795" class="Bound">ℓ&#39;&#39;</a><a id="22856" class="Symbol">}</a>
  <a id="22860" class="Symbol">→</a> <a id="22862" class="Symbol">((</a><a id="22864" href="1--Type-Theory.1-5--Propositions-as-Types.html#22864" class="Bound">a</a> <a id="22866" class="Symbol">:</a> <a id="22868" href="1--Type-Theory.1-5--Propositions-as-Types.html#22809" class="Bound">A</a><a id="22869" class="Symbol">)</a> <a id="22871" class="Symbol">→</a> <a id="22873" href="1--Type-Theory.1-5--Propositions-as-Types.html#22836" class="Bound">C</a> <a id="22875" class="Symbol">(</a><a id="22876" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8339" class="InductiveConstructor">inl</a> <a id="22880" href="1--Type-Theory.1-5--Propositions-as-Types.html#22864" class="Bound">a</a><a id="22881" class="Symbol">))</a>
  <a id="22886" class="Symbol">→</a> <a id="22888" class="Symbol">((</a><a id="22890" href="1--Type-Theory.1-5--Propositions-as-Types.html#22890" class="Bound">b</a> <a id="22892" class="Symbol">:</a> <a id="22894" href="1--Type-Theory.1-5--Propositions-as-Types.html#22822" class="Bound">B</a><a id="22895" class="Symbol">)</a> <a id="22897" class="Symbol">→</a> <a id="22899" href="1--Type-Theory.1-5--Propositions-as-Types.html#22836" class="Bound">C</a> <a id="22901" class="Symbol">(</a><a id="22902" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8357" class="InductiveConstructor">inr</a> <a id="22906" href="1--Type-Theory.1-5--Propositions-as-Types.html#22890" class="Bound">b</a><a id="22907" class="Symbol">))</a>
  <a id="22912" class="Symbol">→</a> <a id="22914" class="Symbol">(</a><a id="22915" href="1--Type-Theory.1-5--Propositions-as-Types.html#22915" class="Bound">x</a> <a id="22917" class="Symbol">:</a> <a id="22919" href="1--Type-Theory.1-5--Propositions-as-Types.html#22809" class="Bound">A</a> <a id="22921" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="22923" href="1--Type-Theory.1-5--Propositions-as-Types.html#22822" class="Bound">B</a><a id="22924" class="Symbol">)</a> <a id="22926" class="Symbol">→</a> <a id="22928" href="1--Type-Theory.1-5--Propositions-as-Types.html#22836" class="Bound">C</a> <a id="22930" href="1--Type-Theory.1-5--Propositions-as-Types.html#22915" class="Bound">x</a>
<a id="22932" class="Comment">-- Exercise:</a>
<a id="22945" class="Comment">-- ⊎-ind l r x = {!!}</a>
</pre>
<p><code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code> is a little trickier. It is best to remember ordinary
mathematical induction and think of <code>C</code> as some property of the
natural numbers that we are trying to prove is true for every natural
number. The first input is the base case of type <code>C zero</code>, the claim
that the property <code>C</code> holds for <code class="Agda"><a href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a></code>. Then we have the inductive
step for <code class="Agda"><a href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a></code> saying that, for any <code>n : ℕ</code>, if <code>C</code> holds for <code>n</code>
then it also holds for <code>suc n</code>.</p>
<p>If we can provide both of those things, then we get a function from
<code>(n : ℕ) → C n</code>, meaning that <code>C</code> holds for every <code>n</code>.</p>
<pre class="Agda"><a id="ℕ-ind"></a><a id="23635" href="1--Type-Theory.1-5--Propositions-as-Types.html#23635" class="Function">ℕ-ind</a> <a id="23641" class="Symbol">:</a> <a id="23643" class="Symbol">{</a><a id="23644" href="1--Type-Theory.1-5--Propositions-as-Types.html#23644" class="Bound">ℓ</a> <a id="23646" class="Symbol">:</a> <a id="23648" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="23653" class="Symbol">}</a> <a id="23655" class="Symbol">{</a><a id="23656" href="1--Type-Theory.1-5--Propositions-as-Types.html#23656" class="Bound">C</a> <a id="23658" class="Symbol">:</a> <a id="23660" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="23662" class="Symbol">→</a> <a id="23664" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="23669" href="1--Type-Theory.1-5--Propositions-as-Types.html#23644" class="Bound">ℓ</a><a id="23670" class="Symbol">}</a>
  <a id="23674" class="Symbol">→</a> <a id="23676" class="Symbol">(</a><a id="23677" href="1--Type-Theory.1-5--Propositions-as-Types.html#23677" class="Bound">z</a> <a id="23679" class="Symbol">:</a> <a id="23681" href="1--Type-Theory.1-5--Propositions-as-Types.html#23656" class="Bound">C</a> <a id="23683" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="23687" class="Symbol">)</a>
  <a id="23691" class="Symbol">→</a> <a id="23693" class="Symbol">(</a><a id="23694" href="1--Type-Theory.1-5--Propositions-as-Types.html#23694" class="Bound">r</a> <a id="23696" class="Symbol">:</a> <a id="23698" class="Symbol">(</a><a id="23699" href="1--Type-Theory.1-5--Propositions-as-Types.html#23699" class="Bound">n</a> <a id="23701" class="Symbol">:</a> <a id="23703" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="23704" class="Symbol">)</a> <a id="23706" class="Symbol">→</a> <a id="23708" href="1--Type-Theory.1-5--Propositions-as-Types.html#23656" class="Bound">C</a> <a id="23710" href="1--Type-Theory.1-5--Propositions-as-Types.html#23699" class="Bound">n</a> <a id="23712" class="Symbol">→</a> <a id="23714" href="1--Type-Theory.1-5--Propositions-as-Types.html#23656" class="Bound">C</a> <a id="23716" class="Symbol">(</a><a id="23717" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="23721" href="1--Type-Theory.1-5--Propositions-as-Types.html#23699" class="Bound">n</a><a id="23722" class="Symbol">))</a>
  <a id="23727" class="Symbol">→</a> <a id="23729" class="Symbol">((</a><a id="23731" href="1--Type-Theory.1-5--Propositions-as-Types.html#23731" class="Bound">n</a> <a id="23733" class="Symbol">:</a> <a id="23735" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="23736" class="Symbol">)</a> <a id="23738" class="Symbol">→</a> <a id="23740" href="1--Type-Theory.1-5--Propositions-as-Types.html#23656" class="Bound">C</a> <a id="23742" href="1--Type-Theory.1-5--Propositions-as-Types.html#23731" class="Bound">n</a><a id="23743" class="Symbol">)</a>
<a id="23745" class="Comment">-- Exercise:</a>
<a id="23758" class="Comment">-- ℕ-ind z r n = ?</a>
</pre>
<p>We don’t often need to use <code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#21757" class="Function">Bool-ind</a></code>, <code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#22781" class="Function">⊎-ind</a></code> or <code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#23635" class="Function">ℕ-ind</a></code>; we
can instead use the pattern-matching features of Agda directly.</p>
<h2 id="quantifiers"><a class="header" href="#quantifiers">Quantifiers</a></h2>
<p>One thing we are still missing from ordinary logic is
<em>quantification</em>, that is, the propositions</p>
<ul>
<li>“for all elements <code>x : A</code>, the proposition <code>P x</code> holds”, a.k.a. <code>∀ x. P(x)</code>, and</li>
<li>“there exists an element <code>x : A</code> so that <code>P x</code>” holds, a.k.a. <code>∃ x. P(x)</code>.</li>
</ul>
<p>For our purposes here, we will consider any type family <code>P : A → Type</code>
as expressing a predicate on elements of <code>A</code>. For example, we have the
predicate on natural numbers that identifies when the natural number
is <code class="Agda"><a href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a></code>.</p>
<pre class="Agda"><a id="isZeroP"></a><a id="24532" href="1--Type-Theory.1-5--Propositions-as-Types.html#24532" class="Function">isZeroP</a> <a id="24540" class="Symbol">:</a> <a id="24542" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="24544" class="Symbol">→</a> <a id="24546" href="Library.Primitive.html#422" class="Primitive">Type</a>
<a id="24551" href="1--Type-Theory.1-5--Propositions-as-Types.html#24532" class="Function">isZeroP</a> <a id="24559" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="24564" class="Symbol">=</a> <a id="24566" href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a>
<a id="24568" href="1--Type-Theory.1-5--Propositions-as-Types.html#24532" class="Function">isZeroP</a> <a id="24576" class="Symbol">(</a><a id="24577" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="24581" href="1--Type-Theory.1-5--Propositions-as-Types.html#24581" class="Bound">n</a><a id="24582" class="Symbol">)</a> <a id="24584" class="Symbol">=</a> <a id="24586" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a>
</pre>
<p>In cases like this where we already have a map into <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code>, we
can turn it into a predicate by applying <code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a></code>.</p>
<pre class="Agda"><a id="isEvenP"></a><a id="24716" href="1--Type-Theory.1-5--Propositions-as-Types.html#24716" class="Function">isEvenP</a> <a id="24724" class="Symbol">:</a> <a id="24726" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="24728" class="Symbol">→</a> <a id="24730" href="Library.Primitive.html#422" class="Primitive">Type</a>
<a id="24735" href="1--Type-Theory.1-5--Propositions-as-Types.html#24716" class="Function">isEvenP</a> <a id="24743" href="1--Type-Theory.1-5--Propositions-as-Types.html#24743" class="Bound">n</a> <a id="24745" class="Symbol">=</a> <a id="24747" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="24754" class="Symbol">(</a><a id="24755" href="1--Type-Theory.1-2--Inductive-Types.html#12646" class="Function">isEven</a> <a id="24762" href="1--Type-Theory.1-5--Propositions-as-Types.html#24743" class="Bound">n</a><a id="24763" class="Symbol">)</a>

<a id="isOddP"></a><a id="24766" href="1--Type-Theory.1-5--Propositions-as-Types.html#24766" class="Function">isOddP</a> <a id="24773" class="Symbol">:</a> <a id="24775" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="24777" class="Symbol">→</a> <a id="24779" href="Library.Primitive.html#422" class="Primitive">Type</a>
<a id="24784" href="1--Type-Theory.1-5--Propositions-as-Types.html#24766" class="Function">isOddP</a> <a id="24791" href="1--Type-Theory.1-5--Propositions-as-Types.html#24791" class="Bound">n</a> <a id="24793" class="Symbol">=</a> <a id="24795" href="1--Type-Theory.1-5--Propositions-as-Types.html#2556" class="Function">IsTrue</a> <a id="24802" class="Symbol">(</a><a id="24803" href="1--Type-Theory.1-2--Inductive-Types.html#12664" class="Function">isOdd</a> <a id="24809" href="1--Type-Theory.1-5--Propositions-as-Types.html#24791" class="Bound">n</a><a id="24810" class="Symbol">)</a>
</pre>
<p>We can combine these predicates using the operations we’ve already
seen, for example, we can form the predicate on natural numbers <code>n</code>
that the number <code>n</code> is even or odd.</p>
<pre class="Agda"><a id="evenOrOdd"></a><a id="24993" href="1--Type-Theory.1-5--Propositions-as-Types.html#24993" class="Function">evenOrOdd</a> <a id="25003" class="Symbol">:</a> <a id="25005" class="Symbol">(</a><a id="25006" href="1--Type-Theory.1-5--Propositions-as-Types.html#25006" class="Bound">n</a> <a id="25008" class="Symbol">:</a> <a id="25010" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="25011" class="Symbol">)</a> <a id="25013" class="Symbol">→</a> <a id="25015" href="Library.Primitive.html#422" class="Primitive">Type</a>
<a id="25020" href="1--Type-Theory.1-5--Propositions-as-Types.html#24993" class="Function">evenOrOdd</a> <a id="25030" href="1--Type-Theory.1-5--Propositions-as-Types.html#25030" class="Bound">n</a> <a id="25032" class="Symbol">=</a> <a id="25034" href="1--Type-Theory.1-5--Propositions-as-Types.html#24716" class="Function">isEvenP</a> <a id="25042" href="1--Type-Theory.1-5--Propositions-as-Types.html#25030" class="Bound">n</a> <a id="25044" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="25046" href="1--Type-Theory.1-5--Propositions-as-Types.html#24766" class="Function">isOddP</a> <a id="25053" href="1--Type-Theory.1-5--Propositions-as-Types.html#25030" class="Bound">n</a>
</pre>
<p>Of course this should be true for <em>every</em> element <code>n</code>. The proposition
<code>∀ n. P(n)</code> is represented by a dependent function from natural
numbers <code>n</code> to proofs that <code>evenOrOdd n</code> holds.</p>
<pre class="Agda"><a id="∀-evenOrOdd"></a><a id="25248" href="1--Type-Theory.1-5--Propositions-as-Types.html#25248" class="Function">∀-evenOrOdd</a> <a id="25260" class="Symbol">:</a> <a id="25262" class="Symbol">(</a><a id="25263" href="1--Type-Theory.1-5--Propositions-as-Types.html#25263" class="Bound">n</a> <a id="25265" class="Symbol">:</a> <a id="25267" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="25268" class="Symbol">)</a> <a id="25270" class="Symbol">→</a> <a id="25272" href="1--Type-Theory.1-5--Propositions-as-Types.html#24993" class="Function">evenOrOdd</a> <a id="25282" href="1--Type-Theory.1-5--Propositions-as-Types.html#25263" class="Bound">n</a>
<a id="25284" class="Comment">-- Exercise:</a>
<a id="25297" class="Comment">-- ∀-evenOrOdd n = {!!}</a>
</pre>
<p>Try another simple case:</p>
<pre class="Agda"><a id="∀-zeroImpliesEven"></a><a id="25537" href="1--Type-Theory.1-5--Propositions-as-Types.html#25537" class="Function">∀-zeroImpliesEven</a> <a id="25555" class="Symbol">:</a> <a id="25557" class="Symbol">(</a><a id="25558" href="1--Type-Theory.1-5--Propositions-as-Types.html#25558" class="Bound">n</a> <a id="25560" class="Symbol">:</a> <a id="25562" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="25563" class="Symbol">)</a> <a id="25565" class="Symbol">→</a> <a id="25567" class="Symbol">(</a><a id="25568" href="1--Type-Theory.1-5--Propositions-as-Types.html#24532" class="Function">isZeroP</a> <a id="25576" href="1--Type-Theory.1-5--Propositions-as-Types.html#25558" class="Bound">n</a><a id="25577" class="Symbol">)</a> <a id="25579" class="Symbol">→</a> <a id="25581" class="Symbol">(</a><a id="25582" href="1--Type-Theory.1-5--Propositions-as-Types.html#24716" class="Function">isEvenP</a> <a id="25590" href="1--Type-Theory.1-5--Propositions-as-Types.html#25558" class="Bound">n</a><a id="25591" class="Symbol">)</a>
<a id="25593" class="Comment">-- Exercise:</a>
<a id="25606" class="Comment">-- ∀-zeroImpliesEven n = {!!}</a>
</pre>
<p>For the proposition <code>∃ n. P(n)</code>, the obvious thing to try is a
dependent pair: that is, a proof of <code>∃ n. P(n)</code> should be an actual
example of an <code>n</code> together with a proof that <code>P(n)</code> holds. So, we
might represent the proposition that there exists an even number as:</p>
<pre class="Agda"><a id="Even"></a><a id="26025" href="1--Type-Theory.1-5--Propositions-as-Types.html#26025" class="Function">Even</a> <a id="26030" class="Symbol">:</a> <a id="26032" href="Library.Prelude.html#1429" class="Function">Σ[</a> <a id="26035" href="1--Type-Theory.1-5--Propositions-as-Types.html#26035" class="Bound">n</a> <a id="26037" href="Library.Prelude.html#1429" class="Function">∈</a> <a id="26039" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="26041" href="Library.Prelude.html#1429" class="Function">]</a> <a id="26043" href="1--Type-Theory.1-5--Propositions-as-Types.html#24716" class="Function">isEvenP</a> <a id="26051" href="1--Type-Theory.1-5--Propositions-as-Types.html#26035" class="Bound">n</a>
<a id="26053" href="1--Type-Theory.1-5--Propositions-as-Types.html#26025" class="Function">Even</a> <a id="26058" class="Symbol">=</a> <a id="26060" class="Number">2</a> <a id="26062" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="26064" href="1--Type-Theory.1-2--Inductive-Types.html#8988" class="InductiveConstructor">tt</a>
</pre>
<p>This interpretation of <code>∃</code> is not quite right for similar reasons that
<code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype">⊎</a></code> is not quite right. After all, there are lots of different even
numbers that we can use to inhabit the above type, and so the type
represents more information than the mere proposition that there
exists an even number: it comes with a specific choice of one. Again
we will fix this in Lecture 2-X.</p>
<p>For the following exercises, you should recall that <code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function">¬</a></code> is simply
functions into <code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a></code>. Once you unfold that definition, the below
exercises are <em>exactly</em> two functions that we have seen before.</p>
<pre class="Agda"><a id="¬Σ→forall¬"></a><a id="26650" href="1--Type-Theory.1-5--Propositions-as-Types.html#26650" class="Function">¬Σ→forall¬</a> <a id="26661" class="Symbol">:</a> <a id="26663" class="Symbol">{</a><a id="26664" href="1--Type-Theory.1-5--Propositions-as-Types.html#26664" class="Bound">A</a> <a id="26666" class="Symbol">:</a> <a id="26668" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="26672" class="Symbol">}</a> <a id="26674" class="Symbol">{</a><a id="26675" href="1--Type-Theory.1-5--Propositions-as-Types.html#26675" class="Bound">B</a> <a id="26677" class="Symbol">:</a> <a id="26679" href="1--Type-Theory.1-5--Propositions-as-Types.html#26664" class="Bound">A</a> <a id="26681" class="Symbol">→</a> <a id="26683" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="26687" class="Symbol">}</a>
  <a id="26691" class="Symbol">→</a> <a id="26693" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="26695" class="Symbol">(</a><a id="26696" href="Library.Prelude.html#1429" class="Function">Σ[</a> <a id="26699" href="1--Type-Theory.1-5--Propositions-as-Types.html#26699" class="Bound">a</a> <a id="26701" href="Library.Prelude.html#1429" class="Function">∈</a> <a id="26703" href="1--Type-Theory.1-5--Propositions-as-Types.html#26664" class="Bound">A</a> <a id="26705" href="Library.Prelude.html#1429" class="Function">]</a> <a id="26707" href="1--Type-Theory.1-5--Propositions-as-Types.html#26675" class="Bound">B</a> <a id="26709" href="1--Type-Theory.1-5--Propositions-as-Types.html#26699" class="Bound">a</a><a id="26710" class="Symbol">)</a> <a id="26712" class="Symbol">→</a> <a id="26714" class="Symbol">(</a><a id="26715" href="1--Type-Theory.1-5--Propositions-as-Types.html#26715" class="Bound">a</a> <a id="26717" class="Symbol">:</a> <a id="26719" href="1--Type-Theory.1-5--Propositions-as-Types.html#26664" class="Bound">A</a><a id="26720" class="Symbol">)</a> <a id="26722" class="Symbol">→</a> <a id="26724" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="26726" href="1--Type-Theory.1-5--Propositions-as-Types.html#26675" class="Bound">B</a> <a id="26728" href="1--Type-Theory.1-5--Propositions-as-Types.html#26715" class="Bound">a</a>
<a id="26730" class="Comment">-- Exercise:</a>
<a id="26743" class="Comment">-- ¬Σ→forall¬ = ?</a>

<a id="forall¬→¬Σ"></a><a id="26810" href="1--Type-Theory.1-5--Propositions-as-Types.html#26810" class="Function">forall¬→¬Σ</a> <a id="26821" class="Symbol">:</a> <a id="26823" class="Symbol">{</a><a id="26824" href="1--Type-Theory.1-5--Propositions-as-Types.html#26824" class="Bound">A</a> <a id="26826" class="Symbol">:</a> <a id="26828" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="26832" class="Symbol">}</a> <a id="26834" class="Symbol">{</a><a id="26835" href="1--Type-Theory.1-5--Propositions-as-Types.html#26835" class="Bound">B</a> <a id="26837" class="Symbol">:</a> <a id="26839" href="1--Type-Theory.1-5--Propositions-as-Types.html#26824" class="Bound">A</a> <a id="26841" class="Symbol">→</a> <a id="26843" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="26847" class="Symbol">}</a>
  <a id="26851" class="Symbol">→</a> <a id="26853" class="Symbol">((</a><a id="26855" href="1--Type-Theory.1-5--Propositions-as-Types.html#26855" class="Bound">a</a> <a id="26857" class="Symbol">:</a> <a id="26859" href="1--Type-Theory.1-5--Propositions-as-Types.html#26824" class="Bound">A</a><a id="26860" class="Symbol">)</a> <a id="26862" class="Symbol">→</a> <a id="26864" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="26866" href="1--Type-Theory.1-5--Propositions-as-Types.html#26835" class="Bound">B</a> <a id="26868" href="1--Type-Theory.1-5--Propositions-as-Types.html#26855" class="Bound">a</a><a id="26869" class="Symbol">)</a> <a id="26871" class="Symbol">→</a> <a id="26873" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="26875" class="Symbol">(</a><a id="26876" href="Library.Prelude.html#1429" class="Function">Σ[</a> <a id="26879" href="1--Type-Theory.1-5--Propositions-as-Types.html#26879" class="Bound">a</a> <a id="26881" href="Library.Prelude.html#1429" class="Function">∈</a> <a id="26883" href="1--Type-Theory.1-5--Propositions-as-Types.html#26824" class="Bound">A</a> <a id="26885" href="Library.Prelude.html#1429" class="Function">]</a> <a id="26887" href="1--Type-Theory.1-5--Propositions-as-Types.html#26835" class="Bound">B</a> <a id="26889" href="1--Type-Theory.1-5--Propositions-as-Types.html#26879" class="Bound">a</a><a id="26890" class="Symbol">)</a>
<a id="26892" class="Comment">-- Exercise:</a>
<a id="26905" class="Comment">-- forall¬→¬Σ = ?</a>
</pre>
<h2 id="decidable-types"><a class="header" href="#decidable-types">Decidable Types</a></h2>
<p>There is another crucial way in which constructive logic differs from
classical logic: the Law of Excluded Middle. For propositions
represented as Booleans, we saw in <code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#14224" class="Function">≡Bool-LEM</a></code> that every Boolean
element is either <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a></code> or <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a></code>. It seems reasonable for
something similar to be true for propositions as types.</p>
<p>And yet, you will have a hard time proving the following!</p>
<pre class="Agda"><a id="27384" class="Comment">-- Uncomment to try if you want!</a>
<a id="27417" class="Comment">-- impossible-LEM : {ℓ : Level} (P : Type ℓ) → (¬ P) ⊎ P</a>
<a id="27474" class="Comment">-- impossible-LEM = {!!}</a>
</pre>
<p>and in fact, the two impossible problems we have seen so far are
related: as soon as you can solve one, you can solve the other.</p>
<pre class="Agda"><a id="27638" class="Comment">-- If you have `LEM` for a type `P`, then you have ¬¬-implies</a>
<a id="LEM→¬¬implies"></a><a id="27700" href="1--Type-Theory.1-5--Propositions-as-Types.html#27700" class="Function">LEM→¬¬implies</a> <a id="27714" class="Symbol">:</a> <a id="27716" class="Symbol">{</a><a id="27717" href="1--Type-Theory.1-5--Propositions-as-Types.html#27717" class="Bound">ℓ</a> <a id="27719" class="Symbol">:</a> <a id="27721" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="27726" class="Symbol">}</a> <a id="27728" class="Symbol">{</a><a id="27729" href="1--Type-Theory.1-5--Propositions-as-Types.html#27729" class="Bound">P</a> <a id="27731" class="Symbol">:</a> <a id="27733" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="27738" href="1--Type-Theory.1-5--Propositions-as-Types.html#27717" class="Bound">ℓ</a><a id="27739" class="Symbol">}</a>
  <a id="27743" class="Symbol">→</a> <a id="27745" class="Symbol">((</a><a id="27747" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="27749" href="1--Type-Theory.1-5--Propositions-as-Types.html#27729" class="Bound">P</a><a id="27750" class="Symbol">)</a> <a id="27752" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="27754" href="1--Type-Theory.1-5--Propositions-as-Types.html#27729" class="Bound">P</a><a id="27755" class="Symbol">)</a>
  <a id="27759" class="Symbol">→</a> <a id="27761" class="Symbol">(</a><a id="27762" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="27764" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="27766" href="1--Type-Theory.1-5--Propositions-as-Types.html#27729" class="Bound">P</a> <a id="27768" class="Symbol">→</a> <a id="27770" href="1--Type-Theory.1-5--Propositions-as-Types.html#27729" class="Bound">P</a><a id="27771" class="Symbol">)</a>
<a id="27773" class="Comment">-- Exercise:</a>
<a id="27786" class="Comment">-- LEM→¬¬implies p = {!!}</a>

<a id="27939" class="Comment">-- We almost have LEM for any particular `P`:</a>
<a id="¬¬LEM"></a><a id="27985" href="1--Type-Theory.1-5--Propositions-as-Types.html#27985" class="Function">¬¬LEM</a> <a id="27991" class="Symbol">:</a> <a id="27993" class="Symbol">{</a><a id="27994" href="1--Type-Theory.1-5--Propositions-as-Types.html#27994" class="Bound">ℓ</a> <a id="27996" class="Symbol">:</a> <a id="27998" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="28003" class="Symbol">}</a> <a id="28005" class="Symbol">{</a><a id="28006" href="1--Type-Theory.1-5--Propositions-as-Types.html#28006" class="Bound">P</a> <a id="28008" class="Symbol">:</a> <a id="28010" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="28015" href="1--Type-Theory.1-5--Propositions-as-Types.html#27994" class="Bound">ℓ</a><a id="28016" class="Symbol">}</a> <a id="28018" class="Symbol">→</a> <a id="28020" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="28022" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="28024" class="Symbol">((</a><a id="28026" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="28028" href="1--Type-Theory.1-5--Propositions-as-Types.html#28006" class="Bound">P</a><a id="28029" class="Symbol">)</a> <a id="28031" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="28033" href="1--Type-Theory.1-5--Propositions-as-Types.html#28006" class="Bound">P</a><a id="28034" class="Symbol">)</a>
<a id="28036" class="Comment">-- Exercise:</a>
<a id="28049" class="Comment">-- ¬¬LEM x = {!!}</a>

<a id="28131" class="Comment">-- Suppose you have `¬¬implies` for `(¬ P) ⊎ P`, then:</a>
<a id="¬¬implies→LEM"></a><a id="28186" href="1--Type-Theory.1-5--Propositions-as-Types.html#28186" class="Function">¬¬implies→LEM</a> <a id="28200" class="Symbol">:</a> <a id="28202" class="Symbol">{</a><a id="28203" href="1--Type-Theory.1-5--Propositions-as-Types.html#28203" class="Bound">ℓ</a> <a id="28205" class="Symbol">:</a> <a id="28207" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="28212" class="Symbol">}</a> <a id="28214" class="Symbol">{</a><a id="28215" href="1--Type-Theory.1-5--Propositions-as-Types.html#28215" class="Bound">P</a> <a id="28217" class="Symbol">:</a> <a id="28219" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="28224" href="1--Type-Theory.1-5--Propositions-as-Types.html#28203" class="Bound">ℓ</a><a id="28225" class="Symbol">}</a>
              <a id="28241" class="Symbol">→</a> <a id="28243" class="Symbol">(</a><a id="28244" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="28246" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="28248" class="Symbol">((</a><a id="28250" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="28252" href="1--Type-Theory.1-5--Propositions-as-Types.html#28215" class="Bound">P</a><a id="28253" class="Symbol">)</a> <a id="28255" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="28257" href="1--Type-Theory.1-5--Propositions-as-Types.html#28215" class="Bound">P</a><a id="28258" class="Symbol">)</a> <a id="28260" class="Symbol">→</a> <a id="28262" class="Symbol">(</a><a id="28263" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="28265" href="1--Type-Theory.1-5--Propositions-as-Types.html#28215" class="Bound">P</a><a id="28266" class="Symbol">)</a> <a id="28268" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="28270" href="1--Type-Theory.1-5--Propositions-as-Types.html#28215" class="Bound">P</a><a id="28271" class="Symbol">)</a>
              <a id="28287" class="Symbol">→</a> <a id="28289" class="Symbol">((</a><a id="28291" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="28293" href="1--Type-Theory.1-5--Propositions-as-Types.html#28215" class="Bound">P</a><a id="28294" class="Symbol">)</a> <a id="28296" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="28298" href="1--Type-Theory.1-5--Propositions-as-Types.html#28215" class="Bound">P</a><a id="28299" class="Symbol">)</a>
<a id="28301" class="Comment">-- Exercise:</a>
<a id="28314" class="Comment">-- ¬¬implies→LEM f = {!!}</a>
</pre>
<p>So if we have a general proposition <code>P</code>, we cannot split into
cases for whether <code>P</code> holds or not this: would be saying that we
always have an element of <code>P ⊎ ¬ P</code> telling us whether a proposition
is true.</p>
<p>For some specific types, we can show that <code>P ⊎ ¬ P</code> holds: we call
such types “decidable”. The following type is essentially identical to
the type <code>P ⊎ ¬ P</code> but we define a new type so we can give it more
meaningful constructor names.</p>
<pre class="Agda"><a id="28844" class="Keyword">data</a> <a id="Dec"></a><a id="28849" href="1--Type-Theory.1-5--Propositions-as-Types.html#28849" class="Datatype">Dec</a> <a id="28853" class="Symbol">{</a><a id="28854" href="1--Type-Theory.1-5--Propositions-as-Types.html#28854" class="Bound">ℓ</a> <a id="28856" class="Symbol">:</a> <a id="28858" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="28863" class="Symbol">}</a> <a id="28865" class="Symbol">(</a><a id="28866" href="1--Type-Theory.1-5--Propositions-as-Types.html#28866" class="Bound">P</a> <a id="28868" class="Symbol">:</a> <a id="28870" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="28875" href="1--Type-Theory.1-5--Propositions-as-Types.html#28854" class="Bound">ℓ</a><a id="28876" class="Symbol">)</a> <a id="28878" class="Symbol">:</a> <a id="28880" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="28885" href="1--Type-Theory.1-5--Propositions-as-Types.html#28854" class="Bound">ℓ</a> <a id="28887" class="Keyword">where</a>
  <a id="Dec.yes"></a><a id="28895" href="1--Type-Theory.1-5--Propositions-as-Types.html#28895" class="InductiveConstructor">yes</a> <a id="28899" class="Symbol">:</a> <a id="28901" class="Symbol">(</a> <a id="28903" href="1--Type-Theory.1-5--Propositions-as-Types.html#28903" class="Bound">p</a> <a id="28905" class="Symbol">:</a>   <a id="28909" href="1--Type-Theory.1-5--Propositions-as-Types.html#28866" class="Bound">P</a><a id="28910" class="Symbol">)</a> <a id="28912" class="Symbol">→</a> <a id="28914" href="1--Type-Theory.1-5--Propositions-as-Types.html#28849" class="Datatype">Dec</a> <a id="28918" href="1--Type-Theory.1-5--Propositions-as-Types.html#28866" class="Bound">P</a>
  <a id="Dec.no"></a><a id="28922" href="1--Type-Theory.1-5--Propositions-as-Types.html#28922" class="InductiveConstructor">no</a>  <a id="28926" class="Symbol">:</a> <a id="28928" class="Symbol">(</a><a id="28929" href="1--Type-Theory.1-5--Propositions-as-Types.html#28929" class="Bound">¬p</a> <a id="28932" class="Symbol">:</a> <a id="28934" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="28936" href="1--Type-Theory.1-5--Propositions-as-Types.html#28866" class="Bound">P</a><a id="28937" class="Symbol">)</a> <a id="28939" class="Symbol">→</a> <a id="28941" href="1--Type-Theory.1-5--Propositions-as-Types.html#28849" class="Datatype">Dec</a> <a id="28945" href="1--Type-Theory.1-5--Propositions-as-Types.html#28866" class="Bound">P</a>
</pre>
<p>Here are the simplest examples:</p>
<pre class="Agda"><a id="Dec⊤"></a><a id="28989" href="1--Type-Theory.1-5--Propositions-as-Types.html#28989" class="Function">Dec⊤</a> <a id="28994" class="Symbol">:</a> <a id="28996" href="1--Type-Theory.1-5--Propositions-as-Types.html#28849" class="Datatype">Dec</a> <a id="29000" href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a>
<a id="29002" class="Comment">-- Exercise:</a>
<a id="29015" class="Comment">-- Dec⊤ = {!!}</a>

<a id="Dec∅"></a><a id="29072" href="1--Type-Theory.1-5--Propositions-as-Types.html#29072" class="Function">Dec∅</a> <a id="29077" class="Symbol">:</a> <a id="29079" href="1--Type-Theory.1-5--Propositions-as-Types.html#28849" class="Datatype">Dec</a> <a id="29083" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a>
<a id="29085" class="Comment">-- Exercise:</a>
<a id="29098" class="Comment">-- Dec∅ = {!!}</a>
</pre>
<p>The predicates we defined on data types so far are all decidable
because we built them out of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a></code> and <code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a></code>.</p>
<pre class="Agda"><a id="Dec-isEvenP"></a><a id="29281" href="1--Type-Theory.1-5--Propositions-as-Types.html#29281" class="Function">Dec-isEvenP</a> <a id="29293" class="Symbol">:</a> <a id="29295" class="Symbol">(</a><a id="29296" href="1--Type-Theory.1-5--Propositions-as-Types.html#29296" class="Bound">n</a> <a id="29298" class="Symbol">:</a> <a id="29300" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="29301" class="Symbol">)</a> <a id="29303" class="Symbol">→</a> <a id="29305" href="1--Type-Theory.1-5--Propositions-as-Types.html#28849" class="Datatype">Dec</a> <a id="29309" class="Symbol">(</a><a id="29310" href="1--Type-Theory.1-5--Propositions-as-Types.html#24716" class="Function">isEvenP</a> <a id="29318" href="1--Type-Theory.1-5--Propositions-as-Types.html#29296" class="Bound">n</a><a id="29319" class="Symbol">)</a>
<a id="29321" class="Comment">-- Exercise:</a>
<a id="29334" class="Comment">-- Dec-isEvenP n = {!!}</a>
</pre>
<p>In particular, observational equality of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> and <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code> is
decidable. Just pattern match and observe whether or not they are
equal!</p>
<pre class="Agda"><a id="Dec-≡Bool"></a><a id="29681" href="1--Type-Theory.1-5--Propositions-as-Types.html#29681" class="Function">Dec-≡Bool</a> <a id="29691" class="Symbol">:</a> <a id="29693" class="Symbol">(</a><a id="29694" href="1--Type-Theory.1-5--Propositions-as-Types.html#29694" class="Bound">a</a> <a id="29696" href="1--Type-Theory.1-5--Propositions-as-Types.html#29696" class="Bound">b</a> <a id="29698" class="Symbol">:</a> <a id="29700" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="29704" class="Symbol">)</a> <a id="29706" class="Symbol">→</a> <a id="29708" href="1--Type-Theory.1-5--Propositions-as-Types.html#28849" class="Datatype">Dec</a> <a id="29712" class="Symbol">(</a><a id="29713" href="1--Type-Theory.1-5--Propositions-as-Types.html#29694" class="Bound">a</a> <a id="29715" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="29721" href="1--Type-Theory.1-5--Propositions-as-Types.html#29696" class="Bound">b</a><a id="29722" class="Symbol">)</a>
<a id="29724" class="Comment">-- Exercise:</a>
<a id="29737" class="Comment">-- Dec-≡Bool a b = {!!}</a>

<a id="Dec-≡ℕ"></a><a id="29982" href="1--Type-Theory.1-5--Propositions-as-Types.html#29982" class="Function">Dec-≡ℕ</a> <a id="29989" class="Symbol">:</a> <a id="29991" class="Symbol">(</a><a id="29992" href="1--Type-Theory.1-5--Propositions-as-Types.html#29992" class="Bound">a</a> <a id="29994" href="1--Type-Theory.1-5--Propositions-as-Types.html#29994" class="Bound">b</a> <a id="29996" class="Symbol">:</a> <a id="29998" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="29999" class="Symbol">)</a> <a id="30001" class="Symbol">→</a> <a id="30003" href="1--Type-Theory.1-5--Propositions-as-Types.html#28849" class="Datatype">Dec</a> <a id="30007" class="Symbol">(</a><a id="30008" href="1--Type-Theory.1-5--Propositions-as-Types.html#29992" class="Bound">a</a> <a id="30010" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="30013" href="1--Type-Theory.1-5--Propositions-as-Types.html#29994" class="Bound">b</a><a id="30014" class="Symbol">)</a>
<a id="30016" class="Comment">-- Exercise:</a>
<a id="30029" class="Comment">-- Dec-≡ℕ a b = {!!}</a>
</pre>
<p>We further discuss constructive mathematics and its limits in the
Lecture 3-X.</p>
<h2 id="references-and-further-reading"><a class="header" href="#references-and-further-reading">References and Further Reading</a></h2>
<p>mvrnote:</p>

                  </main>
                  <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                  </div>
                </div>
            </div>
        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>


    </div>
    </body>
</html>
