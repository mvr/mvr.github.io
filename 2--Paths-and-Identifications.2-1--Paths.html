<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2.1: Paths - Introduction to Homotopy Type Theory in Cubical Agda</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/Agda.css">
        <link rel="stylesheet" href="theme/css/Agda-highlight.css">
        <link rel="stylesheet" href="theme/pagetoc.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="chapter-item affix "><a href="INSTALLING_AGDA.html">Installing Agda</a></li><li class="chapter-item affix "><a href="USING_AGDA.html">Using Agda</a></li><li class="chapter-item affix "><li class="part-title">Type Theory</li><li class="chapter-item "><a href="1--Type-Theory.1-1--Types-and-Functions.html">1.1: Types and Functions</a></li><li class="chapter-item "><a href="1--Type-Theory.1-2--Inductive-Types.html">1.2: Inductive Types</a></li><li class="chapter-item "><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html">1.3: Universes and More Inductive Types</a></li><li class="chapter-item "><a href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html">1.4: Record Types and Copatterns</a></li><li class="chapter-item "><a href="1--Type-Theory.1-5--Propositions-as-Types.html">1.5: Propositions as Types</a></li><li class="chapter-item affix "><li class="part-title">Paths and Identifications</li><li class="chapter-item expanded "><a href="2--Paths-and-Identifications.2-1--Paths.html" class="active">2.1: Paths</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html">2.2: Equivalences and Path Algebra</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html">2.3: Substitution and J</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html">2.4: Composition and Filling</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-5--Transport.html">2.5: Transport</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-6--Univalence.html">2.6: Univalence</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-7--Propositions.html">2.7: Propositions</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-8--Sets-and-Higher-Types.html">2.8: Sets and Higher Types</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-9--Contractible-Maps.html">2.9: Contractible Maps</a></li><li class="chapter-item affix "><li class="part-title">Topics</li><li class="chapter-item "><a href="3--Topics.3-1--Structure-Identity-Principle.html">3.1: The Structure Identity Principle</a></li><li class="chapter-item "><a href="3--Topics.3-2--Modalities.html">3.2: Modalities</a></li><li class="chapter-item "><a href="3--Topics.3-3--Constructive-Logic.html">3.3: Constructive Logic</a></li><li class="chapter-item affix "><li class="part-title">Behind-the-Scenes</li><li class="chapter-item "><a href="Library.Primitive.html">Primitives</a></li><li class="chapter-item "><a href="Library.Prelude.html">Prelude</a></li><li class="chapter-item "><a href="Library.Univalence.html">Univalence</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="UNICODE_DICTIONARY.html">Unicode Dictionary</a></li><li class="chapter-item affix "><a href="ACKNOWLEDGEMENTS.html">Acknowledgements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <!-- <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li> -->
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Homotopy Type Theory in Cubical Agda</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/CQTS/introduction-to-cubical" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                  <main>
                    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<!--
<pre class="Agda"><a id="10" class="Keyword">module</a> <a id="17" href="2--Paths-and-Identifications.2-1--Paths.html" class="Module">2--Paths-and-Identifications.2-1--Paths</a> <a id="57" class="Keyword">where</a>

<a id="64" class="Keyword">open</a> <a id="69" class="Keyword">import</a> <a id="76" href="Library.Prelude.html" class="Module">Library.Prelude</a>
<a id="92" class="Keyword">open</a> <a id="97" class="Keyword">import</a> <a id="104" href="1--Type-Theory.1-1--Types-and-Functions.html" class="Module">1--Type-Theory.1-1--Types-and-Functions</a>
<a id="144" class="Keyword">open</a> <a id="149" class="Keyword">import</a> <a id="156" href="1--Type-Theory.1-2--Inductive-Types.html" class="Module">1--Type-Theory.1-2--Inductive-Types</a>
<a id="192" class="Keyword">open</a> <a id="197" class="Keyword">import</a> <a id="204" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html" class="Module">1--Type-Theory.1-3--Universes-and-More-Inductive-Types</a>
<a id="259" class="Keyword">open</a> <a id="264" class="Keyword">import</a> <a id="271" href="1--Type-Theory.1-5--Propositions-as-Types.html" class="Module">1--Type-Theory.1-5--Propositions-as-Types</a>
</pre>-->
<h1 id="lecture-2-1-paths"><a class="header" href="#lecture-2-1-paths">Lecture 2-1: Paths</a></h1>
<p>In Lecture 1-X, we saw that we could define types that represent
equality in another inductive type, like <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> or <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code>. It would
be tedious to have to define equality separately for every type (and
worse, to check that every function preserves equality), and it would
make proving general facts about equality difficult.</p>
<p>To resolve this issue, Cubical Type Theory takes a page from homotopy
theory — the mathematical theory of continuous deformations of
shapes. Classically, a <em>homotopy</em> is a continuous deformation of one
object into another. In homotopy theory, we only care about the
properties of objects which are unchanged by continuous deformation;
so for the purposes of homotopy theory, to give a homotopy between
objects is to say that they are the same, at least for all
homotopy-theoretical purposes. In other words, to a homotopy theorist,
a homotopy is a way to say two things are the same.</p>
<p>We will use this as inspiration for the concept of sameness that will
apply to all types. Let’s see a bit more of the classical theory
first, so we have something to ground our intuitions.</p>
<p>If <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> are two continuous functions between spaces <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> and
<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> (say, subsets of Euclidean space), then a homotopy <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> between <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>
and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> is a function <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> of two variables <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
where <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> for all <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>. The idea is
that <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> continuously transforms the function
<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> into the function <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> as <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6151em;"></span><span class="mord mathnormal">t</span></span></span></span> travels from <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> to <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>.</p>
<!--
<div class="info">

<span class="info-label">Aside:</span>
If you are reading this in your editor, we are using the `$` symbol to
delimit mathematical expressions as opposed to type theoretic ones;
admittedly the difference is not too important.


</div>
-->
<p>As we saw in Lecture 1-1, we can think of a function with two
arguments as a function with one argument that gives back another
function with one argument (via <code class="Agda"><a href="1--Type-Theory.1-1--Types-and-Functions.html#25869" class="Function">×-curry</a></code> and <code class="Agda"><a href="1--Type-Theory.1-1--Types-and-Functions.html#26233" class="Function">×-uncurry</a></code>). In
this case, we can see a homotopy <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span> between <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> as a function
<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span> into the space of continuous functions <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span>,
so that <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span>. In other words, a homotopy is a
<em>path</em> in a function space, where by path we mean a continuous
function out of the unit interval <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>.</p>
<p>In general, if objects <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> are points that live in some space
<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>, then a homotopy between <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span> is a path <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>
with <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> and <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span>.</p>
<div class="info">
<p><span class="info-label">Aside:</span>
Before we begin: The following block lets us refer to some
arbitrary types <code>A</code>, <code>B</code>, … and terms <code>x : A</code>, <code>y : A</code>, … without
cluttering every definition with <code>{A : Type} {B : Type}</code>, and so on.</p>
<pre class="Agda"><a id="2949" class="Keyword">private</a>
  <a id="2959" class="Keyword">variable</a>
    <a id="2972" href="2--Paths-and-Identifications.2-1--Paths.html#2972" class="Generalizable">ℓ</a> <a id="2974" href="2--Paths-and-Identifications.2-1--Paths.html#2974" class="Generalizable">ℓ&#39;</a> <a id="2977" href="2--Paths-and-Identifications.2-1--Paths.html#2977" class="Generalizable">ℓ₂</a> <a id="2980" href="2--Paths-and-Identifications.2-1--Paths.html#2980" class="Generalizable">ℓ₃</a> <a id="2983" class="Symbol">:</a> <a id="2985" href="Library.Primitive.html#1060" class="Postulate">Level</a>
    <a id="2995" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="2997" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a> <a id="2999" href="2--Paths-and-Identifications.2-1--Paths.html#2999" class="Generalizable">C</a> <a id="3001" href="2--Paths-and-Identifications.2-1--Paths.html#3001" class="Generalizable">D</a> <a id="3003" class="Symbol">:</a> <a id="3005" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="3010" href="2--Paths-and-Identifications.2-1--Paths.html#2972" class="Generalizable">ℓ</a>
    <a id="3016" href="2--Paths-and-Identifications.2-1--Paths.html#3016" class="Generalizable">x</a> <a id="3018" href="2--Paths-and-Identifications.2-1--Paths.html#3018" class="Generalizable">y</a> <a id="3020" class="Symbol">:</a> <a id="3022" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a>
</pre>
</div>
<h2 id="paths"><a class="header" href="#paths">Paths</a></h2>
<p>Let’s translate this into type theory. Agda provides a special “type”
<code class="Agda"><a href="Library.Primitive.html#1675" class="Datatype">I</a></code> to act as a version of the unit interval <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>, equipped with
two elements <code>i0 : I</code> and <code>i1 : I</code>, which act as the endpoints <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> and
<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>. A <em>path</em> <code>x ≡ y</code> from <code>x</code> to <code>y</code> of type <code>A</code> will be a function
<code>h : I → A</code> where <code>h i0</code> is identical to <code>x</code> and <code>h i1</code> is identical
to <code>y</code>. Agda remembers the endpoints of a path, so that when we later
evaluate the path at <code>i0</code>, we do get <code>x</code> exactly, and similarly for
<code>i1</code> and <code>y</code>.</p>
<p>Similarly to <code class="Agda"><a href="Library.Primitive.html#1060" class="Postulate">Level</a></code>, the interval <code class="Agda"><a href="Library.Primitive.html#1675" class="Datatype">I</a></code> is not actually a type,
rather, we are just using it as a tool to describe our notion of
sameness. For this reason, it and its endpoints get siloed in their
own special universe.</p>
<pre class="Agda"><a id="3774" href="2--Paths-and-Identifications.2-1--Paths.html#3774" class="Function">_</a> <a id="3776" class="Symbol">:</a> <a id="3778" href="Library.Primitive.html#1629" class="Primitive">IUniv</a>
<a id="3784" class="Symbol">_</a> <a id="3786" class="Symbol">=</a> <a id="3788" href="Library.Primitive.html#1675" class="Datatype">I</a>

<a id="3791" href="2--Paths-and-Identifications.2-1--Paths.html#3791" class="Function">_</a> <a id="3793" class="Symbol">:</a> <a id="3795" href="Library.Primitive.html#1675" class="Datatype">I</a>
<a id="3797" class="Symbol">_</a> <a id="3799" class="Symbol">=</a> <a id="3801" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a>

<a id="3805" href="2--Paths-and-Identifications.2-1--Paths.html#3805" class="Function">_</a> <a id="3807" class="Symbol">:</a> <a id="3809" href="Library.Primitive.html#1675" class="Datatype">I</a>
<a id="3811" class="Symbol">_</a> <a id="3813" class="Symbol">=</a> <a id="3815" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a>
</pre>
<div class="info">
<p><span class="info-label">Aside:</span>
Above we make a “definition” with name <code>_</code>; this signals to Agda to
check the type of what we provide, but then throw away the result. We
will use this to demonstrate the type of some expression without
having to invent a new name for it.</p>
</div>
<p>This prevents us from using all our usual type operations on
<code class="Agda"><a href="Library.Primitive.html#1675" class="Datatype">I</a></code>, which is good, since an element of <code class="Agda"><a href="Library.Primitive.html#1675" class="Datatype">I</a></code> isn’t meant
to be treated as a piece of data.</p>
<pre class="Agda"><a id="4238" class="Comment">-- Uncomment these and try them out, if you want!</a>
<a id="4288" class="Comment">-- _ : Type</a>
<a id="4300" class="Comment">-- _ = I × I  -- error!</a>

<a id="4325" class="Comment">-- _ : Type</a>
<a id="4337" class="Comment">-- _ = Bool → I -- error!</a>
</pre>
<p>However, since we want to discuss paths in any type, there is a
special rule that for any actual type <code>A : Type ℓ</code>, functions <code>I → A</code>
is also an actual type in <code>Type ℓ</code>.</p>
<pre class="Agda"><a id="4543" href="2--Paths-and-Identifications.2-1--Paths.html#4543" class="Function">_</a> <a id="4545" class="Symbol">:</a> <a id="4547" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="4552" href="Library.Primitive.html#1080" class="Primitive">ℓ-zero</a>
<a id="4559" class="Symbol">_</a> <a id="4561" class="Symbol">=</a> <a id="4563" href="Library.Primitive.html#1675" class="Datatype">I</a> <a id="4565" class="Symbol">→</a> <a id="4567" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
</pre>
<p>Now we for paths with specified endpoints. For <code>x</code> and <code>y</code>, Agda
provides a built-in type <code>x ≡ y</code> which is like a function <code>I → A</code>, but
where the endpoints are known to be exactly <code>x</code> and <code>y</code>. That is,
starting with <code>p : x ≡ y</code>, evaluating <code>p i0</code> gives <em>exactly</em> <code>x</code>, and
evaluating <code>p i1</code> gives <em>exactly</em> <code>y</code>, regardless of what the
definition of the path <code>p</code> actually is.</p>
<p>New paths <code>x ≡ y</code> in a type <code>A</code> are defined the same way that
functions are: we assume we have an <code>i : I</code>, and then give an element
of the type <code>A</code>. Agda will make sure that we indeed get <code>x</code> when <code>i</code>
is <code class="Agda"><a href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a></code> and <code>y</code> when <code>i</code> is <code class="Agda"><a href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a></code>.</p>
<p>The simplest path we can write down is the reflexivity path: for any
element <code>x</code>, there is a constant path at <code>x</code>.</p>
<pre class="Agda"><a id="refl"></a><a id="5312" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a> <a id="5317" class="Symbol">:</a> <a id="5319" class="Symbol">{</a><a id="5320" href="2--Paths-and-Identifications.2-1--Paths.html#5320" class="Bound">x</a> <a id="5322" class="Symbol">:</a> <a id="5324" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a><a id="5325" class="Symbol">}</a> <a id="5327" class="Symbol">→</a> <a id="5329" href="2--Paths-and-Identifications.2-1--Paths.html#5320" class="Bound">x</a> <a id="5331" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="5333" href="2--Paths-and-Identifications.2-1--Paths.html#5320" class="Bound">x</a>
<a id="5335" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a> <a id="5340" class="Symbol">{</a><a id="5341" class="Argument">x</a> <a id="5343" class="Symbol">=</a> <a id="5345" href="2--Paths-and-Identifications.2-1--Paths.html#5345" class="Bound">x</a><a id="5346" class="Symbol">}</a> <a id="5348" href="2--Paths-and-Identifications.2-1--Paths.html#5348" class="Bound">i</a> <a id="5350" class="Symbol">=</a> <a id="5352" href="2--Paths-and-Identifications.2-1--Paths.html#5345" class="Bound">x</a>
</pre>
<p>Interpreted as a statement about sameness, this means that <code>x</code> is the
same as <code>x</code> — certainly a good start!</p>
<p>Even with only <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a></code> we are already able to prove some useful
equalities. For example, The type <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> has the structure of a
<em>Boolean algebra</em>, with respect to <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#2824" class="Function">and</a></code> and <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function">or</a></code>. Here are some
of the axioms:</p>
<pre class="Agda"><a id="or-idl"></a><a id="5690" href="2--Paths-and-Identifications.2-1--Paths.html#5690" class="Function">or-idl</a> <a id="5697" class="Symbol">:</a> <a id="5699" class="Symbol">(</a><a id="5700" href="2--Paths-and-Identifications.2-1--Paths.html#5700" class="Bound">x</a> <a id="5702" class="Symbol">:</a> <a id="5704" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="5708" class="Symbol">)</a> <a id="5710" class="Symbol">→</a> <a id="5712" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="5718" href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function Operator">or</a> <a id="5721" href="2--Paths-and-Identifications.2-1--Paths.html#5700" class="Bound">x</a> <a id="5723" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="5725" href="2--Paths-and-Identifications.2-1--Paths.html#5700" class="Bound">x</a>
<a id="5727" href="2--Paths-and-Identifications.2-1--Paths.html#5690" class="Function">or-idl</a> <a id="5734" href="2--Paths-and-Identifications.2-1--Paths.html#5734" class="Bound">x</a> <a id="5736" class="Symbol">=</a> <a id="5738" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a>

<a id="or-idr"></a><a id="5744" href="2--Paths-and-Identifications.2-1--Paths.html#5744" class="Function">or-idr</a> <a id="5751" class="Symbol">:</a> <a id="5753" class="Symbol">(</a><a id="5754" href="2--Paths-and-Identifications.2-1--Paths.html#5754" class="Bound">x</a> <a id="5756" class="Symbol">:</a> <a id="5758" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="5762" class="Symbol">)</a> <a id="5764" class="Symbol">→</a> <a id="5766" href="2--Paths-and-Identifications.2-1--Paths.html#5754" class="Bound">x</a> <a id="5768" href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function Operator">or</a> <a id="5771" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="5777" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="5779" href="2--Paths-and-Identifications.2-1--Paths.html#5754" class="Bound">x</a>
<a id="5781" href="2--Paths-and-Identifications.2-1--Paths.html#5744" class="Function">or-idr</a> <a id="5788" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="5794" class="Symbol">=</a> <a id="5796" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a>
<a id="5801" href="2--Paths-and-Identifications.2-1--Paths.html#5744" class="Function">or-idr</a> <a id="5808" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="5814" class="Symbol">=</a> <a id="5816" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a>

<a id="or-comm"></a><a id="5822" href="2--Paths-and-Identifications.2-1--Paths.html#5822" class="Function">or-comm</a> <a id="5830" class="Symbol">:</a> <a id="5832" class="Symbol">(</a><a id="5833" href="2--Paths-and-Identifications.2-1--Paths.html#5833" class="Bound">x</a> <a id="5835" href="2--Paths-and-Identifications.2-1--Paths.html#5835" class="Bound">y</a> <a id="5837" class="Symbol">:</a> <a id="5839" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="5843" class="Symbol">)</a> <a id="5845" class="Symbol">→</a> <a id="5847" href="2--Paths-and-Identifications.2-1--Paths.html#5833" class="Bound">x</a> <a id="5849" href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function Operator">or</a> <a id="5852" href="2--Paths-and-Identifications.2-1--Paths.html#5835" class="Bound">y</a> <a id="5854" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="5856" href="2--Paths-and-Identifications.2-1--Paths.html#5835" class="Bound">y</a> <a id="5858" href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function Operator">or</a> <a id="5861" href="2--Paths-and-Identifications.2-1--Paths.html#5833" class="Bound">x</a>
<a id="5863" href="2--Paths-and-Identifications.2-1--Paths.html#5822" class="Function">or-comm</a> <a id="5871" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="5877" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="5883" class="Symbol">=</a> <a id="5885" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a>
<a id="5890" href="2--Paths-and-Identifications.2-1--Paths.html#5822" class="Function">or-comm</a> <a id="5898" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="5904" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="5910" class="Symbol">=</a> <a id="5912" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a>
<a id="5917" href="2--Paths-and-Identifications.2-1--Paths.html#5822" class="Function">or-comm</a> <a id="5925" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="5931" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="5937" class="Symbol">=</a> <a id="5939" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a>
<a id="5944" href="2--Paths-and-Identifications.2-1--Paths.html#5822" class="Function">or-comm</a> <a id="5952" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="5958" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>  <a id="5964" class="Symbol">=</a> <a id="5966" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a>

<a id="or-LEM"></a><a id="5972" href="2--Paths-and-Identifications.2-1--Paths.html#5972" class="Function">or-LEM</a> <a id="5979" class="Symbol">:</a> <a id="5981" class="Symbol">(</a><a id="5982" href="2--Paths-and-Identifications.2-1--Paths.html#5982" class="Bound">x</a> <a id="5984" class="Symbol">:</a> <a id="5986" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="5990" class="Symbol">)</a> <a id="5992" class="Symbol">→</a> <a id="5994" href="2--Paths-and-Identifications.2-1--Paths.html#5982" class="Bound">x</a> <a id="5996" href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function Operator">or</a> <a id="5999" class="Symbol">(</a><a id="6000" href="1--Type-Theory.1-2--Inductive-Types.html#1637" class="Function">not</a> <a id="6004" href="2--Paths-and-Identifications.2-1--Paths.html#5982" class="Bound">x</a><a id="6005" class="Symbol">)</a> <a id="6007" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="6009" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a>
<a id="6014" class="Comment">-- Exercise:</a>
<a id="6027" class="Comment">-- or-LEM x = {!!}</a>

<a id="or-assoc"></a><a id="6140" href="2--Paths-and-Identifications.2-1--Paths.html#6140" class="Function">or-assoc</a> <a id="6149" class="Symbol">:</a> <a id="6151" class="Symbol">(</a><a id="6152" href="2--Paths-and-Identifications.2-1--Paths.html#6152" class="Bound">x</a> <a id="6154" href="2--Paths-and-Identifications.2-1--Paths.html#6154" class="Bound">y</a> <a id="6156" href="2--Paths-and-Identifications.2-1--Paths.html#6156" class="Bound">z</a> <a id="6158" class="Symbol">:</a> <a id="6160" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="6164" class="Symbol">)</a> <a id="6166" class="Symbol">→</a> <a id="6168" href="2--Paths-and-Identifications.2-1--Paths.html#6152" class="Bound">x</a> <a id="6170" href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function Operator">or</a> <a id="6173" class="Symbol">(</a><a id="6174" href="2--Paths-and-Identifications.2-1--Paths.html#6154" class="Bound">y</a> <a id="6176" href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function Operator">or</a> <a id="6179" href="2--Paths-and-Identifications.2-1--Paths.html#6156" class="Bound">z</a><a id="6180" class="Symbol">)</a> <a id="6182" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="6184" class="Symbol">(</a><a id="6185" href="2--Paths-and-Identifications.2-1--Paths.html#6152" class="Bound">x</a> <a id="6187" href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function Operator">or</a> <a id="6190" href="2--Paths-and-Identifications.2-1--Paths.html#6154" class="Bound">y</a><a id="6191" class="Symbol">)</a> <a id="6193" href="1--Type-Theory.1-2--Inductive-Types.html#4051" class="Function Operator">or</a> <a id="6196" href="2--Paths-and-Identifications.2-1--Paths.html#6156" class="Bound">z</a>
<a id="6198" class="Comment">-- Exercise:</a>
<a id="6211" class="Comment">-- or-assoc x y z = {!!}</a>
</pre>
<p>OK, that’s enough of that — it’s straightforward to keep going.</p>
<div class="info">
<p><span class="info-label">Aside:</span>
You can find all the laws for a Boolean algebra listed on Wikipedia,
or you can peek ahead to Lecture 2-X and take all the laws for a De Morgan
algebra (but where <code>∧ = and</code> and <code>∨ = or</code> and <code>~ = not</code>) together with
the “Law of Excluded Middle”: <code>b or (not b)</code>.</p>
</div>
<div class="info">
<p><span class="info-label">Aside:</span>
The <code>≡</code> constructor has low precedence, so <code>x or y ≡ y or x</code> means
<code>(x or y) ≡ (y or x)</code>, and not something weird like <code>x or (y ≡ y) or x</code>.</p>
</div>
<p>A type of paths is a type like any other, so we can define functions
that accept paths as arguments and produce paths as results. It is
easy to show that any function sends equal inputs to equal outputs.</p>
<pre class="Agda"><a id="apⁿ"></a><a id="7056" href="2--Paths-and-Identifications.2-1--Paths.html#7056" class="Function">apⁿ</a> <a id="7060" class="Symbol">:</a> <a id="7062" class="Symbol">(</a><a id="7063" href="2--Paths-and-Identifications.2-1--Paths.html#7063" class="Bound">f</a> <a id="7065" class="Symbol">:</a> <a id="7067" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="7069" class="Symbol">→</a> <a id="7071" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="7072" class="Symbol">)</a>
  <a id="7076" class="Symbol">→</a> <a id="7078" href="2--Paths-and-Identifications.2-1--Paths.html#3016" class="Generalizable">x</a> <a id="7080" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="7082" href="2--Paths-and-Identifications.2-1--Paths.html#3018" class="Generalizable">y</a>
  <a id="7086" class="Symbol">→</a> <a id="7088" href="2--Paths-and-Identifications.2-1--Paths.html#7063" class="Bound">f</a> <a id="7090" href="2--Paths-and-Identifications.2-1--Paths.html#3016" class="Generalizable">x</a> <a id="7092" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="7094" href="2--Paths-and-Identifications.2-1--Paths.html#7063" class="Bound">f</a> <a id="7096" href="2--Paths-and-Identifications.2-1--Paths.html#3018" class="Generalizable">y</a>
<a id="7098" href="2--Paths-and-Identifications.2-1--Paths.html#7056" class="Function">apⁿ</a> <a id="7102" href="2--Paths-and-Identifications.2-1--Paths.html#7102" class="Bound">f</a> <a id="7104" href="2--Paths-and-Identifications.2-1--Paths.html#7104" class="Bound">p</a> <a id="7106" href="2--Paths-and-Identifications.2-1--Paths.html#7106" class="Bound">i</a> <a id="7108" class="Symbol">=</a> <a id="7110" href="2--Paths-and-Identifications.2-1--Paths.html#7102" class="Bound">f</a> <a id="7112" class="Symbol">(</a><a id="7113" href="2--Paths-and-Identifications.2-1--Paths.html#7104" class="Bound">p</a> <a id="7115" href="2--Paths-and-Identifications.2-1--Paths.html#7106" class="Bound">i</a><a id="7116" class="Symbol">)</a>
</pre>
<p>Here, we are composing the function <code>f</code> with the “function” <code>x ≡ y</code>.
When we plug in <code>i = i0</code>, we get that the left endpoint is <code>f (p i0)</code>,
which is <code>f x</code>, and when we plug in <code>i = i1</code>, we similarly get the
right endpoint as <code>f (p i1)</code>, i.e. <code>f y</code>. So indeed, this defines a
path <code>f x ≡ f y</code>.</p>
<pre class="Agda"><a id="apⁿ-bin"></a><a id="7421" href="2--Paths-and-Identifications.2-1--Paths.html#7421" class="Function">apⁿ-bin</a> <a id="7429" class="Symbol">:</a> <a id="7431" class="Symbol">(</a><a id="7432" href="2--Paths-and-Identifications.2-1--Paths.html#7432" class="Bound">f</a> <a id="7434" class="Symbol">:</a> <a id="7436" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="7438" class="Symbol">→</a> <a id="7440" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a> <a id="7442" class="Symbol">→</a> <a id="7444" href="2--Paths-and-Identifications.2-1--Paths.html#2999" class="Generalizable">C</a><a id="7445" class="Symbol">)</a> <a id="7447" class="Symbol">{</a><a id="7448" href="2--Paths-and-Identifications.2-1--Paths.html#7448" class="Bound">a</a> <a id="7450" href="2--Paths-and-Identifications.2-1--Paths.html#7450" class="Bound">a&#39;</a> <a id="7453" class="Symbol">:</a> <a id="7455" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a><a id="7456" class="Symbol">}</a> <a id="7458" class="Symbol">{</a><a id="7459" href="2--Paths-and-Identifications.2-1--Paths.html#7459" class="Bound">b</a> <a id="7461" href="2--Paths-and-Identifications.2-1--Paths.html#7461" class="Bound">b&#39;</a> <a id="7464" class="Symbol">:</a> <a id="7466" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="7467" class="Symbol">}</a>
  <a id="7471" class="Symbol">→</a> <a id="7473" href="2--Paths-and-Identifications.2-1--Paths.html#7448" class="Bound">a</a> <a id="7475" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="7477" href="2--Paths-and-Identifications.2-1--Paths.html#7450" class="Bound">a&#39;</a>
  <a id="7482" class="Symbol">→</a> <a id="7484" href="2--Paths-and-Identifications.2-1--Paths.html#7459" class="Bound">b</a> <a id="7486" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="7488" href="2--Paths-and-Identifications.2-1--Paths.html#7461" class="Bound">b&#39;</a>
  <a id="7493" class="Symbol">→</a> <a id="7495" href="2--Paths-and-Identifications.2-1--Paths.html#7432" class="Bound">f</a> <a id="7497" href="2--Paths-and-Identifications.2-1--Paths.html#7448" class="Bound">a</a> <a id="7499" href="2--Paths-and-Identifications.2-1--Paths.html#7459" class="Bound">b</a> <a id="7501" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="7503" href="2--Paths-and-Identifications.2-1--Paths.html#7432" class="Bound">f</a> <a id="7505" href="2--Paths-and-Identifications.2-1--Paths.html#7450" class="Bound">a&#39;</a> <a id="7508" href="2--Paths-and-Identifications.2-1--Paths.html#7461" class="Bound">b&#39;</a>
<a id="7511" class="Comment">-- Exercise:</a>
<a id="7524" class="Comment">-- apⁿ-bin f p q = {!!}</a>

<a id="apⁿ-∘"></a><a id="7608" href="2--Paths-and-Identifications.2-1--Paths.html#7608" class="Function">apⁿ-∘</a> <a id="7614" class="Symbol">:</a> <a id="7616" class="Symbol">(</a><a id="7617" href="2--Paths-and-Identifications.2-1--Paths.html#7617" class="Bound">f</a> <a id="7619" class="Symbol">:</a> <a id="7621" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="7623" class="Symbol">→</a> <a id="7625" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="7626" class="Symbol">)</a> <a id="7628" class="Symbol">(</a><a id="7629" href="2--Paths-and-Identifications.2-1--Paths.html#7629" class="Bound">g</a> <a id="7631" class="Symbol">:</a> <a id="7633" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a> <a id="7635" class="Symbol">→</a> <a id="7637" href="2--Paths-and-Identifications.2-1--Paths.html#2999" class="Generalizable">C</a><a id="7638" class="Symbol">)</a>
  <a id="7642" class="Symbol">→</a> <a id="7644" class="Symbol">(</a><a id="7645" href="2--Paths-and-Identifications.2-1--Paths.html#7645" class="Bound">p</a> <a id="7647" class="Symbol">:</a> <a id="7649" href="2--Paths-and-Identifications.2-1--Paths.html#3016" class="Generalizable">x</a> <a id="7651" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="7653" href="2--Paths-and-Identifications.2-1--Paths.html#3018" class="Generalizable">y</a><a id="7654" class="Symbol">)</a>
  <a id="7658" class="Symbol">→</a> <a id="7660" href="2--Paths-and-Identifications.2-1--Paths.html#7056" class="Function">apⁿ</a> <a id="7664" class="Symbol">(</a><a id="7665" href="2--Paths-and-Identifications.2-1--Paths.html#7629" class="Bound">g</a> <a id="7667" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#3978" class="Function Operator">∘</a> <a id="7669" href="2--Paths-and-Identifications.2-1--Paths.html#7617" class="Bound">f</a><a id="7670" class="Symbol">)</a> <a id="7672" href="2--Paths-and-Identifications.2-1--Paths.html#7645" class="Bound">p</a> <a id="7674" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="7676" href="2--Paths-and-Identifications.2-1--Paths.html#7056" class="Function">apⁿ</a> <a id="7680" href="2--Paths-and-Identifications.2-1--Paths.html#7629" class="Bound">g</a> <a id="7682" class="Symbol">(</a><a id="7683" href="2--Paths-and-Identifications.2-1--Paths.html#7056" class="Function">apⁿ</a> <a id="7687" href="2--Paths-and-Identifications.2-1--Paths.html#7617" class="Bound">f</a> <a id="7689" href="2--Paths-and-Identifications.2-1--Paths.html#7645" class="Bound">p</a><a id="7690" class="Symbol">)</a>
<a id="7692" class="Comment">-- Exercise:</a>
<a id="7705" class="Comment">-- apⁿ-∘ f g p = {!!}</a>
</pre>
<p><code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#7056" class="Function">apⁿ</a></code> is simple but useful. For example, we can re-prove some of the
properties of addition (<code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#18885" class="Function">+ℕ-≡ℕ-idl</a></code>, <code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#19011" class="Function">+ℕ-≡ℕ-idr</a></code>, <code class="Agda"><a href="1--Type-Theory.1-5--Propositions-as-Types.html#19192" class="Function">+ℕ-≡ℕ-assoc</a></code>)
using our new notion of equality. In each recursive step, you will
have to use <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#7056" class="Function">apⁿ</a></code> to convert a path <code>n ≡ m</code> to a path <code>suc n ≡ suc m</code>. (We didn’t have to do that previously, because <code>suc n ≡ℕ suc m</code>
was <em>defined</em> to be <code>n ≡ℕ m</code>. Win some lose some!)</p>
<pre class="Agda"><a id="+ℕ-idl"></a><a id="8180" href="2--Paths-and-Identifications.2-1--Paths.html#8180" class="Function">+ℕ-idl</a> <a id="8187" class="Symbol">:</a> <a id="8189" class="Symbol">(</a><a id="8190" href="2--Paths-and-Identifications.2-1--Paths.html#8190" class="Bound">n</a> <a id="8192" class="Symbol">:</a> <a id="8194" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="8195" class="Symbol">)</a> <a id="8197" class="Symbol">→</a> <a id="8199" class="Symbol">(</a><a id="8200" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="8205" href="1--Type-Theory.1-2--Inductive-Types.html#12858" class="Function Operator">+ℕ</a> <a id="8208" href="2--Paths-and-Identifications.2-1--Paths.html#8190" class="Bound">n</a><a id="8209" class="Symbol">)</a> <a id="8211" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="8213" href="2--Paths-and-Identifications.2-1--Paths.html#8190" class="Bound">n</a>
<a id="8215" class="Comment">-- Exercise:</a>
<a id="8228" class="Comment">-- +ℕ-idl n = {!!}</a>

<a id="+ℕ-idr"></a><a id="8291" href="2--Paths-and-Identifications.2-1--Paths.html#8291" class="Function">+ℕ-idr</a> <a id="8298" class="Symbol">:</a> <a id="8300" class="Symbol">(</a><a id="8301" href="2--Paths-and-Identifications.2-1--Paths.html#8301" class="Bound">n</a> <a id="8303" class="Symbol">:</a> <a id="8305" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="8306" class="Symbol">)</a> <a id="8308" class="Symbol">→</a> <a id="8310" class="Symbol">(</a><a id="8311" href="2--Paths-and-Identifications.2-1--Paths.html#8301" class="Bound">n</a> <a id="8313" href="1--Type-Theory.1-2--Inductive-Types.html#12858" class="Function Operator">+ℕ</a> <a id="8316" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="8320" class="Symbol">)</a> <a id="8322" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="8324" href="2--Paths-and-Identifications.2-1--Paths.html#8301" class="Bound">n</a>
<a id="8326" class="Comment">-- Exercise:</a>
<a id="8339" class="Comment">-- +ℕ-idr n = {!!}</a>

<a id="+ℕ-assoc"></a><a id="8468" href="2--Paths-and-Identifications.2-1--Paths.html#8468" class="Function">+ℕ-assoc</a> <a id="8477" class="Symbol">:</a> <a id="8479" class="Symbol">(</a><a id="8480" href="2--Paths-and-Identifications.2-1--Paths.html#8480" class="Bound">n</a> <a id="8482" href="2--Paths-and-Identifications.2-1--Paths.html#8482" class="Bound">m</a> <a id="8484" href="2--Paths-and-Identifications.2-1--Paths.html#8484" class="Bound">k</a> <a id="8486" class="Symbol">:</a> <a id="8488" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="8489" class="Symbol">)</a> <a id="8491" class="Symbol">→</a> <a id="8493" class="Symbol">(</a><a id="8494" href="2--Paths-and-Identifications.2-1--Paths.html#8480" class="Bound">n</a> <a id="8496" href="1--Type-Theory.1-2--Inductive-Types.html#12858" class="Function Operator">+ℕ</a> <a id="8499" class="Symbol">(</a><a id="8500" href="2--Paths-and-Identifications.2-1--Paths.html#8482" class="Bound">m</a> <a id="8502" href="1--Type-Theory.1-2--Inductive-Types.html#12858" class="Function Operator">+ℕ</a> <a id="8505" href="2--Paths-and-Identifications.2-1--Paths.html#8484" class="Bound">k</a><a id="8506" class="Symbol">))</a> <a id="8509" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="8511" class="Symbol">((</a><a id="8513" href="2--Paths-and-Identifications.2-1--Paths.html#8480" class="Bound">n</a> <a id="8515" href="1--Type-Theory.1-2--Inductive-Types.html#12858" class="Function Operator">+ℕ</a> <a id="8518" href="2--Paths-and-Identifications.2-1--Paths.html#8482" class="Bound">m</a><a id="8519" class="Symbol">)</a> <a id="8521" href="1--Type-Theory.1-2--Inductive-Types.html#12858" class="Function Operator">+ℕ</a> <a id="8524" href="2--Paths-and-Identifications.2-1--Paths.html#8484" class="Bound">k</a><a id="8525" class="Symbol">)</a>
<a id="8527" class="Comment">-- Exercise:</a>
<a id="8540" class="Comment">-- +ℕ-assoc n m k = {!!}</a>
</pre>
<p>Another use is to show that the constructors for inductive types are
injective. If the same constructor is used on both endpoints of a
path, we can peel that constructor off.</p>
<pre class="Agda"><a id="suc-inj"></a><a id="8877" href="2--Paths-and-Identifications.2-1--Paths.html#8877" class="Function">suc-inj</a> <a id="8885" class="Symbol">:</a> <a id="8887" class="Symbol">{</a><a id="8888" href="2--Paths-and-Identifications.2-1--Paths.html#8888" class="Bound">x</a> <a id="8890" href="2--Paths-and-Identifications.2-1--Paths.html#8890" class="Bound">y</a> <a id="8892" class="Symbol">:</a> <a id="8894" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="8895" class="Symbol">}</a> <a id="8897" class="Symbol">→</a> <a id="8899" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="8903" href="2--Paths-and-Identifications.2-1--Paths.html#8888" class="Bound">x</a> <a id="8905" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="8907" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="8911" href="2--Paths-and-Identifications.2-1--Paths.html#8890" class="Bound">y</a> <a id="8913" class="Symbol">→</a> <a id="8915" href="2--Paths-and-Identifications.2-1--Paths.html#8888" class="Bound">x</a> <a id="8917" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="8919" href="2--Paths-and-Identifications.2-1--Paths.html#8890" class="Bound">y</a>
<a id="8921" class="Comment">-- Exercise: (Hint: use <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#14898" class="Function">predℕ</a></code>!)</a>
<a id="8957" class="Comment">-- suc-inj p = {!!}</a>

<a id="inl-inj"></a><a id="9029" href="2--Paths-and-Identifications.2-1--Paths.html#9029" class="Function">inl-inj</a> <a id="9037" class="Symbol">:</a> <a id="9039" class="Symbol">{</a><a id="9040" href="2--Paths-and-Identifications.2-1--Paths.html#9040" class="Bound">x</a> <a id="9042" href="2--Paths-and-Identifications.2-1--Paths.html#9042" class="Bound">y</a> <a id="9044" class="Symbol">:</a> <a id="9046" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a><a id="9047" class="Symbol">}</a> <a id="9049" class="Symbol">→</a> <a id="9051" href="Library.Prelude.html#1916" class="Function">Path</a> <a id="9056" class="Symbol">(</a><a id="9057" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="9059" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="9061" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="9062" class="Symbol">)</a> <a id="9064" class="Symbol">(</a><a id="9065" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8339" class="InductiveConstructor">inl</a> <a id="9069" href="2--Paths-and-Identifications.2-1--Paths.html#9040" class="Bound">x</a><a id="9070" class="Symbol">)</a> <a id="9072" class="Symbol">(</a><a id="9073" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8339" class="InductiveConstructor">inl</a> <a id="9077" href="2--Paths-and-Identifications.2-1--Paths.html#9042" class="Bound">y</a><a id="9078" class="Symbol">)</a> <a id="9080" class="Symbol">→</a> <a id="9082" href="2--Paths-and-Identifications.2-1--Paths.html#9040" class="Bound">x</a> <a id="9084" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="9086" href="2--Paths-and-Identifications.2-1--Paths.html#9042" class="Bound">y</a>
<a id="9088" href="2--Paths-and-Identifications.2-1--Paths.html#9029" class="Function">inl-inj</a> <a id="9096" class="Symbol">{</a><a id="9097" class="Argument">A</a> <a id="9099" class="Symbol">=</a> <a id="9101" href="2--Paths-and-Identifications.2-1--Paths.html#9101" class="Bound">A</a><a id="9102" class="Symbol">}</a> <a id="9104" class="Symbol">{</a><a id="9105" class="Argument">x</a> <a id="9107" class="Symbol">=</a> <a id="9109" href="2--Paths-and-Identifications.2-1--Paths.html#9109" class="Bound">x</a><a id="9110" class="Symbol">}</a> <a id="9112" href="2--Paths-and-Identifications.2-1--Paths.html#9112" class="Bound">p</a> <a id="9114" class="Symbol">=</a> <a id="9116" href="2--Paths-and-Identifications.2-1--Paths.html#7056" class="Function">apⁿ</a> <a id="9120" href="2--Paths-and-Identifications.2-1--Paths.html#9140" class="Function">uninl</a> <a id="9126" href="2--Paths-and-Identifications.2-1--Paths.html#9112" class="Bound">p</a>
  <a id="9130" class="Keyword">where</a>
    <a id="9140" href="2--Paths-and-Identifications.2-1--Paths.html#9140" class="Function">uninl</a> <a id="9146" class="Symbol">:</a> <a id="9148" href="2--Paths-and-Identifications.2-1--Paths.html#9101" class="Bound">A</a> <a id="9150" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="9152" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a> <a id="9154" class="Symbol">→</a> <a id="9156" href="2--Paths-and-Identifications.2-1--Paths.html#9101" class="Bound">A</a>
    <a id="9162" href="2--Paths-and-Identifications.2-1--Paths.html#9140" class="Function">uninl</a> <a id="9168" class="Symbol">(</a><a id="9169" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8339" class="InductiveConstructor">inl</a> <a id="9173" href="2--Paths-and-Identifications.2-1--Paths.html#9173" class="Bound">a</a><a id="9174" class="Symbol">)</a> <a id="9176" class="Symbol">=</a> <a id="9178" href="2--Paths-and-Identifications.2-1--Paths.html#9173" class="Bound">a</a>
    <a id="9184" href="2--Paths-and-Identifications.2-1--Paths.html#9140" class="Function">uninl</a> <a id="9190" class="Symbol">(</a><a id="9191" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8357" class="InductiveConstructor">inr</a> <a id="9195" class="Symbol">_)</a> <a id="9198" class="Symbol">=</a> <a id="9200" href="2--Paths-and-Identifications.2-1--Paths.html#9109" class="Bound">x</a>

<a id="inr-inj"></a><a id="9203" href="2--Paths-and-Identifications.2-1--Paths.html#9203" class="Function">inr-inj</a> <a id="9211" class="Symbol">:</a> <a id="9213" class="Symbol">{</a><a id="9214" href="2--Paths-and-Identifications.2-1--Paths.html#9214" class="Bound">x</a> <a id="9216" href="2--Paths-and-Identifications.2-1--Paths.html#9216" class="Bound">y</a> <a id="9218" class="Symbol">:</a> <a id="9220" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="9221" class="Symbol">}</a> <a id="9223" class="Symbol">→</a> <a id="9225" href="Library.Prelude.html#1916" class="Function">Path</a> <a id="9230" class="Symbol">(</a><a id="9231" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="9233" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="9235" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="9236" class="Symbol">)</a> <a id="9238" class="Symbol">(</a><a id="9239" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8357" class="InductiveConstructor">inr</a> <a id="9243" href="2--Paths-and-Identifications.2-1--Paths.html#9214" class="Bound">x</a><a id="9244" class="Symbol">)</a> <a id="9246" class="Symbol">(</a><a id="9247" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8357" class="InductiveConstructor">inr</a> <a id="9251" href="2--Paths-and-Identifications.2-1--Paths.html#9216" class="Bound">y</a><a id="9252" class="Symbol">)</a> <a id="9254" class="Symbol">→</a> <a id="9256" href="2--Paths-and-Identifications.2-1--Paths.html#9214" class="Bound">x</a> <a id="9258" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="9260" href="2--Paths-and-Identifications.2-1--Paths.html#9216" class="Bound">y</a>
<a id="9262" class="Comment">-- Exercise:</a>
<a id="9275" class="Comment">-- inr-inj {B = B} {x = x} p = {!!}</a>
</pre>
<p>Here we use the alternative name <code class="Agda"><a href="Library.Prelude.html#1916" class="Function">Path</a></code> to construct the type of
paths rather than <code class="Agda"><a href="Library.Prelude.html#2004" class="Function">≡</a></code> so that we can specify the type that the path
exists in. If we just write <code>inl x ≡ inl y</code> then Agda can see that the
left side of <code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype">⊎</a></code> has to be <code>A</code> because <code>x : A</code> and <code>y : A</code>, but it
has no way of knowing that the right side should be <code>B</code>!</p>
<h2 id="inductive-types-with-path-constructors"><a class="header" href="#inductive-types-with-path-constructors">Inductive Types with Path Constructors</a></h2>
<p>How can we get our hands on some more interesting paths? One way is to
define inductive types that have path constructors. (These are often
called “Higher Inductive Types” or HITs.)</p>
<p>Our first use of a path constructor is a more symmetrical version of
the integers. Remember that the definition of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a></code> we gave back in
Lecture 1-X is a little janky — we have to treat the negative
integers and the positive integers asymmetrically, assigning <code class="Agda"><a href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a></code>
to the <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#19056" class="InductiveConstructor">pos</a></code> side and shifting the <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#19073" class="InductiveConstructor">negsuc</a></code> side down by one. Now
that we have paths, we can define a symmetric version of the integers
as two copies of the the natural numbers, one for the positive
integers and one for the negative — as long as we add in a
path between “positive 0” and “negative 0” to make them the same!</p>
<pre class="Agda"><a id="10733" class="Keyword">data</a> <a id="ℤˢ"></a><a id="10738" href="2--Paths-and-Identifications.2-1--Paths.html#10738" class="Datatype">ℤˢ</a> <a id="10741" class="Symbol">:</a> <a id="10743" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="10748" class="Keyword">where</a>
  <a id="ℤˢ.posˢ"></a><a id="10756" href="2--Paths-and-Identifications.2-1--Paths.html#10756" class="InductiveConstructor">posˢ</a> <a id="10761" class="Symbol">:</a> <a id="10763" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="10765" class="Symbol">→</a> <a id="10767" href="2--Paths-and-Identifications.2-1--Paths.html#10738" class="Datatype">ℤˢ</a>
  <a id="ℤˢ.negˢ"></a><a id="10772" href="2--Paths-and-Identifications.2-1--Paths.html#10772" class="InductiveConstructor">negˢ</a> <a id="10777" class="Symbol">:</a> <a id="10779" href="Library.Prelude.html#3629" class="Datatype">ℕ</a> <a id="10781" class="Symbol">→</a> <a id="10783" href="2--Paths-and-Identifications.2-1--Paths.html#10738" class="Datatype">ℤˢ</a>
  <a id="ℤˢ.zeroˢ≡"></a><a id="10788" href="2--Paths-and-Identifications.2-1--Paths.html#10788" class="InductiveConstructor">zeroˢ≡</a> <a id="10795" class="Symbol">:</a> <a id="10797" href="2--Paths-and-Identifications.2-1--Paths.html#10756" class="InductiveConstructor">posˢ</a> <a id="10802" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a> <a id="10807" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="10809" href="2--Paths-and-Identifications.2-1--Paths.html#10772" class="InductiveConstructor">negˢ</a> <a id="10814" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>
</pre>
<p>Arithmetic using these integers is easier to reason about than the
version involving <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#19073" class="InductiveConstructor">negsuc</a></code>. First, here’s the successor function,
which you should compare to <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#20120" class="Function">sucℤ</a></code>.</p>
<pre class="Agda"><a id="sucℤˢ"></a><a id="11002" href="2--Paths-and-Identifications.2-1--Paths.html#11002" class="Function">sucℤˢ</a> <a id="11008" class="Symbol">:</a> <a id="11010" href="2--Paths-and-Identifications.2-1--Paths.html#10738" class="Datatype">ℤˢ</a> <a id="11013" class="Symbol">→</a> <a id="11015" href="2--Paths-and-Identifications.2-1--Paths.html#10738" class="Datatype">ℤˢ</a>
<a id="11018" href="2--Paths-and-Identifications.2-1--Paths.html#11002" class="Function">sucℤˢ</a> <a id="11024" class="Symbol">(</a><a id="11025" href="2--Paths-and-Identifications.2-1--Paths.html#10756" class="InductiveConstructor">posˢ</a> <a id="11030" href="2--Paths-and-Identifications.2-1--Paths.html#11030" class="Bound">x</a><a id="11031" class="Symbol">)</a> <a id="11033" class="Symbol">=</a> <a id="11035" href="2--Paths-and-Identifications.2-1--Paths.html#10756" class="InductiveConstructor">posˢ</a> <a id="11040" class="Symbol">(</a><a id="11041" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="11045" href="2--Paths-and-Identifications.2-1--Paths.html#11030" class="Bound">x</a><a id="11046" class="Symbol">)</a>
<a id="11048" href="2--Paths-and-Identifications.2-1--Paths.html#11002" class="Function">sucℤˢ</a> <a id="11054" class="Symbol">(</a><a id="11055" href="2--Paths-and-Identifications.2-1--Paths.html#10772" class="InductiveConstructor">negˢ</a> <a id="11060" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="11064" class="Symbol">)</a> <a id="11066" class="Symbol">=</a> <a id="11068" href="2--Paths-and-Identifications.2-1--Paths.html#10756" class="InductiveConstructor">posˢ</a> <a id="11073" class="Symbol">(</a><a id="11074" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="11078" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="11082" class="Symbol">)</a>
<a id="11084" href="2--Paths-and-Identifications.2-1--Paths.html#11002" class="Function">sucℤˢ</a> <a id="11090" class="Symbol">(</a><a id="11091" href="2--Paths-and-Identifications.2-1--Paths.html#10772" class="InductiveConstructor">negˢ</a> <a id="11096" class="Symbol">(</a><a id="11097" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="11101" href="2--Paths-and-Identifications.2-1--Paths.html#11101" class="Bound">x</a><a id="11102" class="Symbol">))</a> <a id="11105" class="Symbol">=</a> <a id="11107" href="2--Paths-and-Identifications.2-1--Paths.html#10772" class="InductiveConstructor">negˢ</a> <a id="11112" href="2--Paths-and-Identifications.2-1--Paths.html#11101" class="Bound">x</a>
<a id="11114" href="2--Paths-and-Identifications.2-1--Paths.html#11002" class="Function">sucℤˢ</a> <a id="11120" class="Symbol">(</a><a id="11121" href="2--Paths-and-Identifications.2-1--Paths.html#10788" class="InductiveConstructor">zeroˢ≡</a> <a id="11128" href="2--Paths-and-Identifications.2-1--Paths.html#11128" class="Bound">i</a><a id="11129" class="Symbol">)</a> <a id="11131" class="Symbol">=</a> <a id="11133" href="2--Paths-and-Identifications.2-1--Paths.html#10756" class="InductiveConstructor">posˢ</a> <a id="11138" class="Symbol">(</a><a id="11139" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="11143" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="11147" class="Symbol">)</a>
</pre>
<p>On positive integers, we use the ordinary successor of the enclosed
natural number. On negative integers, we check if the natural number
is zero, and if so, give back positive one, and use the enclosed
predecessor otherwise.</p>
<p>Notice that we have defined what the function does on zero twice! Once
as <code>posˢ zero</code>, and again as <code>negˢ zero</code>. The final case for the path
constructor <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#10788" class="InductiveConstructor">zeroˢ≡</a></code> forces us to demonstrate that we give the same
answer both times. And indeed we do, so that final case can be defined
by the constant path at <code>posˢ (suc zero)</code>.</p>
<p>It is easy to convert between these integers and the original ones.</p>
<pre class="Agda"><a id="ℤˢ→ℤ"></a><a id="11779" href="2--Paths-and-Identifications.2-1--Paths.html#11779" class="Function">ℤˢ→ℤ</a> <a id="11784" class="Symbol">:</a> <a id="11786" href="2--Paths-and-Identifications.2-1--Paths.html#10738" class="Datatype">ℤˢ</a> <a id="11789" class="Symbol">→</a> <a id="11791" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a>
<a id="11793" class="Comment">-- Exercise:</a>
<a id="11806" class="Comment">-- ℤˢ→ℤ z = {!!}</a>

<a id="ℤ→ℤˢ"></a><a id="12040" href="2--Paths-and-Identifications.2-1--Paths.html#12040" class="Function">ℤ→ℤˢ</a> <a id="12045" class="Symbol">:</a> <a id="12047" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a> <a id="12049" class="Symbol">→</a> <a id="12051" href="2--Paths-and-Identifications.2-1--Paths.html#10738" class="Datatype">ℤˢ</a>
<a id="12054" class="Comment">-- Exercise:</a>
<a id="12067" class="Comment">-- ℤ→ℤˢ z = {!!}</a>
</pre>
<p>Complete the definition of addition.</p>
<pre class="Agda"><a id="predℤˢ"></a><a id="12238" href="2--Paths-and-Identifications.2-1--Paths.html#12238" class="Function">predℤˢ</a> <a id="12245" class="Symbol">:</a> <a id="12247" href="2--Paths-and-Identifications.2-1--Paths.html#10738" class="Datatype">ℤˢ</a> <a id="12250" class="Symbol">→</a> <a id="12252" href="2--Paths-and-Identifications.2-1--Paths.html#10738" class="Datatype">ℤˢ</a>
<a id="12255" class="Comment">-- Exercise:</a>
<a id="12268" class="Comment">-- predℤˢ z = {!!}</a>

<a id="_+ℤˢ_"></a><a id="12531" href="2--Paths-and-Identifications.2-1--Paths.html#12531" class="Function Operator">_+ℤˢ_</a> <a id="12537" class="Symbol">:</a> <a id="12539" href="2--Paths-and-Identifications.2-1--Paths.html#10738" class="Datatype">ℤˢ</a> <a id="12542" class="Symbol">→</a> <a id="12544" href="2--Paths-and-Identifications.2-1--Paths.html#10738" class="Datatype">ℤˢ</a> <a id="12547" class="Symbol">→</a> <a id="12549" href="2--Paths-and-Identifications.2-1--Paths.html#10738" class="Datatype">ℤˢ</a>
<a id="12552" class="Comment">-- Exercise:</a>
<a id="12565" class="Comment">-- m +ℤˢ n = {!!}</a>
</pre>
<p>The simplest non-trivial type involving a path constructor is the
<em>circle</em> <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a></code>, so named because it contains a point <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a></code> and a
path <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a></code> which goes from <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a></code> to <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a></code>, forming a circle.</p>
<pre class="Agda"><a id="13077" class="Keyword">data</a> <a id="S¹"></a><a id="13082" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a> <a id="13085" class="Symbol">:</a> <a id="13087" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="13092" class="Keyword">where</a>
  <a id="S¹.base"></a><a id="13100" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a> <a id="13105" class="Symbol">:</a> <a id="13107" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a>
  <a id="S¹.loop"></a><a id="13112" href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a> <a id="13117" class="Symbol">:</a> <a id="13119" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a> <a id="13124" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="13126" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a>
</pre>
<p>There’s not a huge amount we can do with <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a></code> without technology
from later lectures, but we can at least describe its recursion
principle. The recursion principle for the circle states that to
produce a function <code>S¹ → A</code> for any type <code>A</code>, we need to specify a
point <code>a : A</code>, and a loop <code>l : a ≡ a</code> starting and ending at that
point. In other words, to produce a function <code>S¹ → A</code>, we just need to
draw a circle in the type <code>A</code>.</p>
<pre class="Agda"><a id="S¹-rec"></a><a id="13572" href="2--Paths-and-Identifications.2-1--Paths.html#13572" class="Function">S¹-rec</a> <a id="13579" class="Symbol">:</a> <a id="13581" class="Symbol">{</a><a id="13582" href="2--Paths-and-Identifications.2-1--Paths.html#13582" class="Bound">A</a> <a id="13584" class="Symbol">:</a> <a id="13586" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="13591" href="2--Paths-and-Identifications.2-1--Paths.html#2972" class="Generalizable">ℓ</a><a id="13592" class="Symbol">}</a>
  <a id="13596" class="Symbol">→</a> <a id="13598" class="Symbol">(</a><a id="13599" href="2--Paths-and-Identifications.2-1--Paths.html#13599" class="Bound">a</a> <a id="13601" class="Symbol">:</a> <a id="13603" href="2--Paths-and-Identifications.2-1--Paths.html#13582" class="Bound">A</a><a id="13604" class="Symbol">)</a>
  <a id="13608" class="Symbol">→</a> <a id="13610" href="2--Paths-and-Identifications.2-1--Paths.html#13599" class="Bound">a</a> <a id="13612" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="13614" href="2--Paths-and-Identifications.2-1--Paths.html#13599" class="Bound">a</a>
  <a id="13618" class="Symbol">→</a> <a id="13620" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a> <a id="13623" class="Symbol">→</a> <a id="13625" href="2--Paths-and-Identifications.2-1--Paths.html#13582" class="Bound">A</a>
<a id="13627" href="2--Paths-and-Identifications.2-1--Paths.html#13572" class="Function">S¹-rec</a> <a id="13634" href="2--Paths-and-Identifications.2-1--Paths.html#13634" class="Bound">a</a> <a id="13636" href="2--Paths-and-Identifications.2-1--Paths.html#13636" class="Bound">l</a> <a id="13638" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a> <a id="13643" class="Symbol">=</a> <a id="13645" href="2--Paths-and-Identifications.2-1--Paths.html#13634" class="Bound">a</a>
<a id="13647" href="2--Paths-and-Identifications.2-1--Paths.html#13572" class="Function">S¹-rec</a> <a id="13654" href="2--Paths-and-Identifications.2-1--Paths.html#13654" class="Bound">a</a> <a id="13656" href="2--Paths-and-Identifications.2-1--Paths.html#13656" class="Bound">l</a> <a id="13658" class="Symbol">(</a><a id="13659" href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a> <a id="13664" href="2--Paths-and-Identifications.2-1--Paths.html#13664" class="Bound">i</a><a id="13665" class="Symbol">)</a> <a id="13667" class="Symbol">=</a> <a id="13669" href="2--Paths-and-Identifications.2-1--Paths.html#13656" class="Bound">l</a> <a id="13671" href="2--Paths-and-Identifications.2-1--Paths.html#13664" class="Bound">i</a>
</pre>
<p>You may be able to guess that this forms part of a universal mapping
property. Not only can we build a function <code>S¹ → A</code> out of a point and
a loop in <code>A</code>, but we can go back.</p>
<pre class="Agda"><a id="S¹-ump-fro"></a><a id="13858" href="2--Paths-and-Identifications.2-1--Paths.html#13858" class="Function">S¹-ump-fro</a> <a id="13869" class="Symbol">:</a> <a id="13871" class="Symbol">{</a><a id="13872" href="2--Paths-and-Identifications.2-1--Paths.html#13872" class="Bound">A</a> <a id="13874" class="Symbol">:</a> <a id="13876" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="13881" href="2--Paths-and-Identifications.2-1--Paths.html#2972" class="Generalizable">ℓ</a><a id="13882" class="Symbol">}</a>
  <a id="13886" class="Symbol">→</a> <a id="13888" class="Symbol">(</a><a id="13889" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a> <a id="13892" class="Symbol">→</a> <a id="13894" href="2--Paths-and-Identifications.2-1--Paths.html#13872" class="Bound">A</a><a id="13895" class="Symbol">)</a>
  <a id="13899" class="Symbol">→</a> <a id="13901" href="Library.Prelude.html#1429" class="Function">Σ[</a> <a id="13904" href="2--Paths-and-Identifications.2-1--Paths.html#13904" class="Bound">a</a> <a id="13906" href="Library.Prelude.html#1429" class="Function">∈</a> <a id="13908" href="2--Paths-and-Identifications.2-1--Paths.html#13872" class="Bound">A</a> <a id="13910" href="Library.Prelude.html#1429" class="Function">]</a> <a id="13912" href="2--Paths-and-Identifications.2-1--Paths.html#13904" class="Bound">a</a> <a id="13914" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="13916" href="2--Paths-and-Identifications.2-1--Paths.html#13904" class="Bound">a</a>
<a id="13918" class="Comment">-- Exercise:</a>
<a id="13931" class="Comment">-- S¹-ump-fro f = {!!}</a>
</pre>
<h2 id="paths-in-pair-and-function-types"><a class="header" href="#paths-in-pair-and-function-types">Paths in Pair and Function Types</a></h2>
<p>Now we can ask what paths look like in various types. Inductive data
types (like <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code>) will be covered in detail in Lecture 2-X. Let’s
begin with something easier: what is a path in a pair type? It’s a
pair of paths.</p>
<p>To prove these, remember that any path in <code>A</code> is secretly a function
<code>I → A</code> so, ignoring the endpoints, the first exercise is asking for a
function <code>(I → A) × (I → B) → (I → A × B)</code>. It should be easy to come
up with such a function, and it turns out that this obvious definition
has the correct endpoints.</p>
<pre class="Agda"><a id="×≡→≡×"></a><a id="14604" href="2--Paths-and-Identifications.2-1--Paths.html#14604" class="Function">×≡→≡×</a> <a id="14610" class="Symbol">:</a> <a id="14612" class="Symbol">{</a><a id="14613" href="2--Paths-and-Identifications.2-1--Paths.html#14613" class="Bound">x</a> <a id="14615" href="2--Paths-and-Identifications.2-1--Paths.html#14615" class="Bound">y</a> <a id="14617" class="Symbol">:</a> <a id="14619" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="14621" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="14623" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="14624" class="Symbol">}</a> <a id="14626" class="Symbol">→</a> <a id="14628" class="Symbol">(</a><a id="14629" href="2--Paths-and-Identifications.2-1--Paths.html#14613" class="Bound">x</a> <a id="14631" class="Symbol">.</a><a id="14632" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="14636" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="14638" href="2--Paths-and-Identifications.2-1--Paths.html#14615" class="Bound">y</a> <a id="14640" class="Symbol">.</a><a id="14641" href="Library.Prelude.html#1106" class="Field">fst</a><a id="14644" class="Symbol">)</a> <a id="14646" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="14648" class="Symbol">(</a><a id="14649" href="2--Paths-and-Identifications.2-1--Paths.html#14613" class="Bound">x</a> <a id="14651" class="Symbol">.</a><a id="14652" href="Library.Prelude.html#1118" class="Field">snd</a> <a id="14656" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="14658" href="2--Paths-and-Identifications.2-1--Paths.html#14615" class="Bound">y</a> <a id="14660" class="Symbol">.</a><a id="14661" href="Library.Prelude.html#1118" class="Field">snd</a><a id="14664" class="Symbol">)</a> <a id="14666" class="Symbol">→</a> <a id="14668" href="2--Paths-and-Identifications.2-1--Paths.html#14613" class="Bound">x</a> <a id="14670" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="14672" href="2--Paths-and-Identifications.2-1--Paths.html#14615" class="Bound">y</a>
<a id="14674" class="Comment">-- Exercise:</a>
<a id="14687" class="Comment">-- ×≡→≡× p = {!!}</a>

<a id="≡×→×≡"></a><a id="14812" href="2--Paths-and-Identifications.2-1--Paths.html#14812" class="Function">≡×→×≡</a> <a id="14818" class="Symbol">:</a> <a id="14820" class="Symbol">{</a><a id="14821" href="2--Paths-and-Identifications.2-1--Paths.html#14821" class="Bound">x</a> <a id="14823" href="2--Paths-and-Identifications.2-1--Paths.html#14823" class="Bound">y</a> <a id="14825" class="Symbol">:</a> <a id="14827" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="14829" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="14831" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="14832" class="Symbol">}</a> <a id="14834" class="Symbol">→</a> <a id="14836" href="2--Paths-and-Identifications.2-1--Paths.html#14821" class="Bound">x</a> <a id="14838" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="14840" href="2--Paths-and-Identifications.2-1--Paths.html#14823" class="Bound">y</a> <a id="14842" class="Symbol">→</a> <a id="14844" class="Symbol">(</a><a id="14845" href="2--Paths-and-Identifications.2-1--Paths.html#14821" class="Bound">x</a> <a id="14847" class="Symbol">.</a><a id="14848" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="14852" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="14854" href="2--Paths-and-Identifications.2-1--Paths.html#14823" class="Bound">y</a> <a id="14856" class="Symbol">.</a><a id="14857" href="Library.Prelude.html#1106" class="Field">fst</a><a id="14860" class="Symbol">)</a> <a id="14862" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="14864" class="Symbol">(</a><a id="14865" href="2--Paths-and-Identifications.2-1--Paths.html#14821" class="Bound">x</a> <a id="14867" class="Symbol">.</a><a id="14868" href="Library.Prelude.html#1118" class="Field">snd</a> <a id="14872" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="14874" href="2--Paths-and-Identifications.2-1--Paths.html#14823" class="Bound">y</a> <a id="14876" class="Symbol">.</a><a id="14877" href="Library.Prelude.html#1118" class="Field">snd</a><a id="14880" class="Symbol">)</a>
<a id="14882" class="Comment">-- Exercise:</a>
<a id="14895" class="Comment">-- ≡×→×≡ p = {!!}</a>
</pre>
<p>Similarly, what is a path in a function type? It is a function landing
in paths! This is the principle of “function extensionality”: to say
that <code>f</code> is the same as <code>g</code> means that, for all <code>x</code>, <code>f x</code> is the same
as <code>g x</code>.</p>
<p>mvrnote: relate back to homotopy discussion</p>
<pre class="Agda"><a id="funextˢ"></a><a id="15295" href="2--Paths-and-Identifications.2-1--Paths.html#15295" class="Function">funextˢ</a> <a id="15303" class="Symbol">:</a> <a id="15305" class="Symbol">{</a><a id="15306" href="2--Paths-and-Identifications.2-1--Paths.html#15306" class="Bound">f</a> <a id="15308" href="2--Paths-and-Identifications.2-1--Paths.html#15308" class="Bound">g</a> <a id="15310" class="Symbol">:</a> <a id="15312" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="15314" class="Symbol">→</a> <a id="15316" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="15317" class="Symbol">}</a>
  <a id="15321" class="Symbol">→</a> <a id="15323" class="Symbol">((</a><a id="15325" href="2--Paths-and-Identifications.2-1--Paths.html#15325" class="Bound">x</a> <a id="15327" class="Symbol">:</a> <a id="15329" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a><a id="15330" class="Symbol">)</a> <a id="15332" class="Symbol">→</a> <a id="15334" href="2--Paths-and-Identifications.2-1--Paths.html#15306" class="Bound">f</a> <a id="15336" href="2--Paths-and-Identifications.2-1--Paths.html#15325" class="Bound">x</a> <a id="15338" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="15340" href="2--Paths-and-Identifications.2-1--Paths.html#15308" class="Bound">g</a> <a id="15342" href="2--Paths-and-Identifications.2-1--Paths.html#15325" class="Bound">x</a><a id="15343" class="Symbol">)</a>
  <a id="15347" class="Symbol">→</a> <a id="15349" href="2--Paths-and-Identifications.2-1--Paths.html#15306" class="Bound">f</a> <a id="15351" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="15353" href="2--Paths-and-Identifications.2-1--Paths.html#15308" class="Bound">g</a>
<a id="15355" class="Comment">-- Exercise:</a>
<a id="15368" class="Comment">-- funextˢ f = {!!}</a>

<a id="funextˢ⁻"></a><a id="15438" href="2--Paths-and-Identifications.2-1--Paths.html#15438" class="Function">funextˢ⁻</a> <a id="15447" class="Symbol">:</a> <a id="15449" class="Symbol">{</a><a id="15450" href="2--Paths-and-Identifications.2-1--Paths.html#15450" class="Bound">f</a> <a id="15452" href="2--Paths-and-Identifications.2-1--Paths.html#15452" class="Bound">g</a> <a id="15454" class="Symbol">:</a> <a id="15456" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="15458" class="Symbol">→</a> <a id="15460" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="15461" class="Symbol">}</a>
  <a id="15465" class="Symbol">→</a> <a id="15467" href="2--Paths-and-Identifications.2-1--Paths.html#15450" class="Bound">f</a> <a id="15469" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="15471" href="2--Paths-and-Identifications.2-1--Paths.html#15452" class="Bound">g</a>
  <a id="15475" class="Symbol">→</a> <a id="15477" class="Symbol">((</a><a id="15479" href="2--Paths-and-Identifications.2-1--Paths.html#15479" class="Bound">x</a> <a id="15481" class="Symbol">:</a> <a id="15483" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a><a id="15484" class="Symbol">)</a> <a id="15486" class="Symbol">→</a> <a id="15488" href="2--Paths-and-Identifications.2-1--Paths.html#15450" class="Bound">f</a> <a id="15490" href="2--Paths-and-Identifications.2-1--Paths.html#15479" class="Bound">x</a> <a id="15492" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="15494" href="2--Paths-and-Identifications.2-1--Paths.html#15452" class="Bound">g</a> <a id="15496" href="2--Paths-and-Identifications.2-1--Paths.html#15479" class="Bound">x</a><a id="15497" class="Symbol">)</a>
<a id="15499" class="Comment">-- Exercise:</a>
<a id="15512" class="Comment">-- funextˢ⁻ p = {!!}</a>
</pre>
<p>This works for functions with any number of arguments:</p>
<pre class="Agda"><a id="funext2"></a><a id="15648" href="2--Paths-and-Identifications.2-1--Paths.html#15648" class="Function">funext2</a> <a id="15656" class="Symbol">:</a> <a id="15658" class="Symbol">{</a><a id="15659" href="2--Paths-and-Identifications.2-1--Paths.html#15659" class="Bound">f</a> <a id="15661" href="2--Paths-and-Identifications.2-1--Paths.html#15661" class="Bound">g</a> <a id="15663" class="Symbol">:</a> <a id="15665" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="15667" class="Symbol">→</a> <a id="15669" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a> <a id="15671" class="Symbol">→</a> <a id="15673" href="2--Paths-and-Identifications.2-1--Paths.html#2999" class="Generalizable">C</a><a id="15674" class="Symbol">}</a>
       <a id="15683" class="Symbol">(</a><a id="15684" href="2--Paths-and-Identifications.2-1--Paths.html#15684" class="Bound">p</a> <a id="15686" class="Symbol">:</a> <a id="15688" class="Symbol">(</a><a id="15689" href="2--Paths-and-Identifications.2-1--Paths.html#15689" class="Bound">x</a> <a id="15691" class="Symbol">:</a> <a id="15693" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a><a id="15694" class="Symbol">)</a> <a id="15696" class="Symbol">(</a><a id="15697" href="2--Paths-and-Identifications.2-1--Paths.html#15697" class="Bound">y</a> <a id="15699" class="Symbol">:</a> <a id="15701" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="15702" class="Symbol">)</a> <a id="15704" class="Symbol">→</a> <a id="15706" href="2--Paths-and-Identifications.2-1--Paths.html#15659" class="Bound">f</a> <a id="15708" href="2--Paths-and-Identifications.2-1--Paths.html#15689" class="Bound">x</a> <a id="15710" href="2--Paths-and-Identifications.2-1--Paths.html#15697" class="Bound">y</a> <a id="15712" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="15714" href="2--Paths-and-Identifications.2-1--Paths.html#15661" class="Bound">g</a> <a id="15716" href="2--Paths-and-Identifications.2-1--Paths.html#15689" class="Bound">x</a> <a id="15718" href="2--Paths-and-Identifications.2-1--Paths.html#15697" class="Bound">y</a><a id="15719" class="Symbol">)</a>
       <a id="15728" class="Symbol">→</a> <a id="15730" href="2--Paths-and-Identifications.2-1--Paths.html#15659" class="Bound">f</a> <a id="15732" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="15734" href="2--Paths-and-Identifications.2-1--Paths.html#15661" class="Bound">g</a>
<a id="15736" class="Comment">-- Exercise:</a>
<a id="15749" class="Comment">-- funext2 p i x y = {!!}</a>
</pre>
<p>Try using <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#21464" class="Function">funext</a></code> to prove some unsurprising facts about function
composition:</p>
<pre class="Agda"><a id="∘-assoc"></a><a id="15920" href="2--Paths-and-Identifications.2-1--Paths.html#15920" class="Function">∘-assoc</a> <a id="15928" class="Symbol">:</a> <a id="15930" class="Symbol">(</a><a id="15931" href="2--Paths-and-Identifications.2-1--Paths.html#15931" class="Bound">h</a> <a id="15933" class="Symbol">:</a> <a id="15935" href="2--Paths-and-Identifications.2-1--Paths.html#2999" class="Generalizable">C</a> <a id="15937" class="Symbol">→</a> <a id="15939" href="2--Paths-and-Identifications.2-1--Paths.html#3001" class="Generalizable">D</a><a id="15940" class="Symbol">)</a>
        <a id="15950" class="Symbol">→</a> <a id="15952" class="Symbol">(</a><a id="15953" href="2--Paths-and-Identifications.2-1--Paths.html#15953" class="Bound">g</a> <a id="15955" class="Symbol">:</a> <a id="15957" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a> <a id="15959" class="Symbol">→</a> <a id="15961" href="2--Paths-and-Identifications.2-1--Paths.html#2999" class="Generalizable">C</a><a id="15962" class="Symbol">)</a>
        <a id="15972" class="Symbol">→</a> <a id="15974" class="Symbol">(</a><a id="15975" href="2--Paths-and-Identifications.2-1--Paths.html#15975" class="Bound">f</a> <a id="15977" class="Symbol">:</a> <a id="15979" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="15981" class="Symbol">→</a> <a id="15983" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="15984" class="Symbol">)</a>
        <a id="15994" class="Symbol">→</a> <a id="15996" class="Symbol">(</a><a id="15997" href="2--Paths-and-Identifications.2-1--Paths.html#15931" class="Bound">h</a> <a id="15999" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#3978" class="Function Operator">∘</a> <a id="16001" href="2--Paths-and-Identifications.2-1--Paths.html#15953" class="Bound">g</a><a id="16002" class="Symbol">)</a> <a id="16004" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#3978" class="Function Operator">∘</a> <a id="16006" href="2--Paths-and-Identifications.2-1--Paths.html#15975" class="Bound">f</a> <a id="16008" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="16010" href="2--Paths-and-Identifications.2-1--Paths.html#15931" class="Bound">h</a> <a id="16012" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#3978" class="Function Operator">∘</a> <a id="16014" class="Symbol">(</a><a id="16015" href="2--Paths-and-Identifications.2-1--Paths.html#15953" class="Bound">g</a> <a id="16017" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#3978" class="Function Operator">∘</a> <a id="16019" href="2--Paths-and-Identifications.2-1--Paths.html#15975" class="Bound">f</a><a id="16020" class="Symbol">)</a>
<a id="16022" class="Comment">-- Exercise:</a>
<a id="16035" class="Comment">-- ∘-assoc h g f = {!!}</a>

<a id="∘-idl"></a><a id="16122" href="2--Paths-and-Identifications.2-1--Paths.html#16122" class="Function">∘-idl</a> <a id="16128" class="Symbol">:</a> <a id="16130" class="Symbol">(</a><a id="16131" href="2--Paths-and-Identifications.2-1--Paths.html#16131" class="Bound">f</a> <a id="16133" class="Symbol">:</a> <a id="16135" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="16137" class="Symbol">→</a> <a id="16139" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="16140" class="Symbol">)</a> <a id="16142" class="Symbol">→</a> <a id="16144" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#2180" class="Function">idfun</a> <a id="16150" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#3978" class="Function Operator">∘</a> <a id="16152" href="2--Paths-and-Identifications.2-1--Paths.html#16131" class="Bound">f</a> <a id="16154" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="16156" href="2--Paths-and-Identifications.2-1--Paths.html#16131" class="Bound">f</a>
<a id="16158" class="Comment">-- Exercise:</a>
<a id="16171" class="Comment">-- ∘-idl f = {!!}</a>

<a id="∘-idr"></a><a id="16246" href="2--Paths-and-Identifications.2-1--Paths.html#16246" class="Function">∘-idr</a> <a id="16252" class="Symbol">:</a> <a id="16254" class="Symbol">(</a><a id="16255" href="2--Paths-and-Identifications.2-1--Paths.html#16255" class="Bound">f</a> <a id="16257" class="Symbol">:</a> <a id="16259" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="16261" class="Symbol">→</a> <a id="16263" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="16264" class="Symbol">)</a> <a id="16266" class="Symbol">→</a> <a id="16268" href="2--Paths-and-Identifications.2-1--Paths.html#16255" class="Bound">f</a> <a id="16270" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#3978" class="Function Operator">∘</a> <a id="16272" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#2180" class="Function">idfun</a> <a id="16278" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="16280" href="2--Paths-and-Identifications.2-1--Paths.html#16255" class="Bound">f</a>
<a id="16282" class="Comment">-- Exercise:</a>
<a id="16295" class="Comment">-- ∘-idr f i x = {!!}</a>
</pre>
<h2 id="paths-over-paths"><a class="header" href="#paths-over-paths">Paths over Paths</a></h2>
<p>A path in a type <code>A</code> is a function <code>p : I → A</code> with fixed endpoints <code>x : A</code> and <code>y : A</code>. But what if <code>A</code> is itself a path of types <code>A : I → Type</code>? Then we consider dependent functions <code>p : (i : I) → A i</code> with
fixed endpoints <code>x : A i0</code> and <code>y : A i</code>; these are called “paths over
the path <code>A</code>”, or sometimes simply “path-overs”. The name for this in
Agda is <code class="Agda"><a href="Library.Primitive.html#2174" class="Postulate">PathP</a></code>, for “Path (over) P(ath)”. This is another built-in
notion, like <code class="Agda"><a href="Library.Prelude.html#2004" class="Function">≡</a></code>.</p>
<pre class="Agda"><a id="16845" href="2--Paths-and-Identifications.2-1--Paths.html#16845" class="Function">_</a> <a id="16847" class="Symbol">:</a> <a id="16849" class="Symbol">(</a><a id="16850" href="2--Paths-and-Identifications.2-1--Paths.html#16850" class="Bound">A</a> <a id="16852" class="Symbol">:</a> <a id="16854" href="Library.Primitive.html#1675" class="Datatype">I</a> <a id="16856" class="Symbol">→</a> <a id="16858" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="16862" class="Symbol">)</a> <a id="16864" class="Symbol">(</a><a id="16865" href="2--Paths-and-Identifications.2-1--Paths.html#16865" class="Bound">x</a> <a id="16867" class="Symbol">:</a> <a id="16869" href="2--Paths-and-Identifications.2-1--Paths.html#16850" class="Bound">A</a> <a id="16871" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="16873" class="Symbol">)</a> <a id="16875" class="Symbol">(</a><a id="16876" href="2--Paths-and-Identifications.2-1--Paths.html#16876" class="Bound">y</a> <a id="16878" class="Symbol">:</a> <a id="16880" href="2--Paths-and-Identifications.2-1--Paths.html#16850" class="Bound">A</a> <a id="16882" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="16884" class="Symbol">)</a> <a id="16886" class="Symbol">→</a> <a id="16888" href="Library.Primitive.html#422" class="Primitive">Type</a>
<a id="16893" class="Symbol">_</a> <a id="16895" class="Symbol">=</a> <a id="16897" href="Library.Primitive.html#2174" class="Postulate">PathP</a>
</pre>
<p>Similarly to paths, if we have <code>p : PathP A x y</code>, then <code>p i0</code> is <code>x</code> and
<code>p i1</code> is <code>y</code> always, regardless of the actual definition of <code>p</code>.</p>
<p>In fact, the type <code>x ≡ y</code> is defined in terms of <code class="Agda"><a href="Library.Primitive.html#2174" class="Postulate">PathP</a></code>, where the
path of types happens to the constant path at the type <code>A</code>. This is
just like non-dependent functions <code>A → B</code> are exactly dependent
functions <code>(x : A) → B</code>, where <code>B</code> happens to be a constant type and
not depend on <code>x</code>.</p>
<pre class="Agda"><a id="≡-again"></a><a id="17343" href="2--Paths-and-Identifications.2-1--Paths.html#17343" class="Function">≡-again</a> <a id="17351" class="Symbol">:</a> <a id="17353" class="Symbol">(</a><a id="17354" href="2--Paths-and-Identifications.2-1--Paths.html#17354" class="Bound">A</a> <a id="17356" class="Symbol">:</a> <a id="17358" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="17362" class="Symbol">)</a> <a id="17364" class="Symbol">(</a><a id="17365" href="2--Paths-and-Identifications.2-1--Paths.html#17365" class="Bound">x</a> <a id="17367" class="Symbol">:</a> <a id="17369" href="2--Paths-and-Identifications.2-1--Paths.html#17354" class="Bound">A</a><a id="17370" class="Symbol">)</a> <a id="17372" class="Symbol">(</a><a id="17373" href="2--Paths-and-Identifications.2-1--Paths.html#17373" class="Bound">y</a> <a id="17375" class="Symbol">:</a> <a id="17377" href="2--Paths-and-Identifications.2-1--Paths.html#17354" class="Bound">A</a><a id="17378" class="Symbol">)</a> <a id="17380" class="Symbol">→</a> <a id="17382" href="Library.Primitive.html#422" class="Primitive">Type</a>
<a id="17387" class="Comment">-- Exercise: (easy)</a>
<a id="17407" class="Comment">-- ≡-again A x y = {!!}</a>
</pre>
<p>We can upgrade <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#7056" class="Function">apⁿ</a></code> to apply to dependent functions:</p>
<pre class="Agda"><a id="17560" class="Comment">-- Exercise:</a>
<a id="17573" class="Comment">-- ap : {B : A → Type ℓ₂} </a>
<a id="17600" class="Comment">--   → {x y : A}</a>
<a id="17617" class="Comment">--   → (f : (a : A) → B a)</a>
<a id="17644" class="Comment">--   → (p : x ≡ y)</a>
<a id="17663" class="Comment">--   → PathP {!!} {!!} {!!}</a>

<a id="17943" href="2--Paths-and-Identifications.2-1--Paths.html#17691" class="Function">ap</a> <a id="17946" href="2--Paths-and-Identifications.2-1--Paths.html#17946" class="Bound">f</a> <a id="17948" href="2--Paths-and-Identifications.2-1--Paths.html#17948" class="Bound">p</a> <a id="17950" href="2--Paths-and-Identifications.2-1--Paths.html#17950" class="Bound">i</a> <a id="17952" class="Symbol">=</a> <a id="17954" href="2--Paths-and-Identifications.2-1--Paths.html#17946" class="Bound">f</a> <a id="17956" class="Symbol">(</a><a id="17957" href="2--Paths-and-Identifications.2-1--Paths.html#17948" class="Bound">p</a> <a id="17959" href="2--Paths-and-Identifications.2-1--Paths.html#17950" class="Bound">i</a><a id="17960" class="Symbol">)</a>

<a id="17963" class="Comment">-- Exercise:</a>
<a id="17976" class="Comment">-- ap-bin :</a>
<a id="17988" class="Comment">--   {B : A → Type ℓ₂}</a>
<a id="18011" class="Comment">--   {C : (x : A) → B x → Type ℓ₃}</a>
<a id="18046" class="Comment">--   (f : (x : A) → (y : B x) → C x y)</a>
<a id="18085" class="Comment">--   {a a&#39; : A} {b : B a} {b&#39; : B a&#39;}</a>
<a id="18123" class="Comment">--   → (p : a ≡ a&#39;)</a>
<a id="18143" class="Comment">--   → (q : PathP {!!} {!!} {!!})</a>
<a id="18177" class="Comment">--   → PathP {!!} {!!} {!!}</a>

<a id="18661" href="2--Paths-and-Identifications.2-1--Paths.html#18205" class="Function">ap-bin</a> <a id="18668" href="2--Paths-and-Identifications.2-1--Paths.html#18668" class="Bound">f</a> <a id="18670" href="2--Paths-and-Identifications.2-1--Paths.html#18670" class="Bound">p</a> <a id="18672" href="2--Paths-and-Identifications.2-1--Paths.html#18672" class="Bound">q</a> <a id="18674" href="2--Paths-and-Identifications.2-1--Paths.html#18674" class="Bound">i</a> <a id="18676" class="Symbol">=</a> <a id="18678" href="2--Paths-and-Identifications.2-1--Paths.html#18668" class="Bound">f</a> <a id="18680" class="Symbol">(</a><a id="18681" href="2--Paths-and-Identifications.2-1--Paths.html#18670" class="Bound">p</a> <a id="18683" href="2--Paths-and-Identifications.2-1--Paths.html#18674" class="Bound">i</a><a id="18684" class="Symbol">)</a> <a id="18686" class="Symbol">(</a><a id="18687" href="2--Paths-and-Identifications.2-1--Paths.html#18672" class="Bound">q</a> <a id="18689" href="2--Paths-and-Identifications.2-1--Paths.html#18674" class="Bound">i</a><a id="18690" class="Symbol">)</a>
</pre>
<p>Let’s return to paths in pair types, but look at <em>dependent</em> pairs.
There are actually two places dependency could show up here. The first
is the obvious one, when <code>B</code> depends on <code>A</code>. The definitions are the
same as in the non-dependent case, so try to fill in the parameters to
the <code class="Agda"><a href="Library.Primitive.html#2174" class="Postulate">PathP</a></code> type.</p>
<div class="info">
<p><span class="info-label">Aside:</span>
Here we are going to use an “anonymous module”, to collect the
parameters <code>A</code>, <code>B</code>, <code>x</code> and <code>y</code> that are identical between the two
exercises <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#19380" class="Function">ΣPathP→PathPΣ’</a></code> and <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#19715" class="Function">PathPΣ→ΣPathP’</a></code>.</p>
</div>
<pre class="Agda"><a id="19201" class="Keyword">module</a> <a id="19208" href="2--Paths-and-Identifications.2-1--Paths.html#19208" class="Module">_</a> <a id="19210" class="Symbol">{</a><a id="19211" href="2--Paths-and-Identifications.2-1--Paths.html#19211" class="Bound">A</a> <a id="19213" class="Symbol">:</a> <a id="19215" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="19220" href="2--Paths-and-Identifications.2-1--Paths.html#2972" class="Generalizable">ℓ</a><a id="19221" class="Symbol">}</a> <a id="19223" class="Symbol">{</a><a id="19224" href="2--Paths-and-Identifications.2-1--Paths.html#19224" class="Bound">B</a> <a id="19226" class="Symbol">:</a> <a id="19228" href="2--Paths-and-Identifications.2-1--Paths.html#19211" class="Bound">A</a> <a id="19230" class="Symbol">→</a> <a id="19232" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="19237" href="2--Paths-and-Identifications.2-1--Paths.html#2977" class="Generalizable">ℓ₂</a><a id="19239" class="Symbol">}</a>
  <a id="19243" class="Symbol">{</a><a id="19244" href="2--Paths-and-Identifications.2-1--Paths.html#19244" class="Bound">x</a> <a id="19246" href="2--Paths-and-Identifications.2-1--Paths.html#19246" class="Bound">y</a> <a id="19248" class="Symbol">:</a> <a id="19250" href="Library.Prelude.html#1429" class="Function">Σ[</a> <a id="19253" href="2--Paths-and-Identifications.2-1--Paths.html#19253" class="Bound">a</a> <a id="19255" href="Library.Prelude.html#1429" class="Function">∈</a> <a id="19257" href="2--Paths-and-Identifications.2-1--Paths.html#19211" class="Bound">A</a> <a id="19259" href="Library.Prelude.html#1429" class="Function">]</a> <a id="19261" href="2--Paths-and-Identifications.2-1--Paths.html#19224" class="Bound">B</a> <a id="19263" href="2--Paths-and-Identifications.2-1--Paths.html#19253" class="Bound">a</a><a id="19264" class="Symbol">}</a>
  <a id="19268" class="Keyword">where</a>

  <a id="19277" class="Comment">-- Exercise:</a>
  <a id="19292" class="Comment">-- ΣPathP→PathPΣ&#39; : Σ[ p ∈ (fst x ≡ fst y) ] PathP {!!} {!!} {!!}</a>
  <a id="19360" class="Comment">--        → x ≡ y</a>

  <a id="19533" href="2--Paths-and-Identifications.2-1--Paths.html#19380" class="Function">ΣPathP→PathPΣ&#39;</a> <a id="19548" href="2--Paths-and-Identifications.2-1--Paths.html#19548" class="Bound">eq</a> <a id="19551" href="2--Paths-and-Identifications.2-1--Paths.html#19551" class="Bound">i</a> <a id="19553" class="Symbol">.</a><a id="19554" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="19558" class="Symbol">=</a> <a id="19560" href="2--Paths-and-Identifications.2-1--Paths.html#19548" class="Bound">eq</a> <a id="19563" class="Symbol">.</a><a id="19564" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="19568" href="2--Paths-and-Identifications.2-1--Paths.html#19551" class="Bound">i</a>
  <a id="19572" href="2--Paths-and-Identifications.2-1--Paths.html#19380" class="Function">ΣPathP→PathPΣ&#39;</a> <a id="19587" href="2--Paths-and-Identifications.2-1--Paths.html#19587" class="Bound">eq</a> <a id="19590" href="2--Paths-and-Identifications.2-1--Paths.html#19590" class="Bound">i</a> <a id="19592" class="Symbol">.</a><a id="19593" href="Library.Prelude.html#1118" class="Field">snd</a> <a id="19597" class="Symbol">=</a> <a id="19599" href="2--Paths-and-Identifications.2-1--Paths.html#19587" class="Bound">eq</a> <a id="19602" class="Symbol">.</a><a id="19603" href="Library.Prelude.html#1118" class="Field">snd</a> <a id="19607" href="2--Paths-and-Identifications.2-1--Paths.html#19590" class="Bound">i</a>

  <a id="19612" class="Comment">-- Exercise:</a>
  <a id="19627" class="Comment">-- PathPΣ→ΣPathP&#39; : x ≡ y</a>
  <a id="19655" class="Comment">--        → Σ[ p ∈ (fst x ≡ fst y) ] PathP {!!} {!!} {!!}</a>

  <a id="19868" href="2--Paths-and-Identifications.2-1--Paths.html#19715" class="Function">PathPΣ→ΣPathP&#39;</a> <a id="19883" href="2--Paths-and-Identifications.2-1--Paths.html#19883" class="Bound">eq</a> <a id="19886" class="Symbol">.</a><a id="19887" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="19891" href="2--Paths-and-Identifications.2-1--Paths.html#19891" class="Bound">i</a> <a id="19893" class="Symbol">=</a> <a id="19895" href="2--Paths-and-Identifications.2-1--Paths.html#19883" class="Bound">eq</a> <a id="19898" href="2--Paths-and-Identifications.2-1--Paths.html#19891" class="Bound">i</a> <a id="19900" class="Symbol">.</a><a id="19901" href="Library.Prelude.html#1106" class="Field">fst</a>
  <a id="19907" href="2--Paths-and-Identifications.2-1--Paths.html#19715" class="Function">PathPΣ→ΣPathP&#39;</a> <a id="19922" href="2--Paths-and-Identifications.2-1--Paths.html#19922" class="Bound">eq</a> <a id="19925" class="Symbol">.</a><a id="19926" href="Library.Prelude.html#1118" class="Field">snd</a> <a id="19930" href="2--Paths-and-Identifications.2-1--Paths.html#19930" class="Bound">i</a> <a id="19932" class="Symbol">=</a> <a id="19934" href="2--Paths-and-Identifications.2-1--Paths.html#19922" class="Bound">eq</a> <a id="19937" href="2--Paths-and-Identifications.2-1--Paths.html#19930" class="Bound">i</a> <a id="19939" class="Symbol">.</a><a id="19940" href="Library.Prelude.html#1118" class="Field">snd</a>
</pre>
<p>There is a second possible notion of dependency: it could be that the
types <code>A</code> and <code>B</code> themselves are paths of types, that is, they depend
on an element of <code class="Agda"><a href="Library.Primitive.html#1675" class="Datatype">I</a></code>. Again, the actual definitions are
identical; but their types become more powerful.</p>
<pre class="Agda"><a id="20201" class="Keyword">module</a> <a id="20208" href="2--Paths-and-Identifications.2-1--Paths.html#20208" class="Module">_</a> <a id="20210" class="Symbol">{</a><a id="20211" href="2--Paths-and-Identifications.2-1--Paths.html#20211" class="Bound">A</a> <a id="20213" class="Symbol">:</a> <a id="20215" href="Library.Primitive.html#1675" class="Datatype">I</a> <a id="20217" class="Symbol">→</a> <a id="20219" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="20224" href="2--Paths-and-Identifications.2-1--Paths.html#2972" class="Generalizable">ℓ</a><a id="20225" class="Symbol">}</a> <a id="20227" class="Symbol">{</a><a id="20228" href="2--Paths-and-Identifications.2-1--Paths.html#20228" class="Bound">B</a> <a id="20230" class="Symbol">:</a> <a id="20232" class="Symbol">(</a><a id="20233" href="2--Paths-and-Identifications.2-1--Paths.html#20233" class="Bound">i</a> <a id="20235" class="Symbol">:</a> <a id="20237" href="Library.Primitive.html#1675" class="Datatype">I</a><a id="20238" class="Symbol">)</a> <a id="20240" class="Symbol">→</a> <a id="20242" href="2--Paths-and-Identifications.2-1--Paths.html#20211" class="Bound">A</a> <a id="20244" href="2--Paths-and-Identifications.2-1--Paths.html#20233" class="Bound">i</a> <a id="20246" class="Symbol">→</a> <a id="20248" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="20253" href="2--Paths-and-Identifications.2-1--Paths.html#2977" class="Generalizable">ℓ₂</a><a id="20255" class="Symbol">}</a>
  <a id="20259" class="Symbol">{</a><a id="20260" href="2--Paths-and-Identifications.2-1--Paths.html#20260" class="Bound">x</a> <a id="20262" class="Symbol">:</a> <a id="20264" href="Library.Prelude.html#1429" class="Function">Σ[</a> <a id="20267" href="2--Paths-and-Identifications.2-1--Paths.html#20267" class="Bound">a</a> <a id="20269" href="Library.Prelude.html#1429" class="Function">∈</a> <a id="20271" href="2--Paths-and-Identifications.2-1--Paths.html#20211" class="Bound">A</a> <a id="20273" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a> <a id="20276" href="Library.Prelude.html#1429" class="Function">]</a> <a id="20278" href="2--Paths-and-Identifications.2-1--Paths.html#20228" class="Bound">B</a> <a id="20280" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a> <a id="20283" href="2--Paths-and-Identifications.2-1--Paths.html#20267" class="Bound">a</a><a id="20284" class="Symbol">}</a> <a id="20286" class="Symbol">{</a><a id="20287" href="2--Paths-and-Identifications.2-1--Paths.html#20287" class="Bound">y</a> <a id="20289" class="Symbol">:</a> <a id="20291" href="Library.Prelude.html#1429" class="Function">Σ[</a> <a id="20294" href="2--Paths-and-Identifications.2-1--Paths.html#20294" class="Bound">a</a> <a id="20296" href="Library.Prelude.html#1429" class="Function">∈</a> <a id="20298" href="2--Paths-and-Identifications.2-1--Paths.html#20211" class="Bound">A</a> <a id="20300" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a> <a id="20303" href="Library.Prelude.html#1429" class="Function">]</a> <a id="20305" href="2--Paths-and-Identifications.2-1--Paths.html#20228" class="Bound">B</a> <a id="20307" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a> <a id="20310" href="2--Paths-and-Identifications.2-1--Paths.html#20294" class="Bound">a</a><a id="20311" class="Symbol">}</a>
  <a id="20315" class="Keyword">where</a>

  <a id="20324" class="Comment">-- Exercise:</a>
  <a id="20339" class="Comment">-- ΣPathP→PathPΣ : Σ[ p ∈ PathP {!!} {!!} {!!} ] PathP {!!} {!!} {!!}</a>
  <a id="20411" class="Comment">--        → PathP (λ i → Σ[ a ∈ A i ] B i a) x y</a>

  <a id="20655" href="2--Paths-and-Identifications.2-1--Paths.html#20462" class="Function">ΣPathP→PathPΣ</a> <a id="20669" href="2--Paths-and-Identifications.2-1--Paths.html#20669" class="Bound">p</a> <a id="20671" href="2--Paths-and-Identifications.2-1--Paths.html#20671" class="Bound">i</a> <a id="20673" class="Symbol">.</a><a id="20674" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="20678" class="Symbol">=</a> <a id="20680" href="2--Paths-and-Identifications.2-1--Paths.html#20669" class="Bound">p</a> <a id="20682" class="Symbol">.</a><a id="20683" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="20687" href="2--Paths-and-Identifications.2-1--Paths.html#20671" class="Bound">i</a>
  <a id="20691" href="2--Paths-and-Identifications.2-1--Paths.html#20462" class="Function">ΣPathP→PathPΣ</a> <a id="20705" href="2--Paths-and-Identifications.2-1--Paths.html#20705" class="Bound">p</a> <a id="20707" href="2--Paths-and-Identifications.2-1--Paths.html#20707" class="Bound">i</a> <a id="20709" class="Symbol">.</a><a id="20710" href="Library.Prelude.html#1118" class="Field">snd</a> <a id="20714" class="Symbol">=</a> <a id="20716" href="2--Paths-and-Identifications.2-1--Paths.html#20705" class="Bound">p</a> <a id="20718" class="Symbol">.</a><a id="20719" href="Library.Prelude.html#1118" class="Field">snd</a> <a id="20723" href="2--Paths-and-Identifications.2-1--Paths.html#20707" class="Bound">i</a>

  <a id="20728" class="Comment">-- Exercise:</a>
  <a id="20743" class="Comment">-- PathPΣ→ΣPathP : PathP (λ i → Σ[ a ∈ A i ] B i a) x y</a>
  <a id="20801" class="Comment">--        → Σ[ p ∈ PathP {!!} {!!} {!!} ] PathP {!!} {!!} {!!}</a>

  <a id="21059" href="2--Paths-and-Identifications.2-1--Paths.html#20866" class="Function">PathPΣ→ΣPathP</a> <a id="21073" href="2--Paths-and-Identifications.2-1--Paths.html#21073" class="Bound">p</a> <a id="21075" class="Symbol">.</a><a id="21076" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="21080" href="2--Paths-and-Identifications.2-1--Paths.html#21080" class="Bound">i</a> <a id="21082" class="Symbol">=</a> <a id="21084" href="2--Paths-and-Identifications.2-1--Paths.html#21073" class="Bound">p</a> <a id="21086" href="2--Paths-and-Identifications.2-1--Paths.html#21080" class="Bound">i</a> <a id="21088" class="Symbol">.</a><a id="21089" href="Library.Prelude.html#1106" class="Field">fst</a>
  <a id="21095" href="2--Paths-and-Identifications.2-1--Paths.html#20866" class="Function">PathPΣ→ΣPathP</a> <a id="21109" href="2--Paths-and-Identifications.2-1--Paths.html#21109" class="Bound">p</a> <a id="21111" class="Symbol">.</a><a id="21112" href="Library.Prelude.html#1118" class="Field">snd</a> <a id="21116" href="2--Paths-and-Identifications.2-1--Paths.html#21116" class="Bound">i</a> <a id="21118" class="Symbol">=</a> <a id="21120" href="2--Paths-and-Identifications.2-1--Paths.html#21109" class="Bound">p</a> <a id="21122" href="2--Paths-and-Identifications.2-1--Paths.html#21116" class="Bound">i</a> <a id="21124" class="Symbol">.</a><a id="21125" href="Library.Prelude.html#1118" class="Field">snd</a>
</pre>
<p>And now dependent functions. Similarly to what we have just seen for
Σ-types, there are lots of ways to add dependency to the arguments of
function extensionality. The most obvious is to allow <code>B</code> to depend on
<code>A</code>, not involving the cubical interval:</p>
<pre class="Agda"><a id="21390" class="Keyword">module</a> <a id="21397" href="2--Paths-and-Identifications.2-1--Paths.html#21397" class="Module">_</a> <a id="21399" class="Symbol">{</a><a id="21400" href="2--Paths-and-Identifications.2-1--Paths.html#21400" class="Bound">A</a> <a id="21402" class="Symbol">:</a> <a id="21404" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="21409" href="2--Paths-and-Identifications.2-1--Paths.html#2972" class="Generalizable">ℓ</a><a id="21410" class="Symbol">}</a> <a id="21412" class="Symbol">{</a><a id="21413" href="2--Paths-and-Identifications.2-1--Paths.html#21413" class="Bound">B</a> <a id="21415" class="Symbol">:</a> <a id="21417" href="2--Paths-and-Identifications.2-1--Paths.html#21400" class="Bound">A</a> <a id="21419" class="Symbol">→</a> <a id="21421" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="21426" href="2--Paths-and-Identifications.2-1--Paths.html#2977" class="Generalizable">ℓ₂</a><a id="21428" class="Symbol">}</a>
  <a id="21432" class="Symbol">{</a><a id="21433" href="2--Paths-and-Identifications.2-1--Paths.html#21433" class="Bound">f</a> <a id="21435" href="2--Paths-and-Identifications.2-1--Paths.html#21435" class="Bound">g</a> <a id="21437" class="Symbol">:</a> <a id="21439" class="Symbol">(</a><a id="21440" href="2--Paths-and-Identifications.2-1--Paths.html#21440" class="Bound">a</a> <a id="21442" class="Symbol">:</a> <a id="21444" href="2--Paths-and-Identifications.2-1--Paths.html#21400" class="Bound">A</a><a id="21445" class="Symbol">)</a> <a id="21447" class="Symbol">→</a> <a id="21449" href="2--Paths-and-Identifications.2-1--Paths.html#21413" class="Bound">B</a> <a id="21451" href="2--Paths-and-Identifications.2-1--Paths.html#21440" class="Bound">a</a><a id="21452" class="Symbol">}</a>
  <a id="21456" class="Keyword">where</a>
  <a id="21464" href="2--Paths-and-Identifications.2-1--Paths.html#21464" class="Function">funext</a> <a id="21471" class="Symbol">:</a> <a id="21473" class="Symbol">((</a><a id="21475" href="2--Paths-and-Identifications.2-1--Paths.html#21475" class="Bound">x</a> <a id="21477" class="Symbol">:</a> <a id="21479" href="2--Paths-and-Identifications.2-1--Paths.html#21400" class="Bound">A</a><a id="21480" class="Symbol">)</a> <a id="21482" class="Symbol">→</a> <a id="21484" class="Symbol">(</a><a id="21485" href="2--Paths-and-Identifications.2-1--Paths.html#21433" class="Bound">f</a> <a id="21487" href="2--Paths-and-Identifications.2-1--Paths.html#21475" class="Bound">x</a> <a id="21489" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="21491" href="2--Paths-and-Identifications.2-1--Paths.html#21435" class="Bound">g</a> <a id="21493" href="2--Paths-and-Identifications.2-1--Paths.html#21475" class="Bound">x</a><a id="21494" class="Symbol">))</a> <a id="21497" class="Symbol">→</a> <a id="21499" href="2--Paths-and-Identifications.2-1--Paths.html#21433" class="Bound">f</a> <a id="21501" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="21503" href="2--Paths-and-Identifications.2-1--Paths.html#21435" class="Bound">g</a>
  <a id="21507" href="2--Paths-and-Identifications.2-1--Paths.html#21464" class="Function">funext</a> <a id="21514" href="2--Paths-and-Identifications.2-1--Paths.html#21514" class="Bound">h</a> <a id="21516" href="2--Paths-and-Identifications.2-1--Paths.html#21516" class="Bound">i</a> <a id="21518" href="2--Paths-and-Identifications.2-1--Paths.html#21518" class="Bound">x</a> <a id="21520" class="Symbol">=</a> <a id="21522" href="2--Paths-and-Identifications.2-1--Paths.html#21514" class="Bound">h</a> <a id="21524" href="2--Paths-and-Identifications.2-1--Paths.html#21518" class="Bound">x</a> <a id="21526" href="2--Paths-and-Identifications.2-1--Paths.html#21516" class="Bound">i</a>
  
  <a id="21533" href="2--Paths-and-Identifications.2-1--Paths.html#21533" class="Function">funext⁻</a> <a id="21541" class="Symbol">:</a> <a id="21543" href="2--Paths-and-Identifications.2-1--Paths.html#21433" class="Bound">f</a> <a id="21545" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="21547" href="2--Paths-and-Identifications.2-1--Paths.html#21435" class="Bound">g</a> <a id="21549" class="Symbol">→</a> <a id="21551" class="Symbol">((</a><a id="21553" href="2--Paths-and-Identifications.2-1--Paths.html#21553" class="Bound">x</a> <a id="21555" class="Symbol">:</a> <a id="21557" href="2--Paths-and-Identifications.2-1--Paths.html#21400" class="Bound">A</a><a id="21558" class="Symbol">)</a> <a id="21560" class="Symbol">→</a> <a id="21562" class="Symbol">(</a><a id="21563" href="2--Paths-and-Identifications.2-1--Paths.html#21433" class="Bound">f</a> <a id="21565" href="2--Paths-and-Identifications.2-1--Paths.html#21553" class="Bound">x</a> <a id="21567" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="21569" href="2--Paths-and-Identifications.2-1--Paths.html#21435" class="Bound">g</a> <a id="21571" href="2--Paths-and-Identifications.2-1--Paths.html#21553" class="Bound">x</a><a id="21572" class="Symbol">))</a>
  <a id="21577" href="2--Paths-and-Identifications.2-1--Paths.html#21533" class="Function">funext⁻</a> <a id="21585" href="2--Paths-and-Identifications.2-1--Paths.html#21585" class="Bound">p</a> <a id="21587" href="2--Paths-and-Identifications.2-1--Paths.html#21587" class="Bound">x</a> <a id="21589" href="2--Paths-and-Identifications.2-1--Paths.html#21589" class="Bound">i</a> <a id="21591" class="Symbol">=</a> <a id="21593" href="2--Paths-and-Identifications.2-1--Paths.html#21585" class="Bound">p</a> <a id="21595" href="2--Paths-and-Identifications.2-1--Paths.html#21589" class="Bound">i</a> <a id="21597" href="2--Paths-and-Identifications.2-1--Paths.html#21587" class="Bound">x</a>
</pre>
<p>mvrnote:</p>
<pre class="Agda"><a id="21618" class="Keyword">module</a> <a id="21625" href="2--Paths-and-Identifications.2-1--Paths.html#21625" class="Module">_</a> <a id="21627" class="Symbol">{</a><a id="21628" href="2--Paths-and-Identifications.2-1--Paths.html#21628" class="Bound">A</a> <a id="21630" class="Symbol">:</a> <a id="21632" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="21637" href="2--Paths-and-Identifications.2-1--Paths.html#2972" class="Generalizable">ℓ</a><a id="21638" class="Symbol">}</a> <a id="21640" class="Symbol">{</a><a id="21641" href="2--Paths-and-Identifications.2-1--Paths.html#21641" class="Bound">B</a> <a id="21643" class="Symbol">:</a> <a id="21645" href="Library.Primitive.html#1675" class="Datatype">I</a> <a id="21647" class="Symbol">→</a> <a id="21649" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="21654" href="2--Paths-and-Identifications.2-1--Paths.html#2974" class="Generalizable">ℓ&#39;</a><a id="21656" class="Symbol">}</a>
  <a id="21660" class="Symbol">{</a><a id="21661" href="2--Paths-and-Identifications.2-1--Paths.html#21661" class="Bound">f</a> <a id="21663" class="Symbol">:</a> <a id="21665" href="2--Paths-and-Identifications.2-1--Paths.html#21628" class="Bound">A</a> <a id="21667" class="Symbol">→</a> <a id="21669" href="2--Paths-and-Identifications.2-1--Paths.html#21641" class="Bound">B</a> <a id="21671" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="21673" class="Symbol">}</a> <a id="21675" class="Symbol">{</a><a id="21676" href="2--Paths-and-Identifications.2-1--Paths.html#21676" class="Bound">g</a> <a id="21678" class="Symbol">:</a> <a id="21680" href="2--Paths-and-Identifications.2-1--Paths.html#21628" class="Bound">A</a> <a id="21682" class="Symbol">→</a> <a id="21684" href="2--Paths-and-Identifications.2-1--Paths.html#21641" class="Bound">B</a> <a id="21686" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="21688" class="Symbol">}</a>
  <a id="21692" class="Keyword">where</a>
  <a id="21700" href="2--Paths-and-Identifications.2-1--Paths.html#21700" class="Function">funextP</a> <a id="21708" class="Symbol">:</a> 
      <a id="21717" class="Symbol">((</a><a id="21719" href="2--Paths-and-Identifications.2-1--Paths.html#21719" class="Bound">x</a> <a id="21721" class="Symbol">:</a> <a id="21723" href="2--Paths-and-Identifications.2-1--Paths.html#21628" class="Bound">A</a><a id="21724" class="Symbol">)</a> <a id="21726" class="Symbol">→</a> <a id="21728" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="21734" href="2--Paths-and-Identifications.2-1--Paths.html#21641" class="Bound">B</a> <a id="21736" class="Symbol">(</a><a id="21737" href="2--Paths-and-Identifications.2-1--Paths.html#21661" class="Bound">f</a> <a id="21739" href="2--Paths-and-Identifications.2-1--Paths.html#21719" class="Bound">x</a><a id="21740" class="Symbol">)</a> <a id="21742" class="Symbol">(</a><a id="21743" href="2--Paths-and-Identifications.2-1--Paths.html#21676" class="Bound">g</a> <a id="21745" href="2--Paths-and-Identifications.2-1--Paths.html#21719" class="Bound">x</a><a id="21746" class="Symbol">))</a>
    <a id="21753" class="Symbol">→</a> <a id="21755" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="21761" class="Symbol">(λ</a> <a id="21764" href="2--Paths-and-Identifications.2-1--Paths.html#21764" class="Bound">i</a> <a id="21766" class="Symbol">→</a> <a id="21768" href="2--Paths-and-Identifications.2-1--Paths.html#21628" class="Bound">A</a> <a id="21770" class="Symbol">→</a> <a id="21772" href="2--Paths-and-Identifications.2-1--Paths.html#21641" class="Bound">B</a> <a id="21774" href="2--Paths-and-Identifications.2-1--Paths.html#21764" class="Bound">i</a><a id="21775" class="Symbol">)</a> <a id="21777" href="2--Paths-and-Identifications.2-1--Paths.html#21661" class="Bound">f</a> <a id="21779" href="2--Paths-and-Identifications.2-1--Paths.html#21676" class="Bound">g</a>
  <a id="21783" href="2--Paths-and-Identifications.2-1--Paths.html#21700" class="Function">funextP</a> <a id="21791" href="2--Paths-and-Identifications.2-1--Paths.html#21791" class="Bound">h</a> <a id="21793" href="2--Paths-and-Identifications.2-1--Paths.html#21793" class="Bound">i</a> <a id="21795" href="2--Paths-and-Identifications.2-1--Paths.html#21795" class="Bound">x</a> <a id="21797" class="Symbol">=</a> <a id="21799" href="2--Paths-and-Identifications.2-1--Paths.html#21791" class="Bound">h</a> <a id="21801" href="2--Paths-and-Identifications.2-1--Paths.html#21795" class="Bound">x</a> <a id="21803" href="2--Paths-and-Identifications.2-1--Paths.html#21793" class="Bound">i</a>
  
  <a id="21810" href="2--Paths-and-Identifications.2-1--Paths.html#21810" class="Function">funextP⁻</a> <a id="21819" class="Symbol">:</a> 
      <a id="21828" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="21834" class="Symbol">(λ</a> <a id="21837" href="2--Paths-and-Identifications.2-1--Paths.html#21837" class="Bound">i</a> <a id="21839" class="Symbol">→</a> <a id="21841" href="2--Paths-and-Identifications.2-1--Paths.html#21628" class="Bound">A</a> <a id="21843" class="Symbol">→</a> <a id="21845" href="2--Paths-and-Identifications.2-1--Paths.html#21641" class="Bound">B</a> <a id="21847" href="2--Paths-and-Identifications.2-1--Paths.html#21837" class="Bound">i</a><a id="21848" class="Symbol">)</a> <a id="21850" href="2--Paths-and-Identifications.2-1--Paths.html#21661" class="Bound">f</a> <a id="21852" href="2--Paths-and-Identifications.2-1--Paths.html#21676" class="Bound">g</a>
    <a id="21858" class="Symbol">→</a> <a id="21860" class="Symbol">((</a><a id="21862" href="2--Paths-and-Identifications.2-1--Paths.html#21862" class="Bound">x</a> <a id="21864" class="Symbol">:</a> <a id="21866" href="2--Paths-and-Identifications.2-1--Paths.html#21628" class="Bound">A</a><a id="21867" class="Symbol">)</a> <a id="21869" class="Symbol">→</a> <a id="21871" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="21877" href="2--Paths-and-Identifications.2-1--Paths.html#21641" class="Bound">B</a> <a id="21879" class="Symbol">(</a><a id="21880" href="2--Paths-and-Identifications.2-1--Paths.html#21661" class="Bound">f</a> <a id="21882" href="2--Paths-and-Identifications.2-1--Paths.html#21862" class="Bound">x</a><a id="21883" class="Symbol">)</a> <a id="21885" class="Symbol">(</a><a id="21886" href="2--Paths-and-Identifications.2-1--Paths.html#21676" class="Bound">g</a> <a id="21888" href="2--Paths-and-Identifications.2-1--Paths.html#21862" class="Bound">x</a><a id="21889" class="Symbol">))</a>
  <a id="21894" href="2--Paths-and-Identifications.2-1--Paths.html#21810" class="Function">funextP⁻</a> <a id="21903" href="2--Paths-and-Identifications.2-1--Paths.html#21903" class="Bound">p</a> <a id="21905" href="2--Paths-and-Identifications.2-1--Paths.html#21905" class="Bound">x</a> <a id="21907" href="2--Paths-and-Identifications.2-1--Paths.html#21907" class="Bound">i</a> <a id="21909" class="Symbol">=</a> <a id="21911" href="2--Paths-and-Identifications.2-1--Paths.html#21903" class="Bound">p</a> <a id="21913" href="2--Paths-and-Identifications.2-1--Paths.html#21907" class="Bound">i</a> <a id="21915" href="2--Paths-and-Identifications.2-1--Paths.html#21905" class="Bound">x</a>
</pre>
<p>Path-overs are also what is required to describe the <em>induction</em>
principle of the circle; the upgraded version of <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13572" class="Function">S¹-rec</a></code> for
dependent functions. If we have a type family <code>A : S¹ → Type</code> over the
circle rather than just a single type, the provided point must be an
element of the type family at <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a></code>, and the loop is a path from
that point to itself, lying over the path of types <code>A ∘ loop</code>.</p>
<pre class="Agda"><a id="S¹-ind-≡"></a><a id="22327" href="2--Paths-and-Identifications.2-1--Paths.html#22327" class="Function">S¹-ind-≡</a> <a id="22336" class="Symbol">:</a> <a id="22338" class="Symbol">{</a><a id="22339" href="2--Paths-and-Identifications.2-1--Paths.html#22339" class="Bound">A</a> <a id="22341" class="Symbol">:</a> <a id="22343" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a> <a id="22346" class="Symbol">→</a> <a id="22348" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="22353" href="2--Paths-and-Identifications.2-1--Paths.html#2972" class="Generalizable">ℓ</a><a id="22354" class="Symbol">}</a>
       <a id="22363" class="Symbol">→</a> <a id="22365" class="Symbol">(</a><a id="22366" href="2--Paths-and-Identifications.2-1--Paths.html#22366" class="Bound">a</a> <a id="22368" class="Symbol">:</a> <a id="22370" href="2--Paths-and-Identifications.2-1--Paths.html#22339" class="Bound">A</a> <a id="22372" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a><a id="22376" class="Symbol">)</a>
       <a id="22385" class="Symbol">→</a> <a id="22387" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="22393" class="Symbol">(λ</a> <a id="22396" href="2--Paths-and-Identifications.2-1--Paths.html#22396" class="Bound">i</a> <a id="22398" class="Symbol">→</a> <a id="22400" href="2--Paths-and-Identifications.2-1--Paths.html#22339" class="Bound">A</a> <a id="22402" class="Symbol">(</a><a id="22403" href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a> <a id="22408" href="2--Paths-and-Identifications.2-1--Paths.html#22396" class="Bound">i</a><a id="22409" class="Symbol">))</a> <a id="22412" href="2--Paths-and-Identifications.2-1--Paths.html#22366" class="Bound">a</a> <a id="22414" href="2--Paths-and-Identifications.2-1--Paths.html#22366" class="Bound">a</a>
       <a id="22423" class="Symbol">→</a> <a id="22425" class="Symbol">(</a><a id="22426" href="2--Paths-and-Identifications.2-1--Paths.html#22426" class="Bound">s</a> <a id="22428" class="Symbol">:</a> <a id="22430" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a><a id="22432" class="Symbol">)</a> <a id="22434" class="Symbol">→</a> <a id="22436" href="2--Paths-and-Identifications.2-1--Paths.html#22339" class="Bound">A</a> <a id="22438" href="2--Paths-and-Identifications.2-1--Paths.html#22426" class="Bound">s</a>
<a id="22440" href="2--Paths-and-Identifications.2-1--Paths.html#22327" class="Function">S¹-ind-≡</a> <a id="22449" href="2--Paths-and-Identifications.2-1--Paths.html#22449" class="Bound">a</a> <a id="22451" href="2--Paths-and-Identifications.2-1--Paths.html#22451" class="Bound">l</a> <a id="22453" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a> <a id="22458" class="Symbol">=</a> <a id="22460" href="2--Paths-and-Identifications.2-1--Paths.html#22449" class="Bound">a</a>
<a id="22462" href="2--Paths-and-Identifications.2-1--Paths.html#22327" class="Function">S¹-ind-≡</a> <a id="22471" href="2--Paths-and-Identifications.2-1--Paths.html#22471" class="Bound">a</a> <a id="22473" href="2--Paths-and-Identifications.2-1--Paths.html#22473" class="Bound">l</a> <a id="22475" class="Symbol">(</a><a id="22476" href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a> <a id="22481" href="2--Paths-and-Identifications.2-1--Paths.html#22481" class="Bound">i</a><a id="22482" class="Symbol">)</a> <a id="22484" class="Symbol">=</a> <a id="22486" href="2--Paths-and-Identifications.2-1--Paths.html#22473" class="Bound">l</a> <a id="22488" href="2--Paths-and-Identifications.2-1--Paths.html#22481" class="Bound">i</a>
</pre>
<p>The input <code>l : PathP (λ i → A (loop i)) a a</code> involves a path <code>λ i → A (loop i)</code> from <code>A base</code> to itself, that is, a path between two
<em>types</em>. Right now we have no way of producing interesting paths
between types, but univalence will come to the rescue in Lecture 2-X.</p>
<h2 id="squares"><a class="header" href="#squares">Squares</a></h2>
<p>A path in a type of paths is a function with shape <code>a : I → (I → A)</code>.
This is equivalent (again via something like <code class="Agda"><a href="1--Type-Theory.1-1--Types-and-Functions.html#25869" class="Function">×-curry</a></code>) to a function
<code>I × I → A</code>, and we can therefore think of paths-between-paths as
functions of two interval variables <code>i</code> and <code>j</code>. Though we can’t use
the elements of <code>I</code> as data and so don’t let ourselves actually form
the type <code>I × I</code>, we can nevertheless think of a function of two
interval variables corresponding to a square.</p>
<pre><code>         a-1
   a01 — — — &gt; a11
    ^           ^             ^
a0- |           | a1-       j |
    |           |             ∙ — &gt;
   a00 — — — &gt; a10              i
         a-0
</code></pre>
<p>We will see a square like this as a path from the left side to the
right side, that is, as a path between the paths <code>a0-</code> and <code>a1-</code>.
However, these don’t have the same type; observing the endpoints, we
see that <code>a0- : a00 ≡ a01</code> and <code>a1- : a10 ≡ a11</code>. Using the other two
paths <code>a-0</code> and <code>a-1</code>, we may construct a path of types that
continuously transforms from the type of <code>a0-</code> to the type of <code>a1-</code>,
as we sweep from left to right.</p>
<pre class="Agda"><a id="Square-sweep"></a><a id="23882" href="2--Paths-and-Identifications.2-1--Paths.html#23882" class="Function">Square-sweep</a> <a id="23895" class="Symbol">:</a> <a id="23897" class="Symbol">{</a><a id="23898" href="2--Paths-and-Identifications.2-1--Paths.html#23898" class="Bound">A</a> <a id="23900" class="Symbol">:</a> <a id="23902" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="23907" href="2--Paths-and-Identifications.2-1--Paths.html#2972" class="Generalizable">ℓ</a><a id="23908" class="Symbol">}</a> <a id="23910" class="Symbol">{</a><a id="23911" href="2--Paths-and-Identifications.2-1--Paths.html#23911" class="Bound">a00</a> <a id="23915" href="2--Paths-and-Identifications.2-1--Paths.html#23915" class="Bound">a01</a> <a id="23919" href="2--Paths-and-Identifications.2-1--Paths.html#23919" class="Bound">a10</a> <a id="23923" href="2--Paths-and-Identifications.2-1--Paths.html#23923" class="Bound">a11</a> <a id="23927" class="Symbol">:</a> <a id="23929" href="2--Paths-and-Identifications.2-1--Paths.html#23898" class="Bound">A</a><a id="23930" class="Symbol">}</a>
  <a id="23934" class="Symbol">→</a> <a id="23936" class="Symbol">(</a><a id="23937" href="2--Paths-and-Identifications.2-1--Paths.html#23937" class="Bound">a-0</a> <a id="23941" class="Symbol">:</a> <a id="23943" href="2--Paths-and-Identifications.2-1--Paths.html#23911" class="Bound">a00</a> <a id="23947" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="23949" href="2--Paths-and-Identifications.2-1--Paths.html#23919" class="Bound">a10</a><a id="23952" class="Symbol">)</a> <a id="23954" class="Symbol">(</a><a id="23955" href="2--Paths-and-Identifications.2-1--Paths.html#23955" class="Bound">a-1</a> <a id="23959" class="Symbol">:</a> <a id="23961" href="2--Paths-and-Identifications.2-1--Paths.html#23915" class="Bound">a01</a> <a id="23965" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="23967" href="2--Paths-and-Identifications.2-1--Paths.html#23923" class="Bound">a11</a><a id="23970" class="Symbol">)</a>
  <a id="23974" class="Symbol">→</a> <a id="23976" class="Symbol">(</a><a id="23977" href="Library.Primitive.html#1675" class="Datatype">I</a> <a id="23979" class="Symbol">→</a> <a id="23981" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="23986" href="2--Paths-and-Identifications.2-1--Paths.html#2972" class="Generalizable">ℓ</a><a id="23987" class="Symbol">)</a>
<a id="23989" href="2--Paths-and-Identifications.2-1--Paths.html#23882" class="Function">Square-sweep</a> <a id="24002" href="2--Paths-and-Identifications.2-1--Paths.html#24002" class="Bound">a-0</a> <a id="24006" href="2--Paths-and-Identifications.2-1--Paths.html#24006" class="Bound">a-1</a> <a id="24010" href="2--Paths-and-Identifications.2-1--Paths.html#24010" class="Bound">i</a> <a id="24012" class="Symbol">=</a> <a id="24014" href="2--Paths-and-Identifications.2-1--Paths.html#24002" class="Bound">a-0</a> <a id="24018" href="2--Paths-and-Identifications.2-1--Paths.html#24010" class="Bound">i</a> <a id="24020" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="24022" href="2--Paths-and-Identifications.2-1--Paths.html#24006" class="Bound">a-1</a> <a id="24026" href="2--Paths-and-Identifications.2-1--Paths.html#24010" class="Bound">i</a>
</pre>
<p>Plugging in the endpoints of <code>I</code>, we indeed see that</p>
<ul>
<li><code>(Square-sweep a-0 a-1 i0) = (a00 ≡ a01)</code> and</li>
<li><code>(Square-sweep a-0 a-1 i1) = (a10 ≡ a11)</code></li>
</ul>
<p>by definition.</p>
<p>We want to say that the square is somehow an element of this
continuously varying path type. With <code class="Agda"><a href="Library.Primitive.html#2174" class="Postulate">PathP</a></code>, we can do exactly
this, and define the type of squares as paths over the continuously
varying path <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#23882" class="Function">Square-sweep</a></code>:</p>
<pre class="Agda"><a id="Square"></a><a id="24427" href="2--Paths-and-Identifications.2-1--Paths.html#24427" class="Function">Square</a> <a id="24434" class="Symbol">:</a> <a id="24436" class="Symbol">{</a><a id="24437" href="2--Paths-and-Identifications.2-1--Paths.html#24437" class="Bound">A</a> <a id="24439" class="Symbol">:</a> <a id="24441" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="24446" href="2--Paths-and-Identifications.2-1--Paths.html#2972" class="Generalizable">ℓ</a><a id="24447" class="Symbol">}</a> <a id="24449" class="Symbol">{</a><a id="24450" href="2--Paths-and-Identifications.2-1--Paths.html#24450" class="Bound">a00</a> <a id="24454" href="2--Paths-and-Identifications.2-1--Paths.html#24454" class="Bound">a01</a> <a id="24458" href="2--Paths-and-Identifications.2-1--Paths.html#24458" class="Bound">a10</a> <a id="24462" href="2--Paths-and-Identifications.2-1--Paths.html#24462" class="Bound">a11</a> <a id="24466" class="Symbol">:</a> <a id="24468" href="2--Paths-and-Identifications.2-1--Paths.html#24437" class="Bound">A</a><a id="24469" class="Symbol">}</a>
  <a id="24473" class="Symbol">→</a> <a id="24475" class="Symbol">(</a><a id="24476" href="2--Paths-and-Identifications.2-1--Paths.html#24476" class="Bound">a0-</a> <a id="24480" class="Symbol">:</a> <a id="24482" href="2--Paths-and-Identifications.2-1--Paths.html#24450" class="Bound">a00</a> <a id="24486" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="24488" href="2--Paths-and-Identifications.2-1--Paths.html#24454" class="Bound">a01</a><a id="24491" class="Symbol">)</a>
  <a id="24495" class="Symbol">→</a> <a id="24497" class="Symbol">(</a><a id="24498" href="2--Paths-and-Identifications.2-1--Paths.html#24498" class="Bound">a1-</a> <a id="24502" class="Symbol">:</a> <a id="24504" href="2--Paths-and-Identifications.2-1--Paths.html#24458" class="Bound">a10</a> <a id="24508" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="24510" href="2--Paths-and-Identifications.2-1--Paths.html#24462" class="Bound">a11</a><a id="24513" class="Symbol">)</a>
  <a id="24517" class="Symbol">→</a> <a id="24519" class="Symbol">(</a><a id="24520" href="2--Paths-and-Identifications.2-1--Paths.html#24520" class="Bound">a-0</a> <a id="24524" class="Symbol">:</a> <a id="24526" href="2--Paths-and-Identifications.2-1--Paths.html#24450" class="Bound">a00</a> <a id="24530" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="24532" href="2--Paths-and-Identifications.2-1--Paths.html#24458" class="Bound">a10</a><a id="24535" class="Symbol">)</a>
  <a id="24539" class="Symbol">→</a> <a id="24541" class="Symbol">(</a><a id="24542" href="2--Paths-and-Identifications.2-1--Paths.html#24542" class="Bound">a-1</a> <a id="24546" class="Symbol">:</a> <a id="24548" href="2--Paths-and-Identifications.2-1--Paths.html#24454" class="Bound">a01</a> <a id="24552" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="24554" href="2--Paths-and-Identifications.2-1--Paths.html#24462" class="Bound">a11</a><a id="24557" class="Symbol">)</a>
  <a id="24561" class="Symbol">→</a> <a id="24563" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="24568" href="2--Paths-and-Identifications.2-1--Paths.html#2972" class="Generalizable">ℓ</a>
<a id="24570" href="2--Paths-and-Identifications.2-1--Paths.html#24427" class="Function">Square</a> <a id="24577" href="2--Paths-and-Identifications.2-1--Paths.html#24577" class="Bound">a0-</a> <a id="24581" href="2--Paths-and-Identifications.2-1--Paths.html#24581" class="Bound">a1-</a> <a id="24585" href="2--Paths-and-Identifications.2-1--Paths.html#24585" class="Bound">a-0</a> <a id="24589" href="2--Paths-and-Identifications.2-1--Paths.html#24589" class="Bound">a-1</a> <a id="24593" class="Symbol">=</a> <a id="24595" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="24601" class="Symbol">(</a><a id="24602" href="2--Paths-and-Identifications.2-1--Paths.html#23882" class="Function">Square-sweep</a> <a id="24615" href="2--Paths-and-Identifications.2-1--Paths.html#24585" class="Bound">a-0</a> <a id="24619" href="2--Paths-and-Identifications.2-1--Paths.html#24589" class="Bound">a-1</a><a id="24622" class="Symbol">)</a> <a id="24624" href="2--Paths-and-Identifications.2-1--Paths.html#24577" class="Bound">a0-</a> <a id="24628" href="2--Paths-and-Identifications.2-1--Paths.html#24581" class="Bound">a1-</a>
</pre>
<p>Here’s the picture again, for you to inspect:</p>
<pre><code>         a-1
   a01 — — — &gt; a11
    ^           ^             ^
a0- |           | a1-       j |
    |           |             ∙ — &gt;
   a00 — — — &gt; a10              i
         a-0
</code></pre>
<p>mvrnote: Square p q refl refl is the same as p ≡ q </p>
<p>Elements of the <code>Square A</code> type are squares exist in a constant type
<code>A</code>. But just as we can upgrade <code class="Agda"><a href="Library.Prelude.html#1916" class="Function">Path</a></code> to <code class="Agda"><a href="Library.Primitive.html#2174" class="Postulate">PathP</a></code> where
the type <code>A</code> can vary over the path, we can upgrade <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#24427" class="Function">Square</a></code> to
<code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#25495" class="Function">SquareP</a></code> where the type can vary over the square.</p>
<p>We will fill in the definition, but try filling in the types of the
sides of the square.</p>
<pre class="Agda"><a id="25288" class="Comment">-- Exercise:</a>
<a id="25301" class="Comment">-- SquareP :</a>
<a id="25314" class="Comment">--   (A : I → I → Type ℓ)</a>
<a id="25340" class="Comment">--   {a₀₀ : A i0 i0} {a₀₁ : A i0 i1} {a₁₀ : A i1 i0} {a₁₁ : A i1 i1}</a>
<a id="25409" class="Comment">--   (a₀- : {!!})</a>
<a id="25427" class="Comment">--   (a₁- : {!!})</a>
<a id="25445" class="Comment">--   (a-₀ : {!!})</a>
<a id="25463" class="Comment">--   (a-₁ : {!!})</a>
<a id="25481" class="Comment">--   → Type ℓ</a>

<a id="25978" href="2--Paths-and-Identifications.2-1--Paths.html#25495" class="Function">SquareP</a> <a id="25986" href="2--Paths-and-Identifications.2-1--Paths.html#25986" class="Bound">A</a> <a id="25988" href="2--Paths-and-Identifications.2-1--Paths.html#25988" class="Bound">a₀-</a> <a id="25992" href="2--Paths-and-Identifications.2-1--Paths.html#25992" class="Bound">a₁-</a> <a id="25996" href="2--Paths-and-Identifications.2-1--Paths.html#25996" class="Bound">a-₀</a> <a id="26000" href="2--Paths-and-Identifications.2-1--Paths.html#26000" class="Bound">a-₁</a>
  <a id="26006" class="Symbol">=</a> <a id="26008" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="26014" class="Symbol">(λ</a> <a id="26017" href="2--Paths-and-Identifications.2-1--Paths.html#26017" class="Bound">i</a> <a id="26019" class="Symbol">→</a> <a id="26021" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="26027" class="Symbol">(λ</a> <a id="26030" href="2--Paths-and-Identifications.2-1--Paths.html#26030" class="Bound">j</a> <a id="26032" class="Symbol">→</a> <a id="26034" href="2--Paths-and-Identifications.2-1--Paths.html#25986" class="Bound">A</a> <a id="26036" href="2--Paths-and-Identifications.2-1--Paths.html#26017" class="Bound">i</a> <a id="26038" href="2--Paths-and-Identifications.2-1--Paths.html#26030" class="Bound">j</a><a id="26039" class="Symbol">)</a> <a id="26041" class="Symbol">(</a><a id="26042" href="2--Paths-and-Identifications.2-1--Paths.html#25996" class="Bound">a-₀</a> <a id="26046" href="2--Paths-and-Identifications.2-1--Paths.html#26017" class="Bound">i</a><a id="26047" class="Symbol">)</a> <a id="26049" class="Symbol">(</a><a id="26050" href="2--Paths-and-Identifications.2-1--Paths.html#26000" class="Bound">a-₁</a> <a id="26054" href="2--Paths-and-Identifications.2-1--Paths.html#26017" class="Bound">i</a><a id="26055" class="Symbol">))</a>
          <a id="26068" href="2--Paths-and-Identifications.2-1--Paths.html#25988" class="Bound">a₀-</a>
          <a id="26082" href="2--Paths-and-Identifications.2-1--Paths.html#25992" class="Bound">a₁-</a>
</pre>
<p>For some practice thinking with squares, write a version of <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#17691" class="Function">ap</a></code>
that applies to squares.</p>
<pre class="Agda"><a id="ap-Square"></a><a id="26188" href="2--Paths-and-Identifications.2-1--Paths.html#26188" class="Function">ap-Square</a> <a id="26198" class="Symbol">:</a> <a id="26200" class="Symbol">(</a><a id="26201" href="2--Paths-and-Identifications.2-1--Paths.html#26201" class="Bound">f</a> <a id="26203" class="Symbol">:</a> <a id="26205" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="26207" class="Symbol">→</a> <a id="26209" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="26210" class="Symbol">)</a>
  <a id="26214" class="Symbol">→</a> <a id="26216" class="Symbol">{</a><a id="26217" href="2--Paths-and-Identifications.2-1--Paths.html#26217" class="Bound">a₀₀</a> <a id="26221" href="2--Paths-and-Identifications.2-1--Paths.html#26221" class="Bound">a₀₁</a> <a id="26225" href="2--Paths-and-Identifications.2-1--Paths.html#26225" class="Bound">a₁₀</a> <a id="26229" href="2--Paths-and-Identifications.2-1--Paths.html#26229" class="Bound">a₁₁</a> <a id="26233" class="Symbol">:</a> <a id="26235" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a><a id="26236" class="Symbol">}</a>
  <a id="26240" class="Symbol">→</a> <a id="26242" class="Symbol">{</a><a id="26243" href="2--Paths-and-Identifications.2-1--Paths.html#26243" class="Bound">a₀-</a> <a id="26247" class="Symbol">:</a> <a id="26249" href="Library.Prelude.html#1916" class="Function">Path</a> <a id="26254" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="26256" href="2--Paths-and-Identifications.2-1--Paths.html#26217" class="Bound">a₀₀</a> <a id="26260" href="2--Paths-and-Identifications.2-1--Paths.html#26221" class="Bound">a₀₁</a><a id="26263" class="Symbol">}</a>
  <a id="26267" class="Symbol">→</a> <a id="26269" class="Symbol">{</a><a id="26270" href="2--Paths-and-Identifications.2-1--Paths.html#26270" class="Bound">a₁-</a> <a id="26274" class="Symbol">:</a> <a id="26276" href="Library.Prelude.html#1916" class="Function">Path</a> <a id="26281" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="26283" href="2--Paths-and-Identifications.2-1--Paths.html#26225" class="Bound">a₁₀</a> <a id="26287" href="2--Paths-and-Identifications.2-1--Paths.html#26229" class="Bound">a₁₁</a><a id="26290" class="Symbol">}</a>
  <a id="26294" class="Symbol">→</a> <a id="26296" class="Symbol">{</a><a id="26297" href="2--Paths-and-Identifications.2-1--Paths.html#26297" class="Bound">a-₀</a> <a id="26301" class="Symbol">:</a> <a id="26303" href="Library.Prelude.html#1916" class="Function">Path</a> <a id="26308" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="26310" href="2--Paths-and-Identifications.2-1--Paths.html#26217" class="Bound">a₀₀</a> <a id="26314" href="2--Paths-and-Identifications.2-1--Paths.html#26225" class="Bound">a₁₀</a><a id="26317" class="Symbol">}</a>
  <a id="26321" class="Symbol">→</a> <a id="26323" class="Symbol">{</a><a id="26324" href="2--Paths-and-Identifications.2-1--Paths.html#26324" class="Bound">a-₁</a> <a id="26328" class="Symbol">:</a> <a id="26330" href="Library.Prelude.html#1916" class="Function">Path</a> <a id="26335" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="26337" href="2--Paths-and-Identifications.2-1--Paths.html#26221" class="Bound">a₀₁</a> <a id="26341" href="2--Paths-and-Identifications.2-1--Paths.html#26229" class="Bound">a₁₁</a><a id="26344" class="Symbol">}</a>
  <a id="26348" class="Symbol">→</a> <a id="26350" href="2--Paths-and-Identifications.2-1--Paths.html#24427" class="Function">Square</a> <a id="26357" href="2--Paths-and-Identifications.2-1--Paths.html#26243" class="Bound">a₀-</a> <a id="26361" href="2--Paths-and-Identifications.2-1--Paths.html#26270" class="Bound">a₁-</a> <a id="26365" href="2--Paths-and-Identifications.2-1--Paths.html#26297" class="Bound">a-₀</a> <a id="26369" href="2--Paths-and-Identifications.2-1--Paths.html#26324" class="Bound">a-₁</a>
  <a id="26375" class="Symbol">→</a> <a id="26377" href="2--Paths-and-Identifications.2-1--Paths.html#24427" class="Function">Square</a> <a id="26384" class="Symbol">(</a><a id="26385" href="2--Paths-and-Identifications.2-1--Paths.html#17691" class="Function">ap</a> <a id="26388" href="2--Paths-and-Identifications.2-1--Paths.html#26201" class="Bound">f</a> <a id="26390" href="2--Paths-and-Identifications.2-1--Paths.html#26243" class="Bound">a₀-</a><a id="26393" class="Symbol">)</a> <a id="26395" class="Symbol">(</a><a id="26396" href="2--Paths-and-Identifications.2-1--Paths.html#17691" class="Function">ap</a> <a id="26399" href="2--Paths-and-Identifications.2-1--Paths.html#26201" class="Bound">f</a> <a id="26401" href="2--Paths-and-Identifications.2-1--Paths.html#26270" class="Bound">a₁-</a><a id="26404" class="Symbol">)</a> <a id="26406" class="Symbol">(</a><a id="26407" href="2--Paths-and-Identifications.2-1--Paths.html#17691" class="Function">ap</a> <a id="26410" href="2--Paths-and-Identifications.2-1--Paths.html#26201" class="Bound">f</a> <a id="26412" href="2--Paths-and-Identifications.2-1--Paths.html#26297" class="Bound">a-₀</a><a id="26415" class="Symbol">)</a> <a id="26417" class="Symbol">(</a><a id="26418" href="2--Paths-and-Identifications.2-1--Paths.html#17691" class="Function">ap</a> <a id="26421" href="2--Paths-and-Identifications.2-1--Paths.html#26201" class="Bound">f</a> <a id="26423" href="2--Paths-and-Identifications.2-1--Paths.html#26324" class="Bound">a-₁</a><a id="26426" class="Symbol">)</a>
<a id="26428" class="Comment">-- Exercise:</a>
<a id="26441" class="Comment">-- ap-Square f s = {!!}</a>
</pre>
<p>Next, write down the function that flips a square along the diagonal:</p>
<pre><code>         a-1                           a1-
   a01 — — — &gt; a11               a10 — — — &gt; a11
    ^           ^                 ^           ^
a0- |           | a1-   ~~&gt;   a-0 |           | a-1
    |           |                 |           |
   a00 — — — &gt; a10               a00 — — — &gt; a01
         a-0                           a0-
</code></pre>
<pre class="Agda"><a id="flipSquare"></a><a id="26964" href="2--Paths-and-Identifications.2-1--Paths.html#26964" class="Function">flipSquare</a> <a id="26975" class="Symbol">:</a> <a id="26977" class="Symbol">{</a><a id="26978" href="2--Paths-and-Identifications.2-1--Paths.html#26978" class="Bound">a₀₀</a> <a id="26982" href="2--Paths-and-Identifications.2-1--Paths.html#26982" class="Bound">a₀₁</a> <a id="26986" href="2--Paths-and-Identifications.2-1--Paths.html#26986" class="Bound">a₁₀</a> <a id="26990" href="2--Paths-and-Identifications.2-1--Paths.html#26990" class="Bound">a₁₁</a> <a id="26994" class="Symbol">:</a> <a id="26996" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="26998" class="Symbol">}</a>
  <a id="27002" class="Symbol">→</a> <a id="27004" class="Symbol">{</a><a id="27005" href="2--Paths-and-Identifications.2-1--Paths.html#27005" class="Bound">a₀-</a> <a id="27009" class="Symbol">:</a> <a id="27011" href="Library.Prelude.html#1916" class="Function">Path</a> <a id="27016" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="27018" href="2--Paths-and-Identifications.2-1--Paths.html#26978" class="Bound">a₀₀</a> <a id="27022" href="2--Paths-and-Identifications.2-1--Paths.html#26982" class="Bound">a₀₁</a><a id="27025" class="Symbol">}</a>
  <a id="27029" class="Symbol">→</a> <a id="27031" class="Symbol">{</a><a id="27032" href="2--Paths-and-Identifications.2-1--Paths.html#27032" class="Bound">a₁-</a> <a id="27036" class="Symbol">:</a> <a id="27038" href="Library.Prelude.html#1916" class="Function">Path</a> <a id="27043" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="27045" href="2--Paths-and-Identifications.2-1--Paths.html#26986" class="Bound">a₁₀</a> <a id="27049" href="2--Paths-and-Identifications.2-1--Paths.html#26990" class="Bound">a₁₁</a><a id="27052" class="Symbol">}</a>
  <a id="27056" class="Symbol">→</a> <a id="27058" class="Symbol">{</a><a id="27059" href="2--Paths-and-Identifications.2-1--Paths.html#27059" class="Bound">a-₀</a> <a id="27063" class="Symbol">:</a> <a id="27065" href="Library.Prelude.html#1916" class="Function">Path</a> <a id="27070" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="27072" href="2--Paths-and-Identifications.2-1--Paths.html#26978" class="Bound">a₀₀</a> <a id="27076" href="2--Paths-and-Identifications.2-1--Paths.html#26986" class="Bound">a₁₀</a><a id="27079" class="Symbol">}</a>
  <a id="27083" class="Symbol">→</a> <a id="27085" class="Symbol">{</a><a id="27086" href="2--Paths-and-Identifications.2-1--Paths.html#27086" class="Bound">a-₁</a> <a id="27090" class="Symbol">:</a> <a id="27092" href="Library.Prelude.html#1916" class="Function">Path</a> <a id="27097" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="27099" href="2--Paths-and-Identifications.2-1--Paths.html#26982" class="Bound">a₀₁</a> <a id="27103" href="2--Paths-and-Identifications.2-1--Paths.html#26990" class="Bound">a₁₁</a><a id="27106" class="Symbol">}</a>
  <a id="27110" class="Symbol">→</a> <a id="27112" href="2--Paths-and-Identifications.2-1--Paths.html#24427" class="Function">Square</a> <a id="27119" href="2--Paths-and-Identifications.2-1--Paths.html#27005" class="Bound">a₀-</a> <a id="27123" href="2--Paths-and-Identifications.2-1--Paths.html#27032" class="Bound">a₁-</a> <a id="27127" href="2--Paths-and-Identifications.2-1--Paths.html#27059" class="Bound">a-₀</a> <a id="27131" href="2--Paths-and-Identifications.2-1--Paths.html#27086" class="Bound">a-₁</a>
  <a id="27137" class="Symbol">→</a> <a id="27139" href="2--Paths-and-Identifications.2-1--Paths.html#24427" class="Function">Square</a> <a id="27146" href="2--Paths-and-Identifications.2-1--Paths.html#27059" class="Bound">a-₀</a> <a id="27150" href="2--Paths-and-Identifications.2-1--Paths.html#27086" class="Bound">a-₁</a> <a id="27154" href="2--Paths-and-Identifications.2-1--Paths.html#27005" class="Bound">a₀-</a> <a id="27158" href="2--Paths-and-Identifications.2-1--Paths.html#27032" class="Bound">a₁-</a>
<a id="27162" class="Comment">-- Exercise:</a>
<a id="27175" class="Comment">-- flipSquare s = {!!}</a>
</pre>
<p>Once you’ve figured this out, try to define a similar function
<code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#27503" class="Function">flipSquareP</a></code>, where the type now varies over the square. Here,
the trick is not so much the definition itself — it will be the same
as <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#26964" class="Function">flipSquare</a></code> — but rather the type.</p>
<pre class="Agda"><a id="flipSquareP"></a><a id="27503" href="2--Paths-and-Identifications.2-1--Paths.html#27503" class="Function">flipSquareP</a> <a id="27515" class="Symbol">:</a> 
  <a id="27520" class="Symbol">(</a><a id="27521" href="2--Paths-and-Identifications.2-1--Paths.html#27521" class="Bound">A</a> <a id="27523" class="Symbol">:</a> <a id="27525" href="Library.Primitive.html#1675" class="Datatype">I</a> <a id="27527" class="Symbol">→</a> <a id="27529" href="Library.Primitive.html#1675" class="Datatype">I</a> <a id="27531" class="Symbol">→</a> <a id="27533" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="27538" href="2--Paths-and-Identifications.2-1--Paths.html#2972" class="Generalizable">ℓ</a><a id="27539" class="Symbol">)</a>
  <a id="27543" class="Symbol">{</a><a id="27544" href="2--Paths-and-Identifications.2-1--Paths.html#27544" class="Bound">a₀₀</a> <a id="27548" class="Symbol">:</a> <a id="27550" href="2--Paths-and-Identifications.2-1--Paths.html#27521" class="Bound">A</a> <a id="27552" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a> <a id="27555" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="27557" class="Symbol">}</a> <a id="27559" class="Symbol">{</a><a id="27560" href="2--Paths-and-Identifications.2-1--Paths.html#27560" class="Bound">a₀₁</a> <a id="27564" class="Symbol">:</a> <a id="27566" href="2--Paths-and-Identifications.2-1--Paths.html#27521" class="Bound">A</a> <a id="27568" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a> <a id="27571" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="27573" class="Symbol">}</a> <a id="27575" class="Symbol">{</a><a id="27576" href="2--Paths-and-Identifications.2-1--Paths.html#27576" class="Bound">a₁₀</a> <a id="27580" class="Symbol">:</a> <a id="27582" href="2--Paths-and-Identifications.2-1--Paths.html#27521" class="Bound">A</a> <a id="27584" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a> <a id="27587" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="27589" class="Symbol">}</a> <a id="27591" class="Symbol">{</a><a id="27592" href="2--Paths-and-Identifications.2-1--Paths.html#27592" class="Bound">a₁₁</a> <a id="27596" class="Symbol">:</a> <a id="27598" href="2--Paths-and-Identifications.2-1--Paths.html#27521" class="Bound">A</a> <a id="27600" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a> <a id="27603" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="27605" class="Symbol">}</a>
  <a id="27609" class="Symbol">{</a><a id="27610" href="2--Paths-and-Identifications.2-1--Paths.html#27610" class="Bound">a₀-</a> <a id="27614" class="Symbol">:</a> <a id="27616" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="27622" class="Symbol">(λ</a> <a id="27625" href="2--Paths-and-Identifications.2-1--Paths.html#27625" class="Bound">j</a> <a id="27627" class="Symbol">→</a> <a id="27629" href="2--Paths-and-Identifications.2-1--Paths.html#27521" class="Bound">A</a> <a id="27631" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a> <a id="27634" href="2--Paths-and-Identifications.2-1--Paths.html#27625" class="Bound">j</a><a id="27635" class="Symbol">)</a> <a id="27637" href="2--Paths-and-Identifications.2-1--Paths.html#27544" class="Bound">a₀₀</a> <a id="27641" href="2--Paths-and-Identifications.2-1--Paths.html#27560" class="Bound">a₀₁</a><a id="27644" class="Symbol">}</a>
  <a id="27648" class="Symbol">{</a><a id="27649" href="2--Paths-and-Identifications.2-1--Paths.html#27649" class="Bound">a₁-</a> <a id="27653" class="Symbol">:</a> <a id="27655" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="27661" class="Symbol">(λ</a> <a id="27664" href="2--Paths-and-Identifications.2-1--Paths.html#27664" class="Bound">j</a> <a id="27666" class="Symbol">→</a> <a id="27668" href="2--Paths-and-Identifications.2-1--Paths.html#27521" class="Bound">A</a> <a id="27670" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a> <a id="27673" href="2--Paths-and-Identifications.2-1--Paths.html#27664" class="Bound">j</a><a id="27674" class="Symbol">)</a> <a id="27676" href="2--Paths-and-Identifications.2-1--Paths.html#27576" class="Bound">a₁₀</a> <a id="27680" href="2--Paths-and-Identifications.2-1--Paths.html#27592" class="Bound">a₁₁</a><a id="27683" class="Symbol">}</a>
  <a id="27687" class="Symbol">{</a><a id="27688" href="2--Paths-and-Identifications.2-1--Paths.html#27688" class="Bound">a-₀</a> <a id="27692" class="Symbol">:</a> <a id="27694" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="27700" class="Symbol">(λ</a> <a id="27703" href="2--Paths-and-Identifications.2-1--Paths.html#27703" class="Bound">i</a> <a id="27705" class="Symbol">→</a> <a id="27707" href="2--Paths-and-Identifications.2-1--Paths.html#27521" class="Bound">A</a> <a id="27709" href="2--Paths-and-Identifications.2-1--Paths.html#27703" class="Bound">i</a> <a id="27711" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="27713" class="Symbol">)</a> <a id="27715" href="2--Paths-and-Identifications.2-1--Paths.html#27544" class="Bound">a₀₀</a> <a id="27719" href="2--Paths-and-Identifications.2-1--Paths.html#27576" class="Bound">a₁₀</a><a id="27722" class="Symbol">}</a>
  <a id="27726" class="Symbol">{</a><a id="27727" href="2--Paths-and-Identifications.2-1--Paths.html#27727" class="Bound">a-₁</a> <a id="27731" class="Symbol">:</a> <a id="27733" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="27739" class="Symbol">(λ</a> <a id="27742" href="2--Paths-and-Identifications.2-1--Paths.html#27742" class="Bound">i</a> <a id="27744" class="Symbol">→</a> <a id="27746" href="2--Paths-and-Identifications.2-1--Paths.html#27521" class="Bound">A</a> <a id="27748" href="2--Paths-and-Identifications.2-1--Paths.html#27742" class="Bound">i</a> <a id="27750" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="27752" class="Symbol">)</a> <a id="27754" href="2--Paths-and-Identifications.2-1--Paths.html#27560" class="Bound">a₀₁</a> <a id="27758" href="2--Paths-and-Identifications.2-1--Paths.html#27592" class="Bound">a₁₁</a><a id="27761" class="Symbol">}</a>
  <a id="27765" class="Comment">-- Exercise:</a>
  <a id="27780" class="Comment">-- → SquareP {!!} a₀- a₁- a-₀ a-₁</a>
  <a id="27816" class="Comment">-- → SquareP {!!} a-₀ a-₁ a₀- a₁-</a>

<a id="27981" href="2--Paths-and-Identifications.2-1--Paths.html#27503" class="Function">flipSquareP</a> <a id="27993" href="2--Paths-and-Identifications.2-1--Paths.html#27993" class="Bound">A</a> <a id="27995" href="2--Paths-and-Identifications.2-1--Paths.html#27995" class="Bound">s</a> <a id="27997" class="Symbol">=</a> <a id="27999" class="Symbol">λ</a> <a id="28001" href="2--Paths-and-Identifications.2-1--Paths.html#28001" class="Bound">i</a> <a id="28003" href="2--Paths-and-Identifications.2-1--Paths.html#28003" class="Bound">j</a> <a id="28005" class="Symbol">→</a> <a id="28007" href="2--Paths-and-Identifications.2-1--Paths.html#27995" class="Bound">s</a> <a id="28009" href="2--Paths-and-Identifications.2-1--Paths.html#28003" class="Bound">j</a> <a id="28011" href="2--Paths-and-Identifications.2-1--Paths.html#28001" class="Bound">i</a>
</pre>
<p>Any homotopy between functions is automatically “natural”, in the
following sense. Say we have a homotopy between <code>f</code> and <code>g</code>, that is,
a function <code>H : (x : A) → (f x ≡ g x)</code>. If we have a path <code>p : x ≡ y</code>
in <code>A</code>, then there are two ways we could get from <code>f x</code> to <code>g y</code>: the
two ways of going around the following square:</p>
<pre><code>            H y
      f y — — — &gt; g y
       ^           ^             ^
ap f p |           | ap g p    j |
       |           |             ∙ — &gt;
      f x — — — &gt; g x              i
            H x
</code></pre>
<p>mvrnote: illustration</p>
<p>It is not hard to produce a square that shows these are in fact equal,
as paths in <code>B</code>:</p>
<pre class="Agda"><a id="homotopy-natural"></a><a id="28687" href="2--Paths-and-Identifications.2-1--Paths.html#28687" class="Function">homotopy-natural</a> <a id="28704" class="Symbol">:</a> <a id="28706" class="Symbol">{</a><a id="28707" href="2--Paths-and-Identifications.2-1--Paths.html#28707" class="Bound">f</a> <a id="28709" href="2--Paths-and-Identifications.2-1--Paths.html#28709" class="Bound">g</a> <a id="28711" class="Symbol">:</a> <a id="28713" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="28715" class="Symbol">→</a> <a id="28717" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="28718" class="Symbol">}</a>
  <a id="28722" class="Symbol">→</a> <a id="28724" class="Symbol">(</a><a id="28725" href="2--Paths-and-Identifications.2-1--Paths.html#28725" class="Bound">H</a> <a id="28727" class="Symbol">:</a> <a id="28729" class="Symbol">(</a><a id="28730" href="2--Paths-and-Identifications.2-1--Paths.html#28730" class="Bound">x</a> <a id="28732" class="Symbol">:</a> <a id="28734" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a><a id="28735" class="Symbol">)</a> <a id="28737" class="Symbol">→</a> <a id="28739" class="Symbol">(</a><a id="28740" href="2--Paths-and-Identifications.2-1--Paths.html#28707" class="Bound">f</a> <a id="28742" href="2--Paths-and-Identifications.2-1--Paths.html#28730" class="Bound">x</a> <a id="28744" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="28746" href="2--Paths-and-Identifications.2-1--Paths.html#28709" class="Bound">g</a> <a id="28748" href="2--Paths-and-Identifications.2-1--Paths.html#28730" class="Bound">x</a><a id="28749" class="Symbol">))</a>
  <a id="28754" class="Symbol">→</a> <a id="28756" class="Symbol">{</a><a id="28757" href="2--Paths-and-Identifications.2-1--Paths.html#28757" class="Bound">x</a> <a id="28759" href="2--Paths-and-Identifications.2-1--Paths.html#28759" class="Bound">y</a> <a id="28761" class="Symbol">:</a> <a id="28763" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a><a id="28764" class="Symbol">}</a>
  <a id="28768" class="Symbol">→</a> <a id="28770" class="Symbol">(</a><a id="28771" href="2--Paths-and-Identifications.2-1--Paths.html#28771" class="Bound">p</a> <a id="28773" class="Symbol">:</a> <a id="28775" href="2--Paths-and-Identifications.2-1--Paths.html#28757" class="Bound">x</a> <a id="28777" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="28779" href="2--Paths-and-Identifications.2-1--Paths.html#28759" class="Bound">y</a><a id="28780" class="Symbol">)</a>
  <a id="28784" class="Symbol">→</a> <a id="28786" href="2--Paths-and-Identifications.2-1--Paths.html#24427" class="Function">Square</a> <a id="28793" class="Symbol">(</a><a id="28794" href="2--Paths-and-Identifications.2-1--Paths.html#17691" class="Function">ap</a> <a id="28797" href="2--Paths-and-Identifications.2-1--Paths.html#28707" class="Bound">f</a> <a id="28799" href="2--Paths-and-Identifications.2-1--Paths.html#28771" class="Bound">p</a><a id="28800" class="Symbol">)</a> <a id="28802" class="Symbol">(</a><a id="28803" href="2--Paths-and-Identifications.2-1--Paths.html#17691" class="Function">ap</a> <a id="28806" href="2--Paths-and-Identifications.2-1--Paths.html#28709" class="Bound">g</a> <a id="28808" href="2--Paths-and-Identifications.2-1--Paths.html#28771" class="Bound">p</a><a id="28809" class="Symbol">)</a> <a id="28811" class="Symbol">(</a><a id="28812" href="2--Paths-and-Identifications.2-1--Paths.html#28725" class="Bound">H</a> <a id="28814" href="2--Paths-and-Identifications.2-1--Paths.html#28757" class="Bound">x</a><a id="28815" class="Symbol">)</a> <a id="28817" class="Symbol">(</a><a id="28818" href="2--Paths-and-Identifications.2-1--Paths.html#28725" class="Bound">H</a> <a id="28820" href="2--Paths-and-Identifications.2-1--Paths.html#28759" class="Bound">y</a><a id="28821" class="Symbol">)</a>
<a id="28823" class="Comment">-- Exercise:</a>
<a id="28836" class="Comment">-- homotopy-natural H p k i = {!!}</a>
</pre>
<p>mvnrote: delete this?
And this even works in higher dimensions. We could define a “<code>Cube</code>”
type to use here, but as a one-off just writing the <code class="Agda"><a href="Library.Primitive.html#2174" class="Postulate">PathP</a></code> manually
will do.</p>
<pre class="Agda"><a id="homotopy-natural-cube"></a><a id="29116" href="2--Paths-and-Identifications.2-1--Paths.html#29116" class="Function">homotopy-natural-cube</a> <a id="29138" class="Symbol">:</a> <a id="29140" class="Symbol">{</a><a id="29141" href="2--Paths-and-Identifications.2-1--Paths.html#29141" class="Bound">f</a> <a id="29143" href="2--Paths-and-Identifications.2-1--Paths.html#29143" class="Bound">g</a> <a id="29145" class="Symbol">:</a> <a id="29147" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a> <a id="29149" class="Symbol">→</a> <a id="29151" href="2--Paths-and-Identifications.2-1--Paths.html#2997" class="Generalizable">B</a><a id="29152" class="Symbol">}</a>
  <a id="29156" class="Symbol">→</a> <a id="29158" class="Symbol">(</a><a id="29159" href="2--Paths-and-Identifications.2-1--Paths.html#29159" class="Bound">H</a> <a id="29161" class="Symbol">:</a> <a id="29163" class="Symbol">(</a><a id="29164" href="2--Paths-and-Identifications.2-1--Paths.html#29164" class="Bound">x</a> <a id="29166" class="Symbol">:</a> <a id="29168" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a><a id="29169" class="Symbol">)</a> <a id="29171" class="Symbol">→</a> <a id="29173" class="Symbol">(</a><a id="29174" href="2--Paths-and-Identifications.2-1--Paths.html#29141" class="Bound">f</a> <a id="29176" href="2--Paths-and-Identifications.2-1--Paths.html#29164" class="Bound">x</a> <a id="29178" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="29180" href="2--Paths-and-Identifications.2-1--Paths.html#29143" class="Bound">g</a> <a id="29182" href="2--Paths-and-Identifications.2-1--Paths.html#29164" class="Bound">x</a><a id="29183" class="Symbol">))</a>
  <a id="29188" class="Symbol">→</a> <a id="29190" class="Symbol">{</a><a id="29191" href="2--Paths-and-Identifications.2-1--Paths.html#29191" class="Bound">a</a> <a id="29193" href="2--Paths-and-Identifications.2-1--Paths.html#29193" class="Bound">b</a> <a id="29195" href="2--Paths-and-Identifications.2-1--Paths.html#29195" class="Bound">c</a> <a id="29197" href="2--Paths-and-Identifications.2-1--Paths.html#29197" class="Bound">d</a> <a id="29199" class="Symbol">:</a> <a id="29201" href="2--Paths-and-Identifications.2-1--Paths.html#2995" class="Generalizable">A</a><a id="29202" class="Symbol">}</a>
  <a id="29206" class="Symbol">→</a> <a id="29208" class="Symbol">{</a><a id="29209" href="2--Paths-and-Identifications.2-1--Paths.html#29209" class="Bound">r</a> <a id="29211" class="Symbol">:</a> <a id="29213" href="2--Paths-and-Identifications.2-1--Paths.html#29191" class="Bound">a</a> <a id="29215" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="29217" href="2--Paths-and-Identifications.2-1--Paths.html#29195" class="Bound">c</a><a id="29218" class="Symbol">}</a> <a id="29220" class="Symbol">{</a><a id="29221" href="2--Paths-and-Identifications.2-1--Paths.html#29221" class="Bound">s</a> <a id="29223" class="Symbol">:</a> <a id="29225" href="2--Paths-and-Identifications.2-1--Paths.html#29193" class="Bound">b</a> <a id="29227" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="29229" href="2--Paths-and-Identifications.2-1--Paths.html#29197" class="Bound">d</a><a id="29230" class="Symbol">}</a>
  <a id="29234" class="Symbol">→</a> <a id="29236" class="Symbol">{</a><a id="29237" href="2--Paths-and-Identifications.2-1--Paths.html#29237" class="Bound">t</a> <a id="29239" class="Symbol">:</a> <a id="29241" href="2--Paths-and-Identifications.2-1--Paths.html#29191" class="Bound">a</a> <a id="29243" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="29245" href="2--Paths-and-Identifications.2-1--Paths.html#29193" class="Bound">b</a><a id="29246" class="Symbol">}</a> <a id="29248" class="Symbol">{</a><a id="29249" href="2--Paths-and-Identifications.2-1--Paths.html#29249" class="Bound">u</a> <a id="29251" class="Symbol">:</a> <a id="29253" href="2--Paths-and-Identifications.2-1--Paths.html#29195" class="Bound">c</a> <a id="29255" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="29257" href="2--Paths-and-Identifications.2-1--Paths.html#29197" class="Bound">d</a><a id="29258" class="Symbol">}</a>
  <a id="29262" class="Symbol">→</a> <a id="29264" class="Symbol">(</a><a id="29265" href="2--Paths-and-Identifications.2-1--Paths.html#29265" class="Bound">sq</a> <a id="29268" class="Symbol">:</a> <a id="29270" href="2--Paths-and-Identifications.2-1--Paths.html#24427" class="Function">Square</a> <a id="29277" href="2--Paths-and-Identifications.2-1--Paths.html#29237" class="Bound">t</a> <a id="29279" href="2--Paths-and-Identifications.2-1--Paths.html#29249" class="Bound">u</a> <a id="29281" href="2--Paths-and-Identifications.2-1--Paths.html#29209" class="Bound">r</a> <a id="29283" href="2--Paths-and-Identifications.2-1--Paths.html#29221" class="Bound">s</a><a id="29284" class="Symbol">)</a>
  <a id="29288" class="Symbol">→</a> <a id="29290" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="29296" class="Symbol">(λ</a> <a id="29299" href="2--Paths-and-Identifications.2-1--Paths.html#29299" class="Bound">k</a> <a id="29301" class="Symbol">→</a> <a id="29303" href="2--Paths-and-Identifications.2-1--Paths.html#24427" class="Function">Square</a> <a id="29310" class="Symbol">(</a><a id="29311" href="2--Paths-and-Identifications.2-1--Paths.html#28687" class="Function">homotopy-natural</a> <a id="29328" href="2--Paths-and-Identifications.2-1--Paths.html#29159" class="Bound">H</a> <a id="29330" href="2--Paths-and-Identifications.2-1--Paths.html#29237" class="Bound">t</a> <a id="29332" href="2--Paths-and-Identifications.2-1--Paths.html#29299" class="Bound">k</a><a id="29333" class="Symbol">)</a> 
                        <a id="29360" class="Symbol">(</a><a id="29361" href="2--Paths-and-Identifications.2-1--Paths.html#28687" class="Function">homotopy-natural</a> <a id="29378" href="2--Paths-and-Identifications.2-1--Paths.html#29159" class="Bound">H</a> <a id="29380" href="2--Paths-and-Identifications.2-1--Paths.html#29249" class="Bound">u</a> <a id="29382" href="2--Paths-and-Identifications.2-1--Paths.html#29299" class="Bound">k</a><a id="29383" class="Symbol">)</a> 
                        <a id="29410" class="Symbol">(</a><a id="29411" href="2--Paths-and-Identifications.2-1--Paths.html#28687" class="Function">homotopy-natural</a> <a id="29428" href="2--Paths-and-Identifications.2-1--Paths.html#29159" class="Bound">H</a> <a id="29430" href="2--Paths-and-Identifications.2-1--Paths.html#29209" class="Bound">r</a> <a id="29432" href="2--Paths-and-Identifications.2-1--Paths.html#29299" class="Bound">k</a><a id="29433" class="Symbol">)</a> 
                        <a id="29460" class="Symbol">(</a><a id="29461" href="2--Paths-and-Identifications.2-1--Paths.html#28687" class="Function">homotopy-natural</a> <a id="29478" href="2--Paths-and-Identifications.2-1--Paths.html#29159" class="Bound">H</a> <a id="29480" href="2--Paths-and-Identifications.2-1--Paths.html#29221" class="Bound">s</a> <a id="29482" href="2--Paths-and-Identifications.2-1--Paths.html#29299" class="Bound">k</a><a id="29483" class="Symbol">))</a>
    <a id="29490" class="Symbol">(</a><a id="29491" href="2--Paths-and-Identifications.2-1--Paths.html#26188" class="Function">ap-Square</a> <a id="29501" href="2--Paths-and-Identifications.2-1--Paths.html#29141" class="Bound">f</a> <a id="29503" href="2--Paths-and-Identifications.2-1--Paths.html#29265" class="Bound">sq</a><a id="29505" class="Symbol">)</a> 
    <a id="29512" class="Symbol">(</a><a id="29513" href="2--Paths-and-Identifications.2-1--Paths.html#26188" class="Function">ap-Square</a> <a id="29523" href="2--Paths-and-Identifications.2-1--Paths.html#29143" class="Bound">g</a> <a id="29525" href="2--Paths-and-Identifications.2-1--Paths.html#29265" class="Bound">sq</a><a id="29527" class="Symbol">)</a>
<a id="29529" href="2--Paths-and-Identifications.2-1--Paths.html#29116" class="Function">homotopy-natural-cube</a> <a id="29551" href="2--Paths-and-Identifications.2-1--Paths.html#29551" class="Bound">H</a> <a id="29553" href="2--Paths-and-Identifications.2-1--Paths.html#29553" class="Bound">sq</a> <a id="29556" href="2--Paths-and-Identifications.2-1--Paths.html#29556" class="Bound">k</a> <a id="29558" href="2--Paths-and-Identifications.2-1--Paths.html#29558" class="Bound">i</a> <a id="29560" href="2--Paths-and-Identifications.2-1--Paths.html#29560" class="Bound">j</a> <a id="29562" class="Symbol">=</a> <a id="29564" href="2--Paths-and-Identifications.2-1--Paths.html#29551" class="Bound">H</a> <a id="29566" class="Symbol">(</a><a id="29567" href="2--Paths-and-Identifications.2-1--Paths.html#29553" class="Bound">sq</a> <a id="29570" href="2--Paths-and-Identifications.2-1--Paths.html#29558" class="Bound">i</a> <a id="29572" href="2--Paths-and-Identifications.2-1--Paths.html#29560" class="Bound">j</a><a id="29573" class="Symbol">)</a> <a id="29575" href="2--Paths-and-Identifications.2-1--Paths.html#29556" class="Bound">k</a>
</pre>
<h2 id="higher-path-constructors"><a class="header" href="#higher-path-constructors">Higher Path Constructors</a></h2>
<p>Inductive types can also contain path-of-path constructors. Here’s a
nice example: the torus, which consists a basepoint, two circles
connected to that basepoint, and a square region with sides as
follows:</p>
<pre><code>         line1
      pt — — — &gt; pt
      ^           ^
      |           |                 ^
line2 |           | line2         j |
      |           |                 ∙ — &gt;
      pt — — — &gt; pt                   i
         line1
</code></pre>
<p>mvrnote: this will really need some pictures</p>
<pre class="Agda"><a id="30130" class="Keyword">data</a> <a id="Torus"></a><a id="30135" href="2--Paths-and-Identifications.2-1--Paths.html#30135" class="Datatype">Torus</a> <a id="30141" class="Symbol">:</a> <a id="30143" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="30148" class="Keyword">where</a>
  <a id="Torus.torus-base"></a><a id="30156" href="2--Paths-and-Identifications.2-1--Paths.html#30156" class="InductiveConstructor">torus-base</a>  <a id="30168" class="Symbol">:</a> <a id="30170" href="2--Paths-and-Identifications.2-1--Paths.html#30135" class="Datatype">Torus</a>
  <a id="Torus.torus-loop1"></a><a id="30178" href="2--Paths-and-Identifications.2-1--Paths.html#30178" class="InductiveConstructor">torus-loop1</a>  <a id="30191" class="Symbol">:</a> <a id="30193" href="2--Paths-and-Identifications.2-1--Paths.html#30156" class="InductiveConstructor">torus-base</a> <a id="30204" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="30206" href="2--Paths-and-Identifications.2-1--Paths.html#30156" class="InductiveConstructor">torus-base</a>
  <a id="Torus.torus-loop2"></a><a id="30219" href="2--Paths-and-Identifications.2-1--Paths.html#30219" class="InductiveConstructor">torus-loop2</a>  <a id="30232" class="Symbol">:</a> <a id="30234" href="2--Paths-and-Identifications.2-1--Paths.html#30156" class="InductiveConstructor">torus-base</a> <a id="30245" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="30247" href="2--Paths-and-Identifications.2-1--Paths.html#30156" class="InductiveConstructor">torus-base</a>
  <a id="Torus.torus-square"></a><a id="30260" href="2--Paths-and-Identifications.2-1--Paths.html#30260" class="InductiveConstructor">torus-square</a> <a id="30273" class="Symbol">:</a> <a id="30275" href="2--Paths-and-Identifications.2-1--Paths.html#24427" class="Function">Square</a> <a id="30282" href="2--Paths-and-Identifications.2-1--Paths.html#30219" class="InductiveConstructor">torus-loop2</a> <a id="30294" href="2--Paths-and-Identifications.2-1--Paths.html#30219" class="InductiveConstructor">torus-loop2</a> <a id="30306" href="2--Paths-and-Identifications.2-1--Paths.html#30178" class="InductiveConstructor">torus-loop1</a> <a id="30318" href="2--Paths-and-Identifications.2-1--Paths.html#30178" class="InductiveConstructor">torus-loop1</a>
</pre>
<p>Topologically, the torus is equal to the cartesian product of two
circles. We can prove this directly! mvrnote: refer to the picture</p>
<pre class="Agda"><a id="Torus→S¹×S¹"></a><a id="30473" href="2--Paths-and-Identifications.2-1--Paths.html#30473" class="Function">Torus→S¹×S¹</a> <a id="30485" class="Symbol">:</a> <a id="30487" href="2--Paths-and-Identifications.2-1--Paths.html#30135" class="Datatype">Torus</a> <a id="30493" class="Symbol">→</a> <a id="30495" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a> <a id="30498" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="30500" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a>
<a id="30503" class="Comment">-- Exercise:</a>
<a id="30516" class="Comment">-- Torus→S¹×S¹ t = {!!}</a>

<a id="S¹×S¹→Torus"></a><a id="30853" href="2--Paths-and-Identifications.2-1--Paths.html#30853" class="Function">S¹×S¹→Torus</a> <a id="30865" class="Symbol">:</a> <a id="30867" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a> <a id="30870" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="30872" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a> <a id="30875" class="Symbol">→</a> <a id="30877" href="2--Paths-and-Identifications.2-1--Paths.html#30135" class="Datatype">Torus</a>
<a id="30883" class="Comment">-- Exercise:</a>
<a id="30896" class="Comment">-- S¹×S¹→Torus c = {!!}</a>
</pre>
<h2 id="references-and-further-reading"><a class="header" href="#references-and-further-reading">References and Further Reading</a></h2>

                  </main>
                  <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                  </div>
                </div>
            </div>
        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>


    </div>
    </body>
</html>
