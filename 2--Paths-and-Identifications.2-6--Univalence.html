<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2.6: Univalence - Introduction to Homotopy Type Theory in Cubical Agda</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/Agda.css">
        <link rel="stylesheet" href="theme/css/Agda-highlight.css">
        <link rel="stylesheet" href="theme/pagetoc.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="chapter-item affix "><a href="INSTALLING_AGDA.html">Installing Agda</a></li><li class="chapter-item affix "><a href="USING_AGDA.html">Using Agda</a></li><li class="chapter-item affix "><li class="part-title">Type Theory</li><li class="chapter-item "><a href="1--Type-Theory.1-1--Types-and-Functions.html">1.1: Types and Functions</a></li><li class="chapter-item "><a href="1--Type-Theory.1-2--Inductive-Types.html">1.2: Inductive Types</a></li><li class="chapter-item "><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html">1.3: Universes and More Inductive Types</a></li><li class="chapter-item "><a href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html">1.4: Record Types and Copatterns</a></li><li class="chapter-item "><a href="1--Type-Theory.1-5--Propositions-as-Types.html">1.5: Propositions as Types</a></li><li class="chapter-item affix "><li class="part-title">Paths and Identifications</li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-1--Paths.html">2.1: Paths</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html">2.2: Equivalences and Path Algebra</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html">2.3: Substitution and J</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html">2.4: Composition and Filling</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-5--Transport.html">2.5: Transport</a></li><li class="chapter-item expanded "><a href="2--Paths-and-Identifications.2-6--Univalence.html" class="active">2.6: Univalence</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-7--Propositions.html">2.7: Propositions</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-8--Sets-and-Higher-Types.html">2.8: Sets and Higher Types</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-9--Contractible-Maps.html">2.9: Contractible Maps</a></li><li class="chapter-item affix "><li class="part-title">Topics</li><li class="chapter-item "><a href="3--Topics.3-1--Structure-Identity-Principle.html">3.1: The Structure Identity Principle</a></li><li class="chapter-item "><a href="3--Topics.3-2--Modalities.html">3.2: Modalities</a></li><li class="chapter-item "><a href="3--Topics.3-3--Constructive-Logic.html">3.3: Constructive Logic</a></li><li class="chapter-item affix "><li class="part-title">Behind-the-Scenes</li><li class="chapter-item "><a href="Library.Primitive.html">Primitives</a></li><li class="chapter-item "><a href="Library.Prelude.html">Prelude</a></li><li class="chapter-item "><a href="Library.Univalence.html">Univalence</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="UNICODE_DICTIONARY.html">Unicode Dictionary</a></li><li class="chapter-item affix "><a href="ACKNOWLEDGEMENTS.html">Acknowledgements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <!-- <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li> -->
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Homotopy Type Theory in Cubical Agda</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/CQTS/introduction-to-cubical" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                  <main>
                    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<!--
<pre class="Agda"><a id="10" class="Keyword">module</a> <a id="17" href="2--Paths-and-Identifications.2-6--Univalence.html" class="Module">2--Paths-and-Identifications.2-6--Univalence</a> <a id="62" class="Keyword">where</a>

<a id="69" class="Keyword">open</a> <a id="74" class="Keyword">import</a> <a id="81" href="Library.Prelude.html" class="Module">Library.Prelude</a>
<a id="97" class="Keyword">open</a> <a id="102" class="Keyword">import</a> <a id="109" href="1--Type-Theory.1-2--Inductive-Types.html" class="Module">1--Type-Theory.1-2--Inductive-Types</a>
<a id="145" class="Keyword">open</a> <a id="150" class="Keyword">import</a> <a id="157" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html" class="Module">1--Type-Theory.1-3--Universes-and-More-Inductive-Types</a>
<a id="212" class="Keyword">open</a> <a id="217" class="Keyword">import</a> <a id="224" href="1--Type-Theory.1-5--Propositions-as-Types.html" class="Module">1--Type-Theory.1-5--Propositions-as-Types</a>
<a id="266" class="Keyword">open</a> <a id="271" class="Keyword">import</a> <a id="278" href="2--Paths-and-Identifications.2-1--Paths.html" class="Module">2--Paths-and-Identifications.2-1--Paths</a>
<a id="318" class="Keyword">open</a> <a id="323" class="Keyword">import</a> <a id="330" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html" class="Module">2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra</a>
<a id="394" class="Keyword">open</a> <a id="399" class="Keyword">import</a> <a id="406" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html" class="Module">2--Paths-and-Identifications.2-3--Substitution-and-J</a>
<a id="459" class="Keyword">open</a> <a id="464" class="Keyword">import</a> <a id="471" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html" class="Module">2--Paths-and-Identifications.2-4--Composition-and-Filling</a>
<a id="529" class="Keyword">open</a> <a id="534" class="Keyword">import</a> <a id="541" href="2--Paths-and-Identifications.2-5--Transport.html" class="Module">2--Paths-and-Identifications.2-5--Transport</a>
<a id="585" class="Keyword">open</a> <a id="590" class="Keyword">import</a> <a id="597" href="Library.Univalence.html" class="Module">Library.Univalence</a>

<a id="617" class="Keyword">private</a>
  <a id="627" class="Keyword">variable</a>
    <a id="640" href="2--Paths-and-Identifications.2-6--Univalence.html#640" class="Generalizable">ℓ</a> <a id="642" href="2--Paths-and-Identifications.2-6--Univalence.html#642" class="Generalizable">ℓ&#39;</a> <a id="645" href="2--Paths-and-Identifications.2-6--Univalence.html#645" class="Generalizable">ℓ&#39;&#39;</a> <a id="649" class="Symbol">:</a> <a id="651" href="Library.Primitive.html#1060" class="Postulate">Level</a>
    <a id="661" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="663" href="2--Paths-and-Identifications.2-6--Univalence.html#663" class="Generalizable">A&#39;</a> <a id="666" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a> <a id="668" href="2--Paths-and-Identifications.2-6--Univalence.html#668" class="Generalizable">B&#39;</a> <a id="671" href="2--Paths-and-Identifications.2-6--Univalence.html#671" class="Generalizable">C</a> <a id="673" class="Symbol">:</a> <a id="675" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="680" href="2--Paths-and-Identifications.2-6--Univalence.html#640" class="Generalizable">ℓ</a>
</pre>-->
<h1 id="lecture-2-6-univalence"><a class="header" href="#lecture-2-6-univalence">Lecture 2-6: Univalence</a></h1>
<p>We’ve spent a lot of time characterising paths in the various types we
have available. The one type we haven’t done this for is the universe
of types <code class="Agda"><a href="Library.Primitive.html#422" class="Primitive">Type</a></code>.</p>
<p>Transport turns any path into an equivalence, as we showed in
<code class="Agda"><a href="2--Paths-and-Identifications.2-5--Transport.html#5498" class="Function">path→equiv</a></code>. But can every equivalence be produced this way? The
<em>univalence principle</em> says yes, that <code class="Agda"><a href="2--Paths-and-Identifications.2-5--Transport.html#5498" class="Function">path→equiv</a></code> is itself an
equivalence, and so every equivalence of types <code>A ≃ B</code> can be turned
back into a path of types <code>A ≡ B</code>.</p>
<p>In the original versions of Homotopy Type Theory, the univalence
principle is simply asserted as an axiom.</p>
<pre><code>univalence-axiom : {A B : Type ℓ} → isEquiv (path→equiv {A = A} {B = B})
</code></pre>
<p>If this principle is provided as an unproven axiom rather than
something with a definition, constructions involving it can’t hope to
compute. For example, suppose we use this axiom to turn the
equivalence <code class="Agda"><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6906" class="Function">Bool≃RedOrBlue</a></code> into a path <code>Bool ≡ RedOrBlue</code>. If we
transport <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a></code> over this path, we would hope to get exactly
<code class="Agda"><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#2983" class="InductiveConstructor">red</a></code>, following the definition of the equivalence. But with the
above axiom, the transport expression is stuck and it has to be proven
manually that we indeed get <code class="Agda"><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#2983" class="InductiveConstructor">red</a></code>.</p>
<p>Cubical Type Theory’s central accomplishment is allowing the
univalence principle to compute in situations like this.</p>
<div class="info">
<p><span class="info-label">Aside:</span>
Really, the original univalence axiom is defined in a setting that
uses “identity types” mvrnote: link (defined as the
inductive type that has the <code class="Agda"><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#5445" class="Function">J</a></code> rule as its eliminator) as its
notion of equality, rather than the cubical path types we have been
using. But the spirit is the same.</p>
</div>
<h2 id="glue-types"><a class="header" href="#glue-types">Glue Types</a></h2>
<p>The feature of Cubical Type Theory needed for univalence is <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code>
types, a type constructor which has the following shape:</p>
<pre><code>Glue : (A : Type ℓ) {φ : I}
     → (Te : Partial φ (Σ[ T ∈ Type ℓ' ] T ≃ A))
     → Type ℓ'
</code></pre>
<p>The type constructor <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> takes a type <code>A</code>, a formula <code>φ</code>, and a
partial element <code>Te : Partial φ (Σ[ T ∈ Type ] (T ≃ A))</code> of types
equipped with an equivalence to <code>A</code> (defined only when <code>φ</code> is <code class="Agda"><a href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a></code>).</p>
<p>As usual, we should be thinking of ourselves in a context that already
has some interval variables in it, with <code>φ</code> a formula describing some
subcube.</p>
<p>Suppose we have an interval variable <code>i</code>, and let’s fix the formula
<code>φ</code> to be <code>φ = ∂ i</code>. We can depict an element of the partial type <code>Te : Partial (∂ i) (Σ[ T ∈ Type ℓ' ] T ≃ A)</code> as follows:</p>
<pre><code>             A i
     A i0  — — — &gt; A i1
       ^             ^                ^
Te i0  (             (  Te i1         )
       )             )                ∙ — &gt;
     T i0          T i1                 i
</code></pre>
<p>where the vertical squiggly lines are equivalences rather than paths.
The type <code>A</code> is defined everywhere along the dimension <code>i</code>, but the
type <code>T</code> is only defined when <code>φ</code> holds, so on the left and right
sides.</p>
<p>This picture a lot like the kind of thing we were <code class="Agda"><a href="Library.Prelude.html#650" class="Function">hcomp</a></code>ing over in
Lecture 2-X, except that it is open on the bottom rather than the top.
(This is a conventional choice — the equivalences go into <code>A</code>,
rather than out of it.)</p>
<p>A <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> type enable us to “cap off” this open box of types, giving us a . That
is, if <code>φ = ∂ i</code>, then <code>Glue A Te : Type</code> is the line of types living
<em>under</em> <code>A</code> in the capped off version of the above square.</p>
<p><code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> types come with some guarantees about how they compute in
special cases. Like <code class="Agda"><a href="Library.Prelude.html#650" class="Function">hcomp</a></code>, the line we get agrees with the partial
input anywhere the formula <code>φ</code> holds. In the above case, this means</p>
<p>∙ <code>Glue A Te</code> is <code>T i0</code> when <code>i = i0</code> and
∙ <code>Glue A Te</code> is <code>T i1</code> when <code>i = i1</code>.</p>
<p>For any element of <code>Glue A Te</code>, regardless of whether <code>φ</code> holds, we
can extract an underlying element of <code>A</code>. This operation is called
<code>unglue φ</code>, and has type <code>Glue A Te → A</code>. Because of the above
guarantees, if <code>φ</code> does in fact hold then the domain of this function
is equal to <code>T</code>. Luckily, in this situation we have access to an
equivalence <code>T ≃ A</code>, because <code>Te</code> is defined when <code>φ</code> holds, and this
equivalence provides the necessary function <code>T → A</code>.</p>
<p>To summarise, <code>Glue A Te</code> is a version of <code>A</code> that has the types <code>T</code>
glued on wherever <code>φ</code> holds, using the provided equivalences <code>Te</code> to
extract an element of <code>A</code> whenever asked.</p>
<p>The first and most important example of a <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> type gives us an
inverse to the <code class="Agda"><a href="2--Paths-and-Identifications.2-5--Transport.html#5498" class="Function">path→equiv</a></code> map, building a path out of an
equivalence of types.</p>
<pre><code>       B
  B — — — &gt; B
  ^         ^                         ^
e (         ( idEquiv                 )
  )         )                         ∙ — &gt;
  A         B                           i
</code></pre>
<pre class="Agda"><a id="ua"></a><a id="5276" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="5279" class="Symbol">:</a> <a id="5281" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="5283" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="5285" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a> <a id="5287" class="Symbol">→</a> <a id="5289" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="5291" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="5293" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a>
<a id="5295" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="5298" class="Symbol">{</a><a id="5299" class="Argument">A</a> <a id="5301" class="Symbol">=</a> <a id="5303" href="2--Paths-and-Identifications.2-6--Univalence.html#5303" class="Bound">A</a><a id="5304" class="Symbol">}</a> <a id="5306" class="Symbol">{</a><a id="5307" class="Argument">B</a> <a id="5309" class="Symbol">=</a> <a id="5311" href="2--Paths-and-Identifications.2-6--Univalence.html#5311" class="Bound">B</a><a id="5312" class="Symbol">}</a> <a id="5314" href="2--Paths-and-Identifications.2-6--Univalence.html#5314" class="Bound">e</a> <a id="5316" href="2--Paths-and-Identifications.2-6--Univalence.html#5316" class="Bound">i</a> <a id="5318" class="Symbol">=</a> <a id="5320" href="Library.Univalence.html#7163" class="Function">Glue</a> <a id="5325" href="2--Paths-and-Identifications.2-6--Univalence.html#5311" class="Bound">B</a> <a id="5327" class="Symbol">{</a><a id="5328" class="Argument">φ</a> <a id="5330" class="Symbol">=</a> <a id="5332" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#6524" class="Function">∂</a> <a id="5334" href="2--Paths-and-Identifications.2-6--Univalence.html#5316" class="Bound">i</a><a id="5335" class="Symbol">}</a>
  <a id="5339" class="Symbol">(λ</a> <a id="5342" class="Symbol">{</a> <a id="5344" class="Symbol">(</a><a id="5345" href="2--Paths-and-Identifications.2-6--Univalence.html#5316" class="Bound">i</a> <a id="5347" class="Symbol">=</a> <a id="5349" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="5351" class="Symbol">)</a> <a id="5353" class="Symbol">→</a> <a id="5355" class="Symbol">(</a><a id="5356" href="2--Paths-and-Identifications.2-6--Univalence.html#5303" class="Bound">A</a> <a id="5358" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="5360" href="2--Paths-and-Identifications.2-6--Univalence.html#5314" class="Bound">e</a><a id="5361" class="Symbol">)</a>
     <a id="5368" class="Symbol">;</a> <a id="5370" class="Symbol">(</a><a id="5371" href="2--Paths-and-Identifications.2-6--Univalence.html#5316" class="Bound">i</a> <a id="5373" class="Symbol">=</a> <a id="5375" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="5377" class="Symbol">)</a> <a id="5379" class="Symbol">→</a> <a id="5381" class="Symbol">(</a><a id="5382" href="2--Paths-and-Identifications.2-6--Univalence.html#5311" class="Bound">B</a> <a id="5384" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="5386" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#8989" class="Function">idEquiv</a> <a id="5394" href="2--Paths-and-Identifications.2-6--Univalence.html#5311" class="Bound">B</a><a id="5395" class="Symbol">)</a> <a id="5397" class="Symbol">})</a>
</pre>
<p>That is, we use <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> to produce a version of <code>B</code> along a line in
the <code>i</code> dimension, but when <code>i</code> is <code>i0</code>, we glue <code>A</code> on using the
equivalence.</p>
<p>So how do we produce elements of <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code>? Thankfully, we will almost
never have to do so manually, but here’s a place where it is useful:
converting between a path in <code>B</code> and a path-over <code>ua e</code> for some
equivalence.</p>
<pre class="Agda"><a id="Path→ua-PathP"></a><a id="5776" href="2--Paths-and-Identifications.2-6--Univalence.html#5776" class="Function">Path→ua-PathP</a> <a id="5790" class="Symbol">:</a> <a id="5792" class="Symbol">(</a><a id="5793" href="2--Paths-and-Identifications.2-6--Univalence.html#5793" class="Bound">e</a> <a id="5795" class="Symbol">:</a> <a id="5797" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="5799" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="5801" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="5802" class="Symbol">)</a> <a id="5804" class="Symbol">{</a><a id="5805" href="2--Paths-and-Identifications.2-6--Univalence.html#5805" class="Bound">x</a> <a id="5807" class="Symbol">:</a> <a id="5809" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a><a id="5810" class="Symbol">}</a> <a id="5812" class="Symbol">{</a><a id="5813" href="2--Paths-and-Identifications.2-6--Univalence.html#5813" class="Bound">y</a> <a id="5815" class="Symbol">:</a> <a id="5817" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="5818" class="Symbol">}</a>
  <a id="5822" class="Symbol">→</a> <a id="5824" href="2--Paths-and-Identifications.2-6--Univalence.html#5793" class="Bound">e</a> <a id="5826" class="Symbol">.</a><a id="5827" class="Field">map</a> <a id="5831" href="2--Paths-and-Identifications.2-6--Univalence.html#5805" class="Bound">x</a> <a id="5833" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="5835" href="2--Paths-and-Identifications.2-6--Univalence.html#5813" class="Bound">y</a>
  <a id="5839" class="Symbol">→</a> <a id="5841" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="5847" class="Symbol">(λ</a> <a id="5850" href="2--Paths-and-Identifications.2-6--Univalence.html#5850" class="Bound">i</a> <a id="5852" class="Symbol">→</a> <a id="5854" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="5857" href="2--Paths-and-Identifications.2-6--Univalence.html#5793" class="Bound">e</a> <a id="5859" href="2--Paths-and-Identifications.2-6--Univalence.html#5850" class="Bound">i</a><a id="5860" class="Symbol">)</a> <a id="5862" href="2--Paths-and-Identifications.2-6--Univalence.html#5805" class="Bound">x</a> <a id="5864" href="2--Paths-and-Identifications.2-6--Univalence.html#5813" class="Bound">y</a>
</pre>
<p>The <code class="Agda"><a href="Library.Univalence.html#7106" class="Primitive">glue</a></code> constructor takes two arguments: first, a partial element
of the partial type <code>T</code> that we used in the <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> type itself.
After all, if we happen to be lying somewhere that <code>φ</code> equals <code>i1</code>,
the <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> type is supposed to turn into exactly <code>T</code>, so we have to
explain which value of <code>T</code> the <code class="Agda"><a href="Library.Univalence.html#7106" class="Primitive">glue</a></code> is supposed to turn into.</p>
<p>The second argument is the value of <code>B</code> that will get used everywhere
that <code>φ</code> doesn’t hold. Agda will check that the two arguments line up
with the equivalences you provided to the <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> type.</p>
<p>Annotating the above diagram, the values we are providing are</p>
<pre><code>           p
</code></pre>
<p>(e x) : B — — — &gt; y : B
^             ^                  ^
e (             ( idEquiv          )
)             )                  ∙ — &gt;
x : A         y : B                 i</p>
<pre class="Agda"><a id="6704" href="2--Paths-and-Identifications.2-6--Univalence.html#5776" class="Function">Path→ua-PathP</a> <a id="6718" href="2--Paths-and-Identifications.2-6--Univalence.html#6718" class="Bound">e</a> <a id="6720" class="Symbol">{</a><a id="6721" class="Argument">x</a> <a id="6723" class="Symbol">=</a> <a id="6725" href="2--Paths-and-Identifications.2-6--Univalence.html#6725" class="Bound">x</a><a id="6726" class="Symbol">}</a> <a id="6728" class="Symbol">{</a><a id="6729" class="Argument">y</a> <a id="6731" class="Symbol">=</a> <a id="6733" href="2--Paths-and-Identifications.2-6--Univalence.html#6733" class="Bound">y</a><a id="6734" class="Symbol">}</a> <a id="6736" href="2--Paths-and-Identifications.2-6--Univalence.html#6736" class="Bound">p</a> <a id="6738" href="2--Paths-and-Identifications.2-6--Univalence.html#6738" class="Bound">i</a> <a id="6740" class="Symbol">=</a> <a id="6742" href="Library.Univalence.html#7106" class="Primitive">glue</a> <a id="6747" class="Symbol">{</a><a id="6748" class="Argument">φ</a> <a id="6750" class="Symbol">=</a> <a id="6752" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#6524" class="Function">∂</a> <a id="6754" href="2--Paths-and-Identifications.2-6--Univalence.html#6738" class="Bound">i</a><a id="6755" class="Symbol">}</a>
  <a id="6759" class="Symbol">(λ</a> <a id="6762" class="Symbol">{</a> <a id="6764" class="Symbol">(</a><a id="6765" href="2--Paths-and-Identifications.2-6--Univalence.html#6738" class="Bound">i</a> <a id="6767" class="Symbol">=</a> <a id="6769" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="6771" class="Symbol">)</a> <a id="6773" class="Symbol">→</a> <a id="6775" href="2--Paths-and-Identifications.2-6--Univalence.html#6725" class="Bound">x</a> <a id="6777" class="Symbol">;</a>
       <a id="6786" class="Symbol">(</a><a id="6787" href="2--Paths-and-Identifications.2-6--Univalence.html#6738" class="Bound">i</a> <a id="6789" class="Symbol">=</a> <a id="6791" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="6793" class="Symbol">)</a> <a id="6795" class="Symbol">→</a> <a id="6797" href="2--Paths-and-Identifications.2-6--Univalence.html#6733" class="Bound">y</a> <a id="6799" class="Symbol">})</a>
  <a id="6804" class="Symbol">(</a><a id="6805" href="2--Paths-and-Identifications.2-6--Univalence.html#6736" class="Bound">p</a> <a id="6807" href="2--Paths-and-Identifications.2-6--Univalence.html#6738" class="Bound">i</a><a id="6808" class="Symbol">)</a>
</pre>
<p>The eliminator <code class="Agda"><a href="Library.Univalence.html#7366" class="Function">unglue</a></code> works as you might expect on elements of
<code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> — regardless of where we are in the <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> type, we can
extract an element of <code>B</code>.</p>
<pre class="Agda"><a id="ua-unglue"></a><a id="6983" href="2--Paths-and-Identifications.2-6--Univalence.html#6983" class="Function">ua-unglue</a> <a id="6993" class="Symbol">:</a> <a id="6995" class="Symbol">(</a><a id="6996" href="2--Paths-and-Identifications.2-6--Univalence.html#6996" class="Bound">e</a> <a id="6998" class="Symbol">:</a> <a id="7000" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="7002" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="7004" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="7005" class="Symbol">)</a> <a id="7007" class="Symbol">→</a> <a id="7009" class="Symbol">(</a><a id="7010" href="2--Paths-and-Identifications.2-6--Univalence.html#7010" class="Bound">i</a> <a id="7012" class="Symbol">:</a> <a id="7014" href="Library.Primitive.html#1675" class="Datatype">I</a><a id="7015" class="Symbol">)</a> <a id="7017" class="Symbol">→</a> <a id="7019" class="Symbol">(</a><a id="7020" href="2--Paths-and-Identifications.2-6--Univalence.html#7020" class="Bound">x</a> <a id="7022" class="Symbol">:</a> <a id="7024" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="7027" href="2--Paths-and-Identifications.2-6--Univalence.html#6996" class="Bound">e</a> <a id="7029" href="2--Paths-and-Identifications.2-6--Univalence.html#7010" class="Bound">i</a><a id="7030" class="Symbol">)</a> <a id="7032" class="Symbol">→</a> <a id="7034" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a>
<a id="7036" href="2--Paths-and-Identifications.2-6--Univalence.html#6983" class="Function">ua-unglue</a> <a id="7046" href="2--Paths-and-Identifications.2-6--Univalence.html#7046" class="Bound">e</a> <a id="7048" href="2--Paths-and-Identifications.2-6--Univalence.html#7048" class="Bound">i</a> <a id="7050" href="2--Paths-and-Identifications.2-6--Univalence.html#7050" class="Bound">x</a> <a id="7052" class="Symbol">=</a> <a id="7054" href="Library.Univalence.html#7366" class="Function">unglue</a> <a id="7061" class="Symbol">(</a><a id="7062" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#6524" class="Function">∂</a> <a id="7064" href="2--Paths-and-Identifications.2-6--Univalence.html#7048" class="Bound">i</a><a id="7065" class="Symbol">)</a> <a id="7067" href="2--Paths-and-Identifications.2-6--Univalence.html#7050" class="Bound">x</a>
</pre>
<p>When we happen to be somewhere that <code>φ</code> equals <code>i1</code>, this will mean
applying the equivalence that we provided to the <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> type
constructor.</p>
<pre class="Agda"><a id="7223" class="Keyword">module</a> <a id="7230" href="2--Paths-and-Identifications.2-6--Univalence.html#7230" class="Module">_</a> <a id="7232" class="Symbol">{</a><a id="7233" href="2--Paths-and-Identifications.2-6--Univalence.html#7233" class="Bound">ℓ</a> <a id="7235" class="Symbol">:</a> <a id="7237" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="7242" class="Symbol">}</a> <a id="7244" class="Symbol">{</a><a id="7245" href="2--Paths-and-Identifications.2-6--Univalence.html#7245" class="Bound">A</a> <a id="7247" href="2--Paths-and-Identifications.2-6--Univalence.html#7247" class="Bound">B</a> <a id="7249" class="Symbol">:</a> <a id="7251" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="7256" href="2--Paths-and-Identifications.2-6--Univalence.html#7233" class="Bound">ℓ</a><a id="7257" class="Symbol">}</a> <a id="7259" class="Symbol">(</a><a id="7260" href="2--Paths-and-Identifications.2-6--Univalence.html#7260" class="Bound">e</a> <a id="7262" class="Symbol">:</a> <a id="7264" href="2--Paths-and-Identifications.2-6--Univalence.html#7245" class="Bound">A</a> <a id="7266" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="7268" href="2--Paths-and-Identifications.2-6--Univalence.html#7247" class="Bound">B</a><a id="7269" class="Symbol">)</a> <a id="7271" class="Keyword">where</a>
  <a id="7279" href="2--Paths-and-Identifications.2-6--Univalence.html#7279" class="Function">_</a> <a id="7281" class="Symbol">=</a> <a id="7283" class="Symbol">λ</a> <a id="7285" class="Symbol">(</a><a id="7286" href="2--Paths-and-Identifications.2-6--Univalence.html#7286" class="Bound">x</a> <a id="7288" class="Symbol">:</a> <a id="7290" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="7293" href="2--Paths-and-Identifications.2-6--Univalence.html#7260" class="Bound">e</a> <a id="7295" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="7297" class="Symbol">)</a> <a id="7299" class="Symbol">→</a> <a id="7301" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="7316" class="Symbol">(</a><a id="7317" href="2--Paths-and-Identifications.2-6--Univalence.html#6983" class="Function">ua-unglue</a> <a id="7327" href="2--Paths-and-Identifications.2-6--Univalence.html#7260" class="Bound">e</a> <a id="7329" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a> <a id="7332" href="2--Paths-and-Identifications.2-6--Univalence.html#7286" class="Bound">x</a><a id="7333" class="Symbol">)</a> <a id="7335" class="Symbol">(</a><a id="7336" href="2--Paths-and-Identifications.2-6--Univalence.html#7260" class="Bound">e</a> <a id="7338" class="Symbol">.</a><a id="7339" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5838" class="Field">map</a> <a id="7343" href="2--Paths-and-Identifications.2-6--Univalence.html#7286" class="Bound">x</a><a id="7344" class="Symbol">)</a>
  <a id="7348" href="2--Paths-and-Identifications.2-6--Univalence.html#7348" class="Function">_</a> <a id="7350" class="Symbol">=</a> <a id="7352" class="Symbol">λ</a> <a id="7354" class="Symbol">(</a><a id="7355" href="2--Paths-and-Identifications.2-6--Univalence.html#7355" class="Bound">x</a> <a id="7357" class="Symbol">:</a> <a id="7359" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="7362" href="2--Paths-and-Identifications.2-6--Univalence.html#7260" class="Bound">e</a> <a id="7364" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="7366" class="Symbol">)</a> <a id="7368" class="Symbol">→</a> <a id="7370" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="7385" class="Symbol">(</a><a id="7386" href="2--Paths-and-Identifications.2-6--Univalence.html#6983" class="Function">ua-unglue</a> <a id="7396" href="2--Paths-and-Identifications.2-6--Univalence.html#7260" class="Bound">e</a> <a id="7398" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a> <a id="7401" href="2--Paths-and-Identifications.2-6--Univalence.html#7355" class="Bound">x</a><a id="7402" class="Symbol">)</a> <a id="7404" href="2--Paths-and-Identifications.2-6--Univalence.html#7355" class="Bound">x</a>
</pre>
<p>Rearranging the arguments slightly, this is turned into an inverse to
<code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#5776" class="Function">Path→ua-PathP</a></code>.</p>
<pre class="Agda"><a id="ua-PathP→Path"></a><a id="7505" href="2--Paths-and-Identifications.2-6--Univalence.html#7505" class="Function">ua-PathP→Path</a> <a id="7519" class="Symbol">:</a> <a id="7521" class="Symbol">(</a><a id="7522" href="2--Paths-and-Identifications.2-6--Univalence.html#7522" class="Bound">e</a> <a id="7524" class="Symbol">:</a> <a id="7526" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="7528" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="7530" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="7531" class="Symbol">)</a> <a id="7533" class="Symbol">{</a><a id="7534" href="2--Paths-and-Identifications.2-6--Univalence.html#7534" class="Bound">x</a> <a id="7536" class="Symbol">:</a> <a id="7538" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a><a id="7539" class="Symbol">}</a> <a id="7541" class="Symbol">{</a><a id="7542" href="2--Paths-and-Identifications.2-6--Univalence.html#7542" class="Bound">y</a> <a id="7544" class="Symbol">:</a> <a id="7546" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="7547" class="Symbol">}</a>
 <a id="7550" class="Symbol">→</a> <a id="7552" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="7558" class="Symbol">(λ</a> <a id="7561" href="2--Paths-and-Identifications.2-6--Univalence.html#7561" class="Bound">i</a> <a id="7563" class="Symbol">→</a> <a id="7565" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="7568" href="2--Paths-and-Identifications.2-6--Univalence.html#7522" class="Bound">e</a> <a id="7570" href="2--Paths-and-Identifications.2-6--Univalence.html#7561" class="Bound">i</a><a id="7571" class="Symbol">)</a> <a id="7573" href="2--Paths-and-Identifications.2-6--Univalence.html#7534" class="Bound">x</a> <a id="7575" href="2--Paths-and-Identifications.2-6--Univalence.html#7542" class="Bound">y</a>
 <a id="7578" class="Symbol">→</a> <a id="7580" href="2--Paths-and-Identifications.2-6--Univalence.html#7522" class="Bound">e</a> <a id="7582" class="Symbol">.</a><a id="7583" class="Field">map</a> <a id="7587" href="2--Paths-and-Identifications.2-6--Univalence.html#7534" class="Bound">x</a> <a id="7589" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="7591" href="2--Paths-and-Identifications.2-6--Univalence.html#7542" class="Bound">y</a>
<a id="7593" href="2--Paths-and-Identifications.2-6--Univalence.html#7505" class="Function">ua-PathP→Path</a> <a id="7607" href="2--Paths-and-Identifications.2-6--Univalence.html#7607" class="Bound">e</a> <a id="7609" href="2--Paths-and-Identifications.2-6--Univalence.html#7609" class="Bound">p</a> <a id="7611" href="2--Paths-and-Identifications.2-6--Univalence.html#7611" class="Bound">i</a> <a id="7613" class="Symbol">=</a> <a id="7615" href="2--Paths-and-Identifications.2-6--Univalence.html#6983" class="Function">ua-unglue</a> <a id="7625" href="2--Paths-and-Identifications.2-6--Univalence.html#7607" class="Bound">e</a> <a id="7627" href="2--Paths-and-Identifications.2-6--Univalence.html#7611" class="Bound">i</a> <a id="7629" class="Symbol">(</a><a id="7630" href="2--Paths-and-Identifications.2-6--Univalence.html#7609" class="Bound">p</a> <a id="7632" href="2--Paths-and-Identifications.2-6--Univalence.html#7611" class="Bound">i</a><a id="7633" class="Symbol">)</a>
</pre>
<p>These <code class="Agda"><a href="Library.Univalence.html#7106" class="Primitive">glue</a></code> and <code class="Agda"><a href="Library.Univalence.html#7366" class="Function">unglue</a></code> operations are inverses by definition,
and so no more work is necessary to show <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#5776" class="Function">Path→ua-PathP</a></code> is an
equivalence.</p>
<pre class="Agda"><a id="Path≃ua-PathP"></a><a id="7792" href="2--Paths-and-Identifications.2-6--Univalence.html#7792" class="Function">Path≃ua-PathP</a> <a id="7806" class="Symbol">:</a> <a id="7808" class="Symbol">(</a><a id="7809" href="2--Paths-and-Identifications.2-6--Univalence.html#7809" class="Bound">e</a> <a id="7811" class="Symbol">:</a> <a id="7813" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="7815" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="7817" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="7818" class="Symbol">)</a> <a id="7820" class="Symbol">{</a><a id="7821" href="2--Paths-and-Identifications.2-6--Univalence.html#7821" class="Bound">x</a> <a id="7823" class="Symbol">:</a> <a id="7825" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a><a id="7826" class="Symbol">}</a> <a id="7828" class="Symbol">{</a><a id="7829" href="2--Paths-and-Identifications.2-6--Univalence.html#7829" class="Bound">y</a> <a id="7831" class="Symbol">:</a> <a id="7833" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="7834" class="Symbol">}</a>
 <a id="7837" class="Symbol">→</a> <a id="7839" class="Symbol">(</a><a id="7840" href="2--Paths-and-Identifications.2-6--Univalence.html#7809" class="Bound">e</a> <a id="7842" class="Symbol">.</a><a id="7843" class="Field">map</a> <a id="7847" href="2--Paths-and-Identifications.2-6--Univalence.html#7821" class="Bound">x</a> <a id="7849" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="7851" href="2--Paths-and-Identifications.2-6--Univalence.html#7829" class="Bound">y</a><a id="7852" class="Symbol">)</a>
 <a id="7855" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="7857" class="Symbol">(</a><a id="7858" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="7864" class="Symbol">(λ</a> <a id="7867" href="2--Paths-and-Identifications.2-6--Univalence.html#7867" class="Bound">i</a> <a id="7869" class="Symbol">→</a> <a id="7871" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="7874" href="2--Paths-and-Identifications.2-6--Univalence.html#7809" class="Bound">e</a> <a id="7876" href="2--Paths-and-Identifications.2-6--Univalence.html#7867" class="Bound">i</a><a id="7877" class="Symbol">)</a> <a id="7879" href="2--Paths-and-Identifications.2-6--Univalence.html#7821" class="Bound">x</a> <a id="7881" href="2--Paths-and-Identifications.2-6--Univalence.html#7829" class="Bound">y</a><a id="7882" class="Symbol">)</a>
<a id="7884" href="2--Paths-and-Identifications.2-6--Univalence.html#7792" class="Function">Path≃ua-PathP</a> <a id="7898" href="2--Paths-and-Identifications.2-6--Univalence.html#7898" class="Bound">e</a> 
  <a id="7903" class="Symbol">=</a> <a id="7905" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#7290" class="Function">inv→equiv</a> <a id="7915" class="Symbol">(</a><a id="7916" href="2--Paths-and-Identifications.2-6--Univalence.html#5776" class="Function">Path→ua-PathP</a> <a id="7930" href="2--Paths-and-Identifications.2-6--Univalence.html#7898" class="Bound">e</a><a id="7931" class="Symbol">)</a> <a id="7933" class="Symbol">(</a><a id="7934" href="2--Paths-and-Identifications.2-6--Univalence.html#7505" class="Function">ua-PathP→Path</a> <a id="7948" href="2--Paths-and-Identifications.2-6--Univalence.html#7898" class="Bound">e</a><a id="7949" class="Symbol">)</a> <a id="7951" class="Symbol">(λ</a> <a id="7954" href="2--Paths-and-Identifications.2-6--Univalence.html#7954" class="Bound">_</a> <a id="7956" class="Symbol">→</a> <a id="7958" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a><a id="7962" class="Symbol">)</a> <a id="7964" class="Symbol">(λ</a> <a id="7967" href="2--Paths-and-Identifications.2-6--Univalence.html#7967" class="Bound">_</a> <a id="7969" class="Symbol">→</a> <a id="7971" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a><a id="7975" class="Symbol">)</a>
</pre>
<p>When <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a></code> is applied to the identity equivalence on <code>A</code>, we get
the <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a></code> path from <code>A</code> to itself.</p>
<pre class="Agda"><a id="ua-idEquiv"></a><a id="8091" href="2--Paths-and-Identifications.2-6--Univalence.html#8091" class="Function">ua-idEquiv</a> <a id="8102" class="Symbol">:</a> <a id="8104" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="8107" class="Symbol">(</a><a id="8108" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#8989" class="Function">idEquiv</a> <a id="8116" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a><a id="8117" class="Symbol">)</a> <a id="8119" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="8121" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a>
</pre>
<p>Written as a square, we are trying to construct the square of types
where on three of the sides we are constant at the type <code>A</code> and on the
remaining side we have <code>ua (idEquiv A)</code>.</p>
<pre><code>            A — — — — — — — — &gt; A
          / ^                 / ^
        /   )               /   )
      /     (             /     (
    A — — — — — — — — &gt; A       )
    ^       (           ^       (                    ^   j
    )       )           )       )                    ) /
    (       (           (       (                    ∙ — &gt;
    )       )           )       )                      i
    (       A — — — — — ( — — &gt; A
    )                   )     /
    (                   (   /
    )                   ) /
    A — — — — — — — — &gt; A
</code></pre>
<p>Using <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> again here with <code>(A , idEquiv A)</code> on all the
vertical faces gives us a square of types on the bottom. When <code>i = i1</code>, <code>j = i0</code> or <code>j = i1</code>, this <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code>-type computes away to give
exactly <code>A</code>. When <code>i = i0</code>, we are left with the line of types </p>
<pre><code>Glue A {φ = ∂ j} 
  (λ { (j = i0) → (A , idEquiv A)
     ; (j = i1) → (A , idEquiv A) })
</code></pre>
<p>but this is exactly the definition of <code>ua (idEquiv A)</code>.</p>
<pre class="Agda"><a id="9345" href="2--Paths-and-Identifications.2-6--Univalence.html#8091" class="Function">ua-idEquiv</a> <a id="9356" class="Symbol">{</a><a id="9357" class="Argument">A</a> <a id="9359" class="Symbol">=</a> <a id="9361" href="2--Paths-and-Identifications.2-6--Univalence.html#9361" class="Bound">A</a><a id="9362" class="Symbol">}</a> <a id="9364" href="2--Paths-and-Identifications.2-6--Univalence.html#9364" class="Bound">i</a> <a id="9366" href="2--Paths-and-Identifications.2-6--Univalence.html#9366" class="Bound">j</a> <a id="9368" class="Symbol">=</a> <a id="9370" href="Library.Univalence.html#7163" class="Function">Glue</a> <a id="9375" href="2--Paths-and-Identifications.2-6--Univalence.html#9361" class="Bound">A</a> <a id="9377" class="Symbol">{</a><a id="9378" class="Argument">φ</a> <a id="9380" class="Symbol">=</a> <a id="9382" href="2--Paths-and-Identifications.2-6--Univalence.html#9364" class="Bound">i</a> <a id="9384" href="Library.Prelude.html#387" class="Primitive Operator">∨</a> <a id="9386" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#6524" class="Function">∂</a> <a id="9388" href="2--Paths-and-Identifications.2-6--Univalence.html#9366" class="Bound">j</a><a id="9389" class="Symbol">}</a> <a id="9391" class="Symbol">(λ</a> <a id="9394" href="2--Paths-and-Identifications.2-6--Univalence.html#9394" class="Bound">_</a> <a id="9396" class="Symbol">→</a> <a id="9398" href="2--Paths-and-Identifications.2-6--Univalence.html#9361" class="Bound">A</a> <a id="9400" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="9402" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#8989" class="Function">idEquiv</a> <a id="9410" href="2--Paths-and-Identifications.2-6--Univalence.html#9361" class="Bound">A</a><a id="9411" class="Symbol">)</a>
</pre>
<p>Transporting over <code>ua e</code> is the same as applying the function
underlying the equivalence <code>e</code>. Really, we get a transport over
<code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a></code>, which is cleared up by a use of <code class="Agda"><a href="2--Paths-and-Identifications.2-5--Transport.html#4144" class="Function">transport-refl</a></code>. This is
an instance of the computation rule for <code class="Agda"><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a></code> on <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code>
types, which is very complicated in full generality.</p>
<pre class="Agda"><a id="ua-comp"></a><a id="9738" href="2--Paths-and-Identifications.2-6--Univalence.html#9738" class="Function">ua-comp</a> <a id="9746" class="Symbol">:</a> <a id="9748" class="Symbol">(</a><a id="9749" href="2--Paths-and-Identifications.2-6--Univalence.html#9749" class="Bound">e</a> <a id="9751" class="Symbol">:</a> <a id="9753" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="9755" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="9757" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="9758" class="Symbol">)</a> <a id="9760" class="Symbol">→</a> <a id="9762" class="Symbol">(</a><a id="9763" href="2--Paths-and-Identifications.2-6--Univalence.html#9763" class="Bound">x</a> <a id="9765" class="Symbol">:</a> <a id="9767" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a><a id="9768" class="Symbol">)</a> <a id="9770" class="Symbol">→</a> <a id="9772" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a> <a id="9782" class="Symbol">(</a><a id="9783" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="9786" href="2--Paths-and-Identifications.2-6--Univalence.html#9749" class="Bound">e</a><a id="9787" class="Symbol">)</a> <a id="9789" href="2--Paths-and-Identifications.2-6--Univalence.html#9763" class="Bound">x</a> <a id="9791" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="9793" href="2--Paths-and-Identifications.2-6--Univalence.html#9749" class="Bound">e</a> <a id="9795" class="Symbol">.</a><a id="9796" class="Field">map</a> <a id="9800" href="2--Paths-and-Identifications.2-6--Univalence.html#9763" class="Bound">x</a>
<a id="9802" href="2--Paths-and-Identifications.2-6--Univalence.html#9738" class="Function">ua-comp</a> <a id="9810" href="2--Paths-and-Identifications.2-6--Univalence.html#9810" class="Bound">e</a> <a id="9812" href="2--Paths-and-Identifications.2-6--Univalence.html#9812" class="Bound">x</a> <a id="9814" class="Symbol">=</a> <a id="9816" href="2--Paths-and-Identifications.2-5--Transport.html#4144" class="Function">transport-refl</a> <a id="9831" class="Symbol">(</a><a id="9832" href="2--Paths-and-Identifications.2-6--Univalence.html#9810" class="Bound">e</a> <a id="9834" class="Symbol">.</a><a id="9835" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5838" class="Field">map</a> <a id="9839" href="2--Paths-and-Identifications.2-6--Univalence.html#9812" class="Bound">x</a><a id="9840" class="Symbol">)</a>
</pre>
<p>For most types we encounter this holds definitionally the same way
that <code class="Agda"><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a></code>ing over <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a></code> does, because in those cases the
<code class="Agda"><a href="2--Paths-and-Identifications.2-5--Transport.html#4144" class="Function">transport-refl</a></code> above truly does become the reflexivity path. And
so Cubical Agda does achieve is the property we hoped for at the top
of this Lecture. </p>
<pre class="Agda"><a id="10144" href="2--Paths-and-Identifications.2-6--Univalence.html#10144" class="Function">_</a> <a id="10146" class="Symbol">=</a> <a id="10148" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="10163" class="Symbol">(</a><a id="10164" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a> <a id="10174" class="Symbol">(</a><a id="10175" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10178" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#22083" class="Function">not-≃</a><a id="10183" class="Symbol">)</a> <a id="10185" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a><a id="10189" class="Symbol">)</a> <a id="10191" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
<a id="10197" href="2--Paths-and-Identifications.2-6--Univalence.html#10197" class="Function">_</a> <a id="10199" class="Symbol">=</a> <a id="10201" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="10216" class="Symbol">(</a><a id="10217" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a> <a id="10227" class="Symbol">(</a><a id="10228" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10231" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6906" class="Function">Bool≃RedOrBlue</a><a id="10245" class="Symbol">)</a> <a id="10247" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a><a id="10251" class="Symbol">)</a> <a id="10253" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#2983" class="InductiveConstructor">red</a>

<a id="10258" href="2--Paths-and-Identifications.2-6--Univalence.html#10258" class="Function">_</a> <a id="10260" class="Symbol">=</a> <a id="10262" class="Symbol">λ</a> <a id="10264" class="Symbol">(</a><a id="10265" href="2--Paths-and-Identifications.2-6--Univalence.html#10265" class="Bound">e</a> <a id="10267" class="Symbol">:</a> <a id="10269" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="10274" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="10276" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="10280" class="Symbol">)</a> <a id="10282" class="Symbol">(</a><a id="10283" href="2--Paths-and-Identifications.2-6--Univalence.html#10283" class="Bound">x</a> <a id="10285" class="Symbol">:</a> <a id="10287" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="10291" class="Symbol">)</a> 
  <a id="10296" class="Symbol">→</a> <a id="10298" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="10313" class="Symbol">(</a><a id="10314" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a> <a id="10324" class="Symbol">(</a><a id="10325" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10328" href="2--Paths-and-Identifications.2-6--Univalence.html#10265" class="Bound">e</a><a id="10329" class="Symbol">)</a> <a id="10331" href="2--Paths-and-Identifications.2-6--Univalence.html#10283" class="Bound">x</a><a id="10332" class="Symbol">)</a> <a id="10334" class="Symbol">(</a><a id="10335" href="2--Paths-and-Identifications.2-6--Univalence.html#10265" class="Bound">e</a> <a id="10337" class="Symbol">.</a><a id="10338" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5838" class="Field">map</a> <a id="10342" href="2--Paths-and-Identifications.2-6--Univalence.html#10283" class="Bound">x</a><a id="10343" class="Symbol">)</a>

<a id="10346" href="2--Paths-and-Identifications.2-6--Univalence.html#10346" class="Function">_</a> <a id="10348" class="Symbol">=</a> <a id="10350" class="Symbol">λ</a> <a id="10352" class="Symbol">(</a><a id="10353" href="2--Paths-and-Identifications.2-6--Univalence.html#10353" class="Bound">e</a> <a id="10355" class="Symbol">:</a> <a id="10357" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a> <a id="10360" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="10362" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a><a id="10364" class="Symbol">)</a> <a id="10366" class="Symbol">(</a><a id="10367" href="2--Paths-and-Identifications.2-6--Univalence.html#10367" class="Bound">x</a> <a id="10369" class="Symbol">:</a> <a id="10371" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a><a id="10373" class="Symbol">)</a>
  <a id="10377" class="Symbol">→</a> <a id="10379" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="10394" class="Symbol">(</a><a id="10395" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a> <a id="10405" class="Symbol">(</a><a id="10406" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10409" href="2--Paths-and-Identifications.2-6--Univalence.html#10353" class="Bound">e</a><a id="10410" class="Symbol">)</a> <a id="10412" href="2--Paths-and-Identifications.2-6--Univalence.html#10367" class="Bound">x</a><a id="10413" class="Symbol">)</a> <a id="10415" class="Symbol">(</a><a id="10416" href="2--Paths-and-Identifications.2-6--Univalence.html#10353" class="Bound">e</a> <a id="10418" class="Symbol">.</a><a id="10419" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5838" class="Field">map</a> <a id="10423" href="2--Paths-and-Identifications.2-6--Univalence.html#10367" class="Bound">x</a><a id="10424" class="Symbol">)</a>
</pre>
<p>Finally, univalence is inverse to <code class="Agda"><a href="2--Paths-and-Identifications.2-5--Transport.html#5498" class="Function">path→equiv</a></code>. We show one half of
this now using <code class="Agda"><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#5445" class="Function">J</a></code>, but will need to wait until Lecture 2-X to show
the other direction.</p>
<pre class="Agda"><a id="au"></a><a id="10597" href="2--Paths-and-Identifications.2-6--Univalence.html#10597" class="Function">au</a> <a id="10600" class="Symbol">:</a> <a id="10602" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="10604" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="10606" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a> <a id="10608" class="Symbol">→</a> <a id="10610" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="10612" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="10614" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a>
<a id="10616" href="2--Paths-and-Identifications.2-6--Univalence.html#10597" class="Function">au</a> <a id="10619" class="Symbol">=</a> <a id="10621" href="2--Paths-and-Identifications.2-5--Transport.html#5498" class="Function">path→equiv</a>

<a id="ua-au"></a><a id="10633" href="2--Paths-and-Identifications.2-6--Univalence.html#10633" class="Function">ua-au</a> <a id="10639" class="Symbol">:</a> <a id="10641" class="Symbol">(</a><a id="10642" href="2--Paths-and-Identifications.2-6--Univalence.html#10642" class="Bound">p</a> <a id="10644" class="Symbol">:</a> <a id="10646" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="10648" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="10650" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="10651" class="Symbol">)</a> <a id="10653" class="Symbol">→</a> <a id="10655" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10658" class="Symbol">(</a><a id="10659" href="2--Paths-and-Identifications.2-6--Univalence.html#10597" class="Function">au</a> <a id="10662" href="2--Paths-and-Identifications.2-6--Univalence.html#10642" class="Bound">p</a><a id="10663" class="Symbol">)</a> <a id="10665" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="10667" href="2--Paths-and-Identifications.2-6--Univalence.html#10642" class="Bound">p</a>
<a id="10669" href="2--Paths-and-Identifications.2-6--Univalence.html#10633" class="Function">ua-au</a> <a id="10675" class="Symbol">=</a> <a id="10677" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#5445" class="Function">J</a> <a id="10679" class="Symbol">(λ</a> <a id="10682" href="2--Paths-and-Identifications.2-6--Univalence.html#10682" class="Bound">_</a> <a id="10684" href="2--Paths-and-Identifications.2-6--Univalence.html#10684" class="Bound">p</a> <a id="10686" class="Symbol">→</a> <a id="10688" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10691" class="Symbol">(</a><a id="10692" href="2--Paths-and-Identifications.2-6--Univalence.html#10597" class="Function">au</a> <a id="10695" href="2--Paths-and-Identifications.2-6--Univalence.html#10684" class="Bound">p</a><a id="10696" class="Symbol">)</a> <a id="10698" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="10700" href="2--Paths-and-Identifications.2-6--Univalence.html#10684" class="Bound">p</a><a id="10701" class="Symbol">)</a> <a id="10703" href="2--Paths-and-Identifications.2-6--Univalence.html#10716" class="Function">path</a>
  <a id="10710" class="Keyword">where</a> <a id="10716" href="2--Paths-and-Identifications.2-6--Univalence.html#10716" class="Function">path</a> <a id="10721" class="Symbol">=</a> <a id="10723" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10726" class="Symbol">(</a><a id="10727" href="2--Paths-and-Identifications.2-6--Univalence.html#10597" class="Function">au</a> <a id="10730" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a><a id="10734" class="Symbol">)</a>   <a id="10738" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#31246" class="Function">≡⟨</a> <a id="10741" href="2--Paths-and-Identifications.2-1--Paths.html#17691" class="Function">ap</a> <a id="10744" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10747" href="2--Paths-and-Identifications.2-5--Transport.html#5996" class="Function">path→equiv-refl</a> <a id="10763" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#31246" class="Function">⟩</a>
               <a id="10780" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10783" class="Symbol">(</a><a id="10784" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#8989" class="Function">idEquiv</a> <a id="10792" class="Symbol">_)</a> <a id="10795" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#31246" class="Function">≡⟨</a> <a id="10798" href="2--Paths-and-Identifications.2-6--Univalence.html#8091" class="Function">ua-idEquiv</a> <a id="10809" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#31246" class="Function">⟩</a>
               <a id="10826" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a> <a id="10831" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#31343" class="Function Operator">∎</a>
</pre>
<p>Back in <code class="Agda"><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#17989" class="Function">×-map-≃</a></code>, we saw that <code class="Agda"><a href="Library.Prelude.html#1692" class="Function">×</a></code> respects equivalences.
Univalence gives us a second, much easier way to prove this:</p>
<pre class="Agda"><a id="×-map-≡"></a><a id="10966" href="2--Paths-and-Identifications.2-6--Univalence.html#10966" class="Function">×-map-≡</a> <a id="10974" class="Symbol">:</a> <a id="10976" class="Symbol">{</a><a id="10977" href="2--Paths-and-Identifications.2-6--Univalence.html#10977" class="Bound">A</a> <a id="10979" href="2--Paths-and-Identifications.2-6--Univalence.html#10979" class="Bound">A&#39;</a> <a id="10982" href="2--Paths-and-Identifications.2-6--Univalence.html#10982" class="Bound">B</a> <a id="10984" href="2--Paths-and-Identifications.2-6--Univalence.html#10984" class="Bound">B&#39;</a> <a id="10987" class="Symbol">:</a> <a id="10989" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="10994" href="2--Paths-and-Identifications.2-6--Univalence.html#640" class="Generalizable">ℓ</a><a id="10995" class="Symbol">}</a>
  <a id="10999" class="Symbol">→</a> <a id="11001" class="Symbol">(</a><a id="11002" href="2--Paths-and-Identifications.2-6--Univalence.html#10977" class="Bound">A</a> <a id="11004" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="11006" href="2--Paths-and-Identifications.2-6--Univalence.html#10979" class="Bound">A&#39;</a><a id="11008" class="Symbol">)</a> <a id="11010" class="Symbol">→</a> <a id="11012" class="Symbol">(</a><a id="11013" href="2--Paths-and-Identifications.2-6--Univalence.html#10982" class="Bound">B</a> <a id="11015" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="11017" href="2--Paths-and-Identifications.2-6--Univalence.html#10984" class="Bound">B&#39;</a><a id="11019" class="Symbol">)</a> <a id="11021" class="Symbol">→</a> <a id="11023" class="Symbol">(</a><a id="11024" href="2--Paths-and-Identifications.2-6--Univalence.html#10977" class="Bound">A</a> <a id="11026" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="11028" href="2--Paths-and-Identifications.2-6--Univalence.html#10982" class="Bound">B</a><a id="11029" class="Symbol">)</a> <a id="11031" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="11033" class="Symbol">(</a><a id="11034" href="2--Paths-and-Identifications.2-6--Univalence.html#10979" class="Bound">A&#39;</a> <a id="11037" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="11039" href="2--Paths-and-Identifications.2-6--Univalence.html#10984" class="Bound">B&#39;</a><a id="11041" class="Symbol">)</a>
<a id="11043" class="Comment">-- Exercise:</a>
<a id="11056" class="Comment">-- ×-map-≡ p q = {!!}</a>

<a id="×-map-≃-ua"></a><a id="11132" href="2--Paths-and-Identifications.2-6--Univalence.html#11132" class="Function">×-map-≃-ua</a> <a id="11143" class="Symbol">:</a> <a id="11145" class="Symbol">{</a><a id="11146" href="2--Paths-and-Identifications.2-6--Univalence.html#11146" class="Bound">A</a> <a id="11148" href="2--Paths-and-Identifications.2-6--Univalence.html#11148" class="Bound">A&#39;</a> <a id="11151" href="2--Paths-and-Identifications.2-6--Univalence.html#11151" class="Bound">B</a> <a id="11153" href="2--Paths-and-Identifications.2-6--Univalence.html#11153" class="Bound">B&#39;</a> <a id="11156" class="Symbol">:</a> <a id="11158" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="11163" href="2--Paths-and-Identifications.2-6--Univalence.html#640" class="Generalizable">ℓ</a><a id="11164" class="Symbol">}</a>
  <a id="11168" class="Symbol">→</a> <a id="11170" class="Symbol">(</a><a id="11171" href="2--Paths-and-Identifications.2-6--Univalence.html#11146" class="Bound">A</a> <a id="11173" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="11175" href="2--Paths-and-Identifications.2-6--Univalence.html#11148" class="Bound">A&#39;</a><a id="11177" class="Symbol">)</a> <a id="11179" class="Symbol">→</a> <a id="11181" class="Symbol">(</a><a id="11182" href="2--Paths-and-Identifications.2-6--Univalence.html#11151" class="Bound">B</a> <a id="11184" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="11186" href="2--Paths-and-Identifications.2-6--Univalence.html#11153" class="Bound">B&#39;</a><a id="11188" class="Symbol">)</a> <a id="11190" class="Symbol">→</a> <a id="11192" class="Symbol">(</a><a id="11193" href="2--Paths-and-Identifications.2-6--Univalence.html#11146" class="Bound">A</a> <a id="11195" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="11197" href="2--Paths-and-Identifications.2-6--Univalence.html#11151" class="Bound">B</a><a id="11198" class="Symbol">)</a> <a id="11200" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="11202" class="Symbol">(</a><a id="11203" href="2--Paths-and-Identifications.2-6--Univalence.html#11148" class="Bound">A&#39;</a> <a id="11206" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="11208" href="2--Paths-and-Identifications.2-6--Univalence.html#11153" class="Bound">B&#39;</a><a id="11210" class="Symbol">)</a>
<a id="11212" class="Comment">-- Exercise:</a>
<a id="11225" class="Comment">-- ×-map-≃-ua f g = au {!!}</a>
</pre>
<p>This is nice, but we now have to check that the underlying function of
this equivalence is the function we expect; that is, <code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#3001" class="Function">×-map</a></code>.
Thankfully, we checked in Lecture 2-X that transporting over a path
like <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#10966" class="Function">×-map-≡</a></code> computes to a transport in each of the components, so we
just have to use <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#9738" class="Function">ua-comp</a></code> on both sides to clear up those transports.</p>
<pre class="Agda"><a id="×-map-≃-underlying"></a><a id="11684" href="2--Paths-and-Identifications.2-6--Univalence.html#11684" class="Function">×-map-≃-underlying</a> <a id="11703" class="Symbol">:</a> <a id="11705" class="Symbol">{</a><a id="11706" href="2--Paths-and-Identifications.2-6--Univalence.html#11706" class="Bound">A</a> <a id="11708" href="2--Paths-and-Identifications.2-6--Univalence.html#11708" class="Bound">A&#39;</a> <a id="11711" href="2--Paths-and-Identifications.2-6--Univalence.html#11711" class="Bound">B</a> <a id="11713" href="2--Paths-and-Identifications.2-6--Univalence.html#11713" class="Bound">B&#39;</a> <a id="11716" class="Symbol">:</a> <a id="11718" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="11723" href="2--Paths-and-Identifications.2-6--Univalence.html#640" class="Generalizable">ℓ</a><a id="11724" class="Symbol">}</a> <a id="11726" class="Symbol">→</a> <a id="11728" class="Symbol">(</a><a id="11729" href="2--Paths-and-Identifications.2-6--Univalence.html#11729" class="Bound">f</a> <a id="11731" class="Symbol">:</a> <a id="11733" href="2--Paths-and-Identifications.2-6--Univalence.html#11706" class="Bound">A</a> <a id="11735" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="11737" href="2--Paths-and-Identifications.2-6--Univalence.html#11708" class="Bound">A&#39;</a><a id="11739" class="Symbol">)</a> <a id="11741" class="Symbol">→</a> <a id="11743" class="Symbol">(</a><a id="11744" href="2--Paths-and-Identifications.2-6--Univalence.html#11744" class="Bound">g</a> <a id="11746" class="Symbol">:</a> <a id="11748" href="2--Paths-and-Identifications.2-6--Univalence.html#11711" class="Bound">B</a> <a id="11750" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="11752" href="2--Paths-and-Identifications.2-6--Univalence.html#11713" class="Bound">B&#39;</a><a id="11754" class="Symbol">)</a>
  <a id="11758" class="Symbol">→</a> <a id="11760" class="Symbol">(</a><a id="11761" href="2--Paths-and-Identifications.2-6--Univalence.html#11132" class="Function">×-map-≃-ua</a> <a id="11772" href="2--Paths-and-Identifications.2-6--Univalence.html#11729" class="Bound">f</a> <a id="11774" href="2--Paths-and-Identifications.2-6--Univalence.html#11744" class="Bound">g</a><a id="11775" class="Symbol">)</a> <a id="11777" class="Symbol">.</a><a id="11778" class="Field">map</a> <a id="11782" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="11784" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#3001" class="Function">×-map</a> <a id="11790" class="Symbol">(</a><a id="11791" href="2--Paths-and-Identifications.2-6--Univalence.html#11729" class="Bound">f</a> <a id="11793" class="Symbol">.</a><a id="11794" class="Field">map</a><a id="11797" class="Symbol">)</a> <a id="11799" class="Symbol">(</a><a id="11800" href="2--Paths-and-Identifications.2-6--Univalence.html#11744" class="Bound">g</a> <a id="11802" class="Symbol">.</a><a id="11803" class="Field">map</a><a id="11806" class="Symbol">)</a>
<a id="11808" class="Comment">-- Exercise:</a>
<a id="11821" class="Comment">-- ×-map-≃-uat f g = {!!}</a>
</pre>
<p>Then, we can transport the map proof that <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#11132" class="Function">×-map-≃-ua</a></code> is an
equivalence back over to the simpler map.</p>
<pre class="Agda"><a id="×-map-≃-again"></a><a id="12054" href="2--Paths-and-Identifications.2-6--Univalence.html#12054" class="Function">×-map-≃-again</a> <a id="12068" class="Symbol">:</a> <a id="12070" class="Symbol">{</a><a id="12071" href="2--Paths-and-Identifications.2-6--Univalence.html#12071" class="Bound">A</a> <a id="12073" href="2--Paths-and-Identifications.2-6--Univalence.html#12073" class="Bound">A&#39;</a> <a id="12076" href="2--Paths-and-Identifications.2-6--Univalence.html#12076" class="Bound">B</a> <a id="12078" href="2--Paths-and-Identifications.2-6--Univalence.html#12078" class="Bound">B&#39;</a> <a id="12081" class="Symbol">:</a> <a id="12083" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="12088" href="2--Paths-and-Identifications.2-6--Univalence.html#640" class="Generalizable">ℓ</a><a id="12089" class="Symbol">}</a>
  <a id="12093" class="Symbol">→</a> <a id="12095" class="Symbol">(</a><a id="12096" href="2--Paths-and-Identifications.2-6--Univalence.html#12071" class="Bound">A</a> <a id="12098" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="12100" href="2--Paths-and-Identifications.2-6--Univalence.html#12073" class="Bound">A&#39;</a><a id="12102" class="Symbol">)</a> <a id="12104" class="Symbol">→</a> <a id="12106" class="Symbol">(</a><a id="12107" href="2--Paths-and-Identifications.2-6--Univalence.html#12076" class="Bound">B</a> <a id="12109" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="12111" href="2--Paths-and-Identifications.2-6--Univalence.html#12078" class="Bound">B&#39;</a><a id="12113" class="Symbol">)</a> <a id="12115" class="Symbol">→</a> <a id="12117" class="Symbol">(</a><a id="12118" href="2--Paths-and-Identifications.2-6--Univalence.html#12071" class="Bound">A</a> <a id="12120" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="12122" href="2--Paths-and-Identifications.2-6--Univalence.html#12076" class="Bound">B</a><a id="12123" class="Symbol">)</a> <a id="12125" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="12127" class="Symbol">(</a><a id="12128" href="2--Paths-and-Identifications.2-6--Univalence.html#12073" class="Bound">A&#39;</a> <a id="12131" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="12133" href="2--Paths-and-Identifications.2-6--Univalence.html#12078" class="Bound">B&#39;</a><a id="12135" class="Symbol">)</a>
<a id="12137" href="2--Paths-and-Identifications.2-6--Univalence.html#12054" class="Function">×-map-≃-again</a> <a id="12151" href="2--Paths-and-Identifications.2-6--Univalence.html#12151" class="Bound">f</a> <a id="12153" href="2--Paths-and-Identifications.2-6--Univalence.html#12153" class="Bound">g</a> <a id="12155" class="Symbol">.</a><a id="12156" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5838" class="Field">map</a> <a id="12160" class="Symbol">=</a> <a id="12162" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#3001" class="Function">×-map</a> <a id="12168" class="Symbol">(</a><a id="12169" href="2--Paths-and-Identifications.2-6--Univalence.html#12151" class="Bound">f</a> <a id="12171" class="Symbol">.</a><a id="12172" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5838" class="Field">map</a><a id="12175" class="Symbol">)</a> <a id="12177" class="Symbol">(</a><a id="12178" href="2--Paths-and-Identifications.2-6--Univalence.html#12153" class="Bound">g</a> <a id="12180" class="Symbol">.</a><a id="12181" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5838" class="Field">map</a><a id="12184" class="Symbol">)</a>
<a id="12186" href="2--Paths-and-Identifications.2-6--Univalence.html#12054" class="Function">×-map-≃-again</a> <a id="12200" href="2--Paths-and-Identifications.2-6--Univalence.html#12200" class="Bound">f</a> <a id="12202" href="2--Paths-and-Identifications.2-6--Univalence.html#12202" class="Bound">g</a> <a id="12204" class="Symbol">.</a><a id="12205" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5854" class="Field">proof</a> <a id="12211" class="Symbol">=</a> <a id="12213" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1180" class="Function">subst</a> <a id="12219" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5559" class="Record">isEquiv</a> <a id="12227" class="Symbol">(</a><a id="12228" href="2--Paths-and-Identifications.2-6--Univalence.html#11684" class="Function">×-map-≃-underlying</a> <a id="12247" href="2--Paths-and-Identifications.2-6--Univalence.html#12200" class="Bound">f</a> <a id="12249" href="2--Paths-and-Identifications.2-6--Univalence.html#12202" class="Bound">g</a><a id="12250" class="Symbol">)</a> <a id="12252" class="Symbol">(</a><a id="12253" href="2--Paths-and-Identifications.2-6--Univalence.html#11132" class="Function">×-map-≃-ua</a> <a id="12264" href="2--Paths-and-Identifications.2-6--Univalence.html#12200" class="Bound">f</a> <a id="12266" href="2--Paths-and-Identifications.2-6--Univalence.html#12202" class="Bound">g</a> <a id="12268" class="Symbol">.</a><a id="12269" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5854" class="Field">proof</a><a id="12274" class="Symbol">)</a>
</pre>
<p>There is a downside to proving this kind of equivalence using
univalence: <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#11132" class="Function">×-map-≃-ua</a></code> only works for types that all lie in the
same universe, whereas our original <code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#3001" class="Function">×-map</a></code> is completely universe
polymorphic.</p>
<h2 id="dependent-univalence"><a class="header" href="#dependent-univalence">Dependent Univalence</a></h2>
<p>mvrnote: useful anywhere?</p>
<p>from Cubical.Foundations.Univalence.Dependent</p>
<pre class="Agda"><a id="12597" class="Comment">-- module _</a>
  <a id="12611" class="Comment">-- {A B : Type ℓ} {P : A → Type ℓ&#39;} {Q : B → Type ℓ&#39;}</a>
  <a id="12667" class="Comment">-- (e : A ≃ B) (F : (a : A) → P a → Q (e .map a))</a>
  <a id="12719" class="Comment">-- (iseq : (a : A) → isEquiv (F a))</a>
  <a id="12757" class="Comment">-- where</a>
  <a id="12768" class="Comment">-- private</a>
  <a id="12781" class="Comment">--   -- Bundle `F` and `equiv` into a pointwise equivalence of `P` and `Q`:</a>
  <a id="12859" class="Comment">--   Γ : (a : A) → P a ≃ Q (e .map a)</a>
  <a id="12899" class="Comment">--   Γ a = equiv (F a) (iseq a)</a>

  <a id="12934" class="Comment">-- uaP : PathP (λ i → ua e i → Type ℓ&#39;) P Q</a>
  <a id="12980" class="Comment">-- uaP i x = Glue Base {∂ i} equiv-boundary where</a>
  <a id="13032" class="Comment">--   -- Like `ua`, `uaOver` is obtained from a line of</a>
  <a id="13089" class="Comment">--   -- Glue-types, except that they are glued</a>
  <a id="13138" class="Comment">--   -- over a line dependent on `ua e : A ≡ B`.</a>

  <a id="13190" class="Comment">--   -- `x` is a point along the path `A ≡ B` obtained</a>
  <a id="13247" class="Comment">--   -- from univalence, i.e. glueing over `B`:</a>
  <a id="13297" class="Comment">--   --</a>
  <a id="13307" class="Comment">--   --  A = = (ua e) = = B</a>
  <a id="13337" class="Comment">--   --  |                |</a>
  <a id="13367" class="Comment">--   -- (e)          (idEquiv B)</a>
  <a id="13402" class="Comment">--   --  |                |</a>
  <a id="13432" class="Comment">--   --  v                v</a>
  <a id="13462" class="Comment">--   --  B =====(B)====== B</a>
  <a id="13492" class="Comment">--   _ : Glue B {φ = i ∨ ~ i} (λ { (i = i0) → A , e ; (i = i1) → B , idEquiv B })</a>
  <a id="13576" class="Comment">--   _ = x</a>

  <a id="13590" class="Comment">--   -- We can therefore `unglue` it to obtain a term in the base line of `ua e`,</a>
  <a id="13674" class="Comment">--   -- i.e. term of type `B`:</a>
  <a id="13707" class="Comment">--   b : B</a>
  <a id="13720" class="Comment">--   b = unglue (∂ i) x</a>

  <a id="13747" class="Comment">--   -- This gives us a line `(i : I) ⊢ Base` in the universe of types,</a>
  <a id="13821" class="Comment">--   -- along which we can glue the equivalences `Γ x` and `idEquiv (Q x)`:</a>
  <a id="13899" class="Comment">--   --</a>
  <a id="13909" class="Comment">--   -- P (e x) = = = = = = Q x</a>
  <a id="13943" class="Comment">--   --    |                |</a>
  <a id="13975" class="Comment">--   --  (Γ x)        (idEquiv (Q x))</a>
  <a id="14015" class="Comment">--   --    |                |</a>
  <a id="14047" class="Comment">--   --    v                v</a>
  <a id="14079" class="Comment">--   --   Q x ===(Base)=== Q x</a>
  <a id="14112" class="Comment">--   Base : Type ℓ&#39;</a>
  <a id="14134" class="Comment">--   Base = Q b</a>

  <a id="14153" class="Comment">--   equiv-boundary : Partial (∂ i) (Σ[ T ∈ Type ℓ&#39; ] T ≃ Base)</a>
  <a id="14219" class="Comment">--   equiv-boundary (i = i0) = P x , Γ x</a>
  <a id="14262" class="Comment">--   equiv-boundary (i = i1) = Q x , idEquiv (Q x)</a>

  <a id="14316" class="Comment">--   -- Note that above `(i = i0) ⊢ x : A` and `(i = i1) ⊢ x : B`,</a>
  <a id="14385" class="Comment">--   -- thus `P x` and `Q x` are well-typed.</a>
  <a id="14432" class="Comment">--   _ : Partial i B</a>
  <a id="14455" class="Comment">--   _ = λ { (i = i1) → x }</a>

  <a id="14486" class="Comment">--   _ : Partial (~ i) A</a>
  <a id="14513" class="Comment">--   _ = λ { (i = i0) → x }</a>
</pre>
<pre class="Agda"><a id="14550" class="Comment">-- module _ {A A&#39; : Type ℓ} {B : A → Type ℓ&#39;} {B&#39; : A&#39; → Type ℓ&#39;} (e₁ : A ≃ A&#39;) (e₂ : (x : A) → B x ≃ B&#39; (e₁ .map x)) where</a>
<a id="14674" class="Comment">--   Σ-map-ua : (Σ[ a ∈ A ] B a) ≃ (Σ[ a&#39; ∈ A&#39; ] B&#39; a&#39;)</a>
<a id="14730" class="Comment">--   Σ-map-ua = au λ i → Σ[ a ∈ ua e₁ i ] uaP e₁ (λ x → e₂ x .map) (λ x → e₂ x .proof) i a</a>

<a id="14822" class="Comment">--   Σ-map-ua-step1 : Σ-map-ua .map ≡ λ (a , b) → (transport (ua e₁) a) , transport (λ i → uaP {P = B} {Q = B&#39;} e₁ (λ x → e₂ x .map) (λ x → e₂ x .proof) i (transport-filler (ua e₁) a i)) b</a>
<a id="15011" class="Comment">--   Σ-map-ua-step1 = refl</a>

<a id="15039" class="Comment">--   Σ-map-ua-underlying : Σ-map-ua .map ≡ Σ-map (e₁ .map) (λ a → e₂ a .map)</a>
<a id="15116" class="Comment">--   Σ-map-ua-underlying i (a , b) .fst = ua-comp e₁ a i</a>
<a id="15173" class="Comment">--   Σ-map-ua-underlying i (a , b) .snd = {!!}</a>
</pre>
<h2 id="addition-as-path-composition"><a class="header" href="#addition-as-path-composition">Addition as Path Composition</a></h2>
<p>Here’s a fun first application: we can implement addition in
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a></code> as composition of paths of type <code>ℤ ≡ ℤ</code>. This leads to a
one-line proof that addition is invertible.</p>
<p>We showed previously that <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#20120" class="Function">sucℤ</a></code> is an equivalence, and
univalence lets us turn this into a path <code>ℤ ≡ ℤ</code>.</p>
<pre class="Agda"><a id="sucℤ-≡"></a><a id="15541" href="2--Paths-and-Identifications.2-6--Univalence.html#15541" class="Function">sucℤ-≡</a> <a id="15548" class="Symbol">:</a> <a id="15550" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a> <a id="15552" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="15554" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a>
<a id="15556" href="2--Paths-and-Identifications.2-6--Univalence.html#15541" class="Function">sucℤ-≡</a> <a id="15563" class="Symbol">=</a> <a id="15565" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="15568" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#22485" class="Function">sucℤ-≃</a>
</pre>
<p>This is the path that corresponds to adding 1, and by composing this
path with itself repeatedly we can produce a path that corresponds to
adding any fixed integer.</p>
<p>This iterated composition makes sense for any path starting and ending
at the same element, so we define it in general. For negative
integers, we simply compose with the inverse of the loop. There are
two ways to define it, repeatedly composing on the left or composing
on the right. This choice will matter for later definitions, so
compose on the ∙right∙.</p>
<pre class="Agda"><a id="iterateⁿ"></a><a id="16109" href="2--Paths-and-Identifications.2-6--Univalence.html#16109" class="Function">iterateⁿ</a> <a id="16118" class="Symbol">:</a> <a id="16120" class="Symbol">{</a><a id="16121" href="2--Paths-and-Identifications.2-6--Univalence.html#16121" class="Bound">x</a> <a id="16123" class="Symbol">:</a> <a id="16125" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a><a id="16126" class="Symbol">}</a> <a id="16128" class="Symbol">→</a> <a id="16130" href="2--Paths-and-Identifications.2-6--Univalence.html#16121" class="Bound">x</a> <a id="16132" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="16134" href="2--Paths-and-Identifications.2-6--Univalence.html#16121" class="Bound">x</a> <a id="16136" class="Symbol">→</a> <a id="16138" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a> <a id="16140" class="Symbol">→</a> <a id="16142" href="2--Paths-and-Identifications.2-6--Univalence.html#16121" class="Bound">x</a> <a id="16144" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="16146" href="2--Paths-and-Identifications.2-6--Univalence.html#16121" class="Bound">x</a>
<a id="16148" class="Comment">-- Exercise: (Remember to be careful with `negsuc`!)</a>
<a id="16201" class="Comment">-- iterateⁿ p z = {!!}</a>

<a id="16505" class="Comment">-- To make sure you composed the right way:</a>
<a id="16549" href="2--Paths-and-Identifications.2-6--Univalence.html#16549" class="Function">_</a> <a id="16551" class="Symbol">=</a> <a id="16553" class="Symbol">λ</a> <a id="16555" class="Symbol">{</a><a id="16556" href="2--Paths-and-Identifications.2-6--Univalence.html#16556" class="Bound">A</a> <a id="16558" class="Symbol">:</a> <a id="16560" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="16564" class="Symbol">}</a> <a id="16566" class="Symbol">{</a><a id="16567" href="2--Paths-and-Identifications.2-6--Univalence.html#16567" class="Bound">x</a> <a id="16569" class="Symbol">:</a> <a id="16571" href="2--Paths-and-Identifications.2-6--Univalence.html#16556" class="Bound">A</a><a id="16572" class="Symbol">}</a> <a id="16574" class="Symbol">(</a><a id="16575" href="2--Paths-and-Identifications.2-6--Univalence.html#16575" class="Bound">p</a> <a id="16577" class="Symbol">:</a> <a id="16579" href="2--Paths-and-Identifications.2-6--Univalence.html#16567" class="Bound">x</a> <a id="16581" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="16583" href="2--Paths-and-Identifications.2-6--Univalence.html#16567" class="Bound">x</a><a id="16584" class="Symbol">)</a> <a id="16586" class="Symbol">→</a> <a id="16588" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="16603" class="Symbol">(</a><a id="16604" href="2--Paths-and-Identifications.2-6--Univalence.html#16109" class="Function">iterateⁿ</a> <a id="16613" href="2--Paths-and-Identifications.2-6--Univalence.html#16575" class="Bound">p</a> <a id="16615" class="Number">2</a><a id="16616" class="Symbol">)</a>    <a id="16621" class="Symbol">((</a><a id="16623" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a> <a id="16628" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#15950" class="Function Operator">∙</a> <a id="16630" href="2--Paths-and-Identifications.2-6--Univalence.html#16575" class="Bound">p</a><a id="16631" class="Symbol">)</a> <a id="16633" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#15950" class="Function Operator">∙</a> <a id="16635" href="2--Paths-and-Identifications.2-6--Univalence.html#16575" class="Bound">p</a><a id="16636" class="Symbol">)</a>
<a id="16638" href="2--Paths-and-Identifications.2-6--Univalence.html#16638" class="Function">_</a> <a id="16640" class="Symbol">=</a> <a id="16642" class="Symbol">λ</a> <a id="16644" class="Symbol">{</a><a id="16645" href="2--Paths-and-Identifications.2-6--Univalence.html#16645" class="Bound">A</a> <a id="16647" class="Symbol">:</a> <a id="16649" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="16653" class="Symbol">}</a> <a id="16655" class="Symbol">{</a><a id="16656" href="2--Paths-and-Identifications.2-6--Univalence.html#16656" class="Bound">x</a> <a id="16658" class="Symbol">:</a> <a id="16660" href="2--Paths-and-Identifications.2-6--Univalence.html#16645" class="Bound">A</a><a id="16661" class="Symbol">}</a> <a id="16663" class="Symbol">(</a><a id="16664" href="2--Paths-and-Identifications.2-6--Univalence.html#16664" class="Bound">p</a> <a id="16666" class="Symbol">:</a> <a id="16668" href="2--Paths-and-Identifications.2-6--Univalence.html#16656" class="Bound">x</a> <a id="16670" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="16672" href="2--Paths-and-Identifications.2-6--Univalence.html#16656" class="Bound">x</a><a id="16673" class="Symbol">)</a> <a id="16675" class="Symbol">→</a> <a id="16677" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="16692" class="Symbol">(</a><a id="16693" href="2--Paths-and-Identifications.2-6--Univalence.html#16109" class="Function">iterateⁿ</a> <a id="16702" href="2--Paths-and-Identifications.2-6--Univalence.html#16664" class="Bound">p</a> <a id="16704" class="Symbol">(</a><a id="16705" class="Number">-2</a><a id="16707" class="Symbol">))</a> <a id="16710" class="Symbol">((</a><a id="16712" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#24347" class="Function">sym</a> <a id="16716" href="2--Paths-and-Identifications.2-6--Univalence.html#16664" class="Bound">p</a><a id="16717" class="Symbol">)</a> <a id="16719" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#15950" class="Function Operator">∙</a> <a id="16721" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#24347" class="Function">sym</a> <a id="16725" href="2--Paths-and-Identifications.2-6--Univalence.html#16664" class="Bound">p</a><a id="16726" class="Symbol">)</a>
</pre>
<p>Then the path corresponding to adding any fixed integer is:</p>
<pre class="Agda"><a id="add-ℤ-≡"></a><a id="16798" href="2--Paths-and-Identifications.2-6--Univalence.html#16798" class="Function">add-ℤ-≡</a> <a id="16806" class="Symbol">:</a> <a id="16808" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a> <a id="16810" class="Symbol">→</a> <a id="16812" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a> <a id="16814" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="16816" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a>
<a id="16818" href="2--Paths-and-Identifications.2-6--Univalence.html#16798" class="Function">add-ℤ-≡</a> <a id="16826" class="Symbol">=</a> <a id="16828" href="2--Paths-and-Identifications.2-6--Univalence.html#16109" class="Function">iterateⁿ</a> <a id="16837" href="2--Paths-and-Identifications.2-6--Univalence.html#15541" class="Function">sucℤ-≡</a>
</pre>
<p>Here’s the upshot: we can define addition of integers by turning one
of them into a path using <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#16798" class="Function">add-ℤ-≡</a></code> and then transporting the other
integer along that path. Transport along a path created by univalence
applies the underlying function, which in this case is <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#20120" class="Function">sucℤ</a></code>. And
so transporting along this path repeatedly indeed adds one integer to
the other!</p>
<pre class="Agda"><a id="_+ℤᵘ_"></a><a id="17213" href="2--Paths-and-Identifications.2-6--Univalence.html#17213" class="Function Operator">_+ℤᵘ_</a> <a id="17219" class="Symbol">:</a> <a id="17221" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a> <a id="17223" class="Symbol">→</a> <a id="17225" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a> <a id="17227" class="Symbol">→</a> <a id="17229" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a>
<a id="17231" href="2--Paths-and-Identifications.2-6--Univalence.html#17231" class="Bound">m</a> <a id="17233" href="2--Paths-and-Identifications.2-6--Univalence.html#17213" class="Function Operator">+ℤᵘ</a> <a id="17237" href="2--Paths-and-Identifications.2-6--Univalence.html#17237" class="Bound">n</a> <a id="17239" class="Symbol">=</a> <a id="17241" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a> <a id="17251" class="Symbol">(</a><a id="17252" href="2--Paths-and-Identifications.2-6--Univalence.html#16798" class="Function">add-ℤ-≡</a> <a id="17260" href="2--Paths-and-Identifications.2-6--Univalence.html#17237" class="Bound">n</a><a id="17261" class="Symbol">)</a> <a id="17263" href="2--Paths-and-Identifications.2-6--Univalence.html#17231" class="Bound">m</a>

<a id="17266" href="2--Paths-and-Identifications.2-6--Univalence.html#17266" class="Function">_</a> <a id="17268" class="Symbol">=</a> <a id="17270" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="17285" class="Symbol">(</a><a id="17286" class="Number">0</a> <a id="17288" href="2--Paths-and-Identifications.2-6--Univalence.html#17213" class="Function Operator">+ℤᵘ</a> <a id="17292" class="Number">0</a><a id="17293" class="Symbol">)</a> <a id="17295" class="Number">0</a>
<a id="17297" href="2--Paths-and-Identifications.2-6--Univalence.html#17297" class="Function">_</a> <a id="17299" class="Symbol">=</a> <a id="17301" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="17316" class="Symbol">(</a><a id="17317" class="Number">0</a> <a id="17319" href="2--Paths-and-Identifications.2-6--Univalence.html#17213" class="Function Operator">+ℤᵘ</a> <a id="17323" class="Number">1</a><a id="17324" class="Symbol">)</a> <a id="17326" class="Number">1</a>
<a id="17328" href="2--Paths-and-Identifications.2-6--Univalence.html#17328" class="Function">_</a> <a id="17330" class="Symbol">=</a> <a id="17332" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="17347" class="Symbol">(</a><a id="17348" class="Number">1</a> <a id="17350" href="2--Paths-and-Identifications.2-6--Univalence.html#17213" class="Function Operator">+ℤᵘ</a> <a id="17354" class="Number">0</a><a id="17355" class="Symbol">)</a> <a id="17357" class="Number">1</a>
<a id="17359" href="2--Paths-and-Identifications.2-6--Univalence.html#17359" class="Function">_</a> <a id="17361" class="Symbol">=</a> <a id="17363" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="17378" class="Symbol">(</a><a id="17379" class="Number">19</a> <a id="17382" href="2--Paths-and-Identifications.2-6--Univalence.html#17213" class="Function Operator">+ℤᵘ</a> <a id="17386" class="Number">34</a><a id="17388" class="Symbol">)</a> <a id="17390" class="Number">53</a>
<a id="17393" href="2--Paths-and-Identifications.2-6--Univalence.html#17393" class="Function">_</a> <a id="17395" class="Symbol">=</a> <a id="17397" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="17412" class="Symbol">(</a><a id="17413" class="Number">-19</a> <a id="17417" href="2--Paths-and-Identifications.2-6--Univalence.html#17213" class="Function Operator">+ℤᵘ</a> <a id="17421" class="Number">34</a><a id="17423" class="Symbol">)</a> <a id="17425" class="Number">15</a>
</pre>
<p>It is easy to show that this always agrees with the ordinary addition
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#21426" class="Function">+ℤ</a></code>, by case-splitting on <code>n</code>.</p>
<pre class="Agda"><a id="+ℤᵘ≡+ℤ"></a><a id="17542" href="2--Paths-and-Identifications.2-6--Univalence.html#17542" class="Function">+ℤᵘ≡+ℤ</a> <a id="17549" class="Symbol">:</a> <a id="17551" href="2--Paths-and-Identifications.2-6--Univalence.html#17213" class="Function Operator">_+ℤᵘ_</a> <a id="17557" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="17559" href="1--Type-Theory.1-2--Inductive-Types.html#21426" class="Function Operator">_+ℤ_</a>
<a id="17564" class="Comment">-- Exercise:</a>
<a id="17577" class="Comment">-- +ℤᵘ≡+ℤ i m n = {!!}</a>
</pre>
<p>Now, a nice trick. Because <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#17213" class="Function">+ℤᵘ</a></code> for a fixed <code>n</code> is defined via
<code class="Agda"><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a></code>, it is automatically an equivalence:</p>
<pre class="Agda"><a id="isEquiv-+ℤᵘ"></a><a id="18009" href="2--Paths-and-Identifications.2-6--Univalence.html#18009" class="Function">isEquiv-+ℤᵘ</a> <a id="18021" class="Symbol">:</a> <a id="18023" class="Symbol">(</a><a id="18024" href="2--Paths-and-Identifications.2-6--Univalence.html#18024" class="Bound">m</a> <a id="18026" class="Symbol">:</a> <a id="18028" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a><a id="18029" class="Symbol">)</a> <a id="18031" class="Symbol">→</a> <a id="18033" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5559" class="Record">isEquiv</a> <a id="18041" class="Symbol">(λ</a> <a id="18044" href="2--Paths-and-Identifications.2-6--Univalence.html#18044" class="Bound">n</a> <a id="18046" class="Symbol">→</a> <a id="18048" href="2--Paths-and-Identifications.2-6--Univalence.html#18044" class="Bound">n</a> <a id="18050" href="2--Paths-and-Identifications.2-6--Univalence.html#17213" class="Function Operator">+ℤᵘ</a> <a id="18054" href="2--Paths-and-Identifications.2-6--Univalence.html#18024" class="Bound">m</a><a id="18055" class="Symbol">)</a>
<a id="18057" class="Comment">-- Exercise: (Hint: <code class="Agda"><a href="2--Paths-and-Identifications.2-5--Transport.html#5498" class="Function">path→equiv</a></code>)</a>
<a id="18093" class="Comment">-- isEquiv-+ℤᵘ n = {!!}</a>
</pre>
<p>And because we have just shown that <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#17213" class="Function">+ℤᵘ</a></code> is equal to
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#21426" class="Function">+ℤ</a></code>, we get a proof that the same is true for <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#21426" class="Function">+ℤ</a></code> with
no extra effort.</p>
<pre class="Agda"><a id="isEquiv-+ℤ"></a><a id="18334" href="2--Paths-and-Identifications.2-6--Univalence.html#18334" class="Function">isEquiv-+ℤ</a> <a id="18345" class="Symbol">:</a> <a id="18347" class="Symbol">(</a><a id="18348" href="2--Paths-and-Identifications.2-6--Univalence.html#18348" class="Bound">m</a> <a id="18350" class="Symbol">:</a> <a id="18352" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a><a id="18353" class="Symbol">)</a> <a id="18355" class="Symbol">→</a> <a id="18357" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5559" class="Record">isEquiv</a> <a id="18365" class="Symbol">(λ</a> <a id="18368" href="2--Paths-and-Identifications.2-6--Univalence.html#18368" class="Bound">n</a> <a id="18370" class="Symbol">→</a> <a id="18372" href="2--Paths-and-Identifications.2-6--Univalence.html#18368" class="Bound">n</a> <a id="18374" href="1--Type-Theory.1-2--Inductive-Types.html#21426" class="Function Operator">+ℤ</a> <a id="18377" href="2--Paths-and-Identifications.2-6--Univalence.html#18348" class="Bound">m</a><a id="18378" class="Symbol">)</a>
<a id="18380" class="Comment">-- Exercise:</a>
<a id="18393" class="Comment">-- isEquiv-+ℤ = subst {!!} {!!} {!!}</a>
</pre>
<h2 id="the-fundamental-group-of-the-circle"><a class="header" href="#the-fundamental-group-of-the-circle">The Fundamental Group of the Circle</a></h2>
<p>An amazing consequence of univalence is that it grants type theory
access to a lot of higher-dimensional homotopical structure. The
primary way it does this is by letting us construct interesting type
families.</p>
<p>Here’s a first example: the “double cover” of the circle <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a></code>. This
is a type family with two elements over <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a></code>, for which
<code class="Agda"><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a></code>ing along the <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a></code> flips those two points.</p>
<pre class="Agda"><a id="not-Path"></a><a id="18994" href="2--Paths-and-Identifications.2-6--Univalence.html#18994" class="Function">not-Path</a> <a id="19003" class="Symbol">:</a> <a id="19005" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="19010" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="19012" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="19017" href="2--Paths-and-Identifications.2-6--Univalence.html#18994" class="Function">not-Path</a> <a id="19026" class="Symbol">=</a> <a id="19028" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="19031" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#22083" class="Function">not-≃</a>

<a id="double-cover"></a><a id="19038" href="2--Paths-and-Identifications.2-6--Univalence.html#19038" class="Function">double-cover</a> <a id="19051" class="Symbol">:</a> <a id="19053" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a> <a id="19056" class="Symbol">→</a> <a id="19058" href="Library.Primitive.html#422" class="Primitive">Type</a>
<a id="19063" href="2--Paths-and-Identifications.2-6--Univalence.html#19038" class="Function">double-cover</a> <a id="19076" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a> <a id="19081" class="Symbol">=</a> <a id="19083" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="19088" href="2--Paths-and-Identifications.2-6--Univalence.html#19038" class="Function">double-cover</a> <a id="19101" class="Symbol">(</a><a id="19102" href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a> <a id="19107" href="2--Paths-and-Identifications.2-6--Univalence.html#19107" class="Bound">i</a><a id="19108" class="Symbol">)</a> <a id="19110" class="Symbol">=</a> <a id="19112" href="2--Paths-and-Identifications.2-6--Univalence.html#18994" class="Function">not-Path</a> <a id="19121" href="2--Paths-and-Identifications.2-6--Univalence.html#19107" class="Bound">i</a>
</pre>
<p>mvrnote: picture is mandatory here from hott game?</p>
<p>This type family lets us show that the circle is non-trivial, which is
a fact we didn’t know for sure previously!</p>
<pre class="Agda"><a id="refl≢loop"></a><a id="19299" href="2--Paths-and-Identifications.2-6--Univalence.html#19299" class="Function">refl≢loop</a> <a id="19309" class="Symbol">:</a> <a id="19311" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="19313" class="Symbol">(</a><a id="19314" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a> <a id="19319" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="19321" href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a><a id="19325" class="Symbol">)</a>
<a id="19327" class="Comment">-- Exercise: (Hint: Use <code class="Agda"><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1180" class="Function">subst</a></code> to prove `true ≡ false`.)</a>
<a id="19387" class="Comment">-- refl≢loop p = {!!}</a>
</pre>
<div class="info">
<p><span class="info-label">Aside:</span>
Without univalence or some other additional feature of type theory
beyond what we’ve seen so far, it is impossible to prove that <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a></code>
is nontrivial! With the bare constructions of type theory, it is
consistent to assume that <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a></code> is contractible.</p>
</div>
<p>There’s nothing special about <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> here. Rather than placing
two points over each point of the circle, we could put an entire copy
of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a></code>:</p>
<pre class="Agda"><a id="helix"></a><a id="19921" href="2--Paths-and-Identifications.2-6--Univalence.html#19921" class="Function">helix</a> <a id="19927" class="Symbol">:</a> <a id="19929" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a> <a id="19932" class="Symbol">→</a> <a id="19934" href="Library.Primitive.html#422" class="Primitive">Type</a>
<a id="19939" href="2--Paths-and-Identifications.2-6--Univalence.html#19921" class="Function">helix</a> <a id="19945" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a> <a id="19950" class="Symbol">=</a> <a id="19952" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a>
<a id="19954" href="2--Paths-and-Identifications.2-6--Univalence.html#19921" class="Function">helix</a> <a id="19960" class="Symbol">(</a><a id="19961" href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a> <a id="19966" href="2--Paths-and-Identifications.2-6--Univalence.html#19966" class="Bound">i</a><a id="19967" class="Symbol">)</a> <a id="19969" class="Symbol">=</a> <a id="19971" href="2--Paths-and-Identifications.2-6--Univalence.html#15541" class="Function">sucℤ-≡</a> <a id="19978" href="2--Paths-and-Identifications.2-6--Univalence.html#19966" class="Bound">i</a>
</pre>
<p>In the remainder of this section we will prove a crucial fact about
<code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a></code>: that the type of paths from <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a></code> to itself is equivalent
to the integers. That is, the following function is an equivalence:</p>
<pre class="Agda"><a id="loopⁿ"></a><a id="20195" href="2--Paths-and-Identifications.2-6--Univalence.html#20195" class="Function">loopⁿ</a> <a id="20201" class="Symbol">:</a> <a id="20203" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a> <a id="20205" class="Symbol">→</a> <a id="20207" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a> <a id="20212" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="20214" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a>
<a id="20219" href="2--Paths-and-Identifications.2-6--Univalence.html#20195" class="Function">loopⁿ</a> <a id="20225" class="Symbol">=</a> <a id="20227" href="2--Paths-and-Identifications.2-6--Univalence.html#16109" class="Function">iterateⁿ</a> <a id="20236" href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a>
</pre>
<p>This will be an encode-decode proof like those we did in Lecture 2-X,
with some slight differences which we will discuss when we encounter
them.</p>
<p>With the benefit of having done this before, we can tell you that the
following square is going to come in handy.</p>
<pre><code>                          p
                     ∙ — — — — &gt; ∙
                     ^           ^                      ^
iterateⁿ p (predℤ n) |           | iterateⁿ p n       j |
                     |           |                      ∙ — &gt;
                     ∙ — — — - &gt; ∙                        i
                         refl
</code></pre>
<p>It can be constructed pretty easily by induction on <code>n</code>.</p>
<pre class="Agda"><a id="iterateⁿ-predℤ-square"></a><a id="20929" href="2--Paths-and-Identifications.2-6--Univalence.html#20929" class="Function">iterateⁿ-predℤ-square</a> <a id="20951" class="Symbol">:</a> <a id="20953" class="Symbol">{</a><a id="20954" href="2--Paths-and-Identifications.2-6--Univalence.html#20954" class="Bound">x</a> <a id="20956" class="Symbol">:</a> <a id="20958" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a><a id="20959" class="Symbol">}</a> <a id="20961" class="Symbol">→</a> <a id="20963" class="Symbol">(</a><a id="20964" href="2--Paths-and-Identifications.2-6--Univalence.html#20964" class="Bound">p</a> <a id="20966" class="Symbol">:</a> <a id="20968" href="2--Paths-and-Identifications.2-6--Univalence.html#20954" class="Bound">x</a> <a id="20970" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="20972" href="2--Paths-and-Identifications.2-6--Univalence.html#20954" class="Bound">x</a><a id="20973" class="Symbol">)</a> <a id="20975" class="Symbol">→</a> <a id="20977" class="Symbol">(</a><a id="20978" href="2--Paths-and-Identifications.2-6--Univalence.html#20978" class="Bound">n</a> <a id="20980" class="Symbol">:</a> <a id="20982" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a><a id="20983" class="Symbol">)</a> <a id="20985" class="Symbol">→</a> <a id="20987" href="2--Paths-and-Identifications.2-1--Paths.html#24427" class="Function">Square</a> <a id="20994" class="Symbol">(</a><a id="20995" href="2--Paths-and-Identifications.2-6--Univalence.html#16109" class="Function">iterateⁿ</a> <a id="21004" href="2--Paths-and-Identifications.2-6--Univalence.html#20964" class="Bound">p</a> <a id="21006" class="Symbol">(</a><a id="21007" href="1--Type-Theory.1-2--Inductive-Types.html#20402" class="Function">predℤ</a> <a id="21013" href="2--Paths-and-Identifications.2-6--Univalence.html#20978" class="Bound">n</a><a id="21014" class="Symbol">))</a> <a id="21017" class="Symbol">(</a><a id="21018" href="2--Paths-and-Identifications.2-6--Univalence.html#16109" class="Function">iterateⁿ</a> <a id="21027" href="2--Paths-and-Identifications.2-6--Univalence.html#20964" class="Bound">p</a> <a id="21029" href="2--Paths-and-Identifications.2-6--Univalence.html#20978" class="Bound">n</a><a id="21030" class="Symbol">)</a> <a id="21032" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a> <a id="21037" href="2--Paths-and-Identifications.2-6--Univalence.html#20964" class="Bound">p</a>
<a id="21039" class="Comment">-- Exercise: (Hint: `∙-filler`.)</a>
<a id="21072" class="Comment">-- iterateⁿ-predℤ-square p n i j = {!!}</a>
</pre>
<p>Now let’s jump straight into the proof.</p>
<pre class="Agda"><a id="ΩS¹≃ℤ"></a><a id="21472" href="2--Paths-and-Identifications.2-6--Univalence.html#21472" class="Function">ΩS¹≃ℤ</a> <a id="21478" class="Symbol">:</a> <a id="21480" class="Symbol">(</a><a id="21481" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a> <a id="21486" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="21488" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a><a id="21492" class="Symbol">)</a> <a id="21494" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="21496" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a>
<a id="21498" href="2--Paths-and-Identifications.2-6--Univalence.html#21472" class="Function">ΩS¹≃ℤ</a> <a id="21504" class="Symbol">=</a> <a id="21506" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#7290" class="Function">inv→equiv</a> <a id="21516" class="Symbol">(</a><a id="21517" href="2--Paths-and-Identifications.2-6--Univalence.html#22218" class="Function">encode</a> <a id="21524" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a><a id="21528" class="Symbol">)</a> <a id="21530" class="Symbol">(</a><a id="21531" href="2--Paths-and-Identifications.2-6--Univalence.html#22372" class="Function">decode</a> <a id="21538" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a><a id="21542" class="Symbol">)</a> <a id="21544" href="2--Paths-and-Identifications.2-6--Univalence.html#28074" class="Function">fro-to</a> <a id="21551" href="2--Paths-and-Identifications.2-6--Univalence.html#27684" class="Function">to-fro</a>
  <a id="21560" class="Keyword">where</a>
</pre>
<div class="info">
<p><span class="info-label">Aside:</span>
In homotopy theory, the space of paths beginning and ending at a fixed
point of a space is called the <em>loop space</em> based at that point, and
is usually denoted using <code>Ω</code>.</p>
</div>
<p>First, the codes for the paths. Because we are ultimately only
interested in <code>base ≡ base</code>, we just give codes for paths of the form
<code>base ≡ x</code>. For this, we use exactly the <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#19921" class="Function">helix</a></code> type family defined
above.</p>
<pre class="Agda">    <a id="21977" href="2--Paths-and-Identifications.2-6--Univalence.html#21977" class="Function">code</a> <a id="21982" class="Symbol">:</a> <a id="21984" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a> <a id="21987" class="Symbol">→</a> <a id="21989" href="Library.Primitive.html#422" class="Primitive">Type</a>
    <a id="21998" href="2--Paths-and-Identifications.2-6--Univalence.html#21977" class="Function">code</a> <a id="22003" class="Symbol">=</a> <a id="22005" href="2--Paths-and-Identifications.2-6--Univalence.html#19921" class="Function">helix</a>
</pre>
<p>Then <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#22164" class="Function">encodeRefl</a></code> and <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#22218" class="Function">encode</a></code> are defined as usual,
though <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#22164" class="Function">encodeRefl</a></code> is particularly simple because we only care
about <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a></code>.</p>
<pre class="Agda">    <a id="22164" href="2--Paths-and-Identifications.2-6--Univalence.html#22164" class="Function">encodeRefl</a> <a id="22175" class="Symbol">:</a> <a id="22177" href="2--Paths-and-Identifications.2-6--Univalence.html#21977" class="Function">code</a> <a id="22182" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a>
    <a id="22191" href="2--Paths-and-Identifications.2-6--Univalence.html#22164" class="Function">encodeRefl</a> <a id="22202" class="Symbol">=</a> <a id="22204" href="1--Type-Theory.1-2--Inductive-Types.html#19056" class="InductiveConstructor">pos</a> <a id="22208" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>

    <a id="22218" href="2--Paths-and-Identifications.2-6--Univalence.html#22218" class="Function">encode</a> <a id="22225" class="Symbol">:</a> <a id="22227" class="Symbol">(</a><a id="22228" href="2--Paths-and-Identifications.2-6--Univalence.html#22228" class="Bound">x</a> <a id="22230" class="Symbol">:</a> <a id="22232" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a><a id="22234" class="Symbol">)</a> <a id="22236" class="Symbol">→</a> <a id="22238" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a> <a id="22243" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="22245" href="2--Paths-and-Identifications.2-6--Univalence.html#22228" class="Bound">x</a> <a id="22247" class="Symbol">→</a> <a id="22249" href="2--Paths-and-Identifications.2-6--Univalence.html#21977" class="Function">code</a> <a id="22254" href="2--Paths-and-Identifications.2-6--Univalence.html#22228" class="Bound">x</a>
    <a id="22260" href="2--Paths-and-Identifications.2-6--Univalence.html#22218" class="Function">encode</a> <a id="22267" href="2--Paths-and-Identifications.2-6--Univalence.html#22267" class="Bound">x</a> <a id="22269" href="2--Paths-and-Identifications.2-6--Univalence.html#22269" class="Bound">p</a> <a id="22271" class="Symbol">=</a> <a id="22273" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#5445" class="Function">J</a> <a id="22275" class="Symbol">(λ</a> <a id="22278" href="2--Paths-and-Identifications.2-6--Univalence.html#22278" class="Bound">y</a> <a id="22280" href="2--Paths-and-Identifications.2-6--Univalence.html#22280" class="Bound">_</a> <a id="22282" class="Symbol">→</a> <a id="22284" href="2--Paths-and-Identifications.2-6--Univalence.html#21977" class="Function">code</a> <a id="22289" href="2--Paths-and-Identifications.2-6--Univalence.html#22278" class="Bound">y</a><a id="22290" class="Symbol">)</a> <a id="22292" href="2--Paths-and-Identifications.2-6--Univalence.html#22164" class="Function">encodeRefl</a> <a id="22303" href="2--Paths-and-Identifications.2-6--Univalence.html#22269" class="Bound">p</a>
</pre>
<p>Now for <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#22372" class="Function">decode</a></code>, which will take a lot more work.</p>
<pre class="Agda">    <a id="22372" href="2--Paths-and-Identifications.2-6--Univalence.html#22372" class="Function">decode</a> <a id="22379" class="Symbol">:</a> <a id="22381" class="Symbol">(</a><a id="22382" href="2--Paths-and-Identifications.2-6--Univalence.html#22382" class="Bound">x</a> <a id="22384" class="Symbol">:</a> <a id="22386" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a><a id="22388" class="Symbol">)</a> <a id="22390" class="Symbol">→</a> <a id="22392" href="2--Paths-and-Identifications.2-6--Univalence.html#21977" class="Function">code</a> <a id="22397" href="2--Paths-and-Identifications.2-6--Univalence.html#22382" class="Bound">x</a> <a id="22399" class="Symbol">→</a> <a id="22401" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a> <a id="22406" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="22408" href="2--Paths-and-Identifications.2-6--Univalence.html#22382" class="Bound">x</a>
</pre>
<p>We now case-split on <code>x</code>, so we will need to give cases for
<code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a></code> and <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a></code>. The <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a></code> case is easy: we
have an element of <code>code base</code>, i.e. an integer, and we need to
produce a path <code>base ≡ base</code>. For this we have the function
<code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#20195" class="Function">loopⁿ</a></code> from earlier.</p>
<pre class="Agda">    <a id="22685" href="2--Paths-and-Identifications.2-6--Univalence.html#22372" class="Function">decode</a> <a id="22692" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a> <a id="22697" class="Symbol">=</a> <a id="22699" href="2--Paths-and-Identifications.2-6--Univalence.html#20195" class="Function">loopⁿ</a>
</pre>
<p>In the <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a></code> case, we will be asked to fill in the following
<code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#25495" class="Function">SquareP</a></code>, where <code>y : code (loop i)</code>, or recalling the definition,
<code>y : sucℤ-≡ i</code>: (In the following diagrams, all the vertices are
always <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a></code>.)</p>
<pre><code>            loop
        ∙ — — — — &gt; ∙
        ^           ^                   ^
loopⁿ y |           | loopⁿ y         j |
        |           |                   ∙ — &gt;
        ∙ — — — — &gt; ∙                     i
            refl
</code></pre>
<p>It might look odd to have <code>loopⁿ y j</code> on both sides: it seems it ought
to be impossible to fill this square, because we have <code>n</code> copies of
<code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a></code> going around one way and <code>n+1</code> copies going around the
other.</p>
<p>The reason is that the variable <code>y</code> has type <code>sucℤ-≡ i</code> rather than
being a a fixed integer: it varies along the type family <code>code (loop i)</code> as <code>i</code> goes from <code class="Agda"><a href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a></code> to <code class="Agda"><a href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a></code>. By the definition of <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#19921" class="Function">helix</a></code>,
<code>y</code> has type <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a></code> when <code>i</code> is <code class="Agda"><a href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a></code> or <code class="Agda"><a href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a></code>, but while moving
along the path between these, we have transported <code>n</code> to <code>suc n</code>. And
so the square should commute: going around either way should be <code>loopⁿ (suc n)</code>.</p>
<p>We can build this square as an <code class="Agda"><a href="Library.Prelude.html#650" class="Function">hcomp</a></code>. Here’s the cube we are
going to fill, with the desired square sitting on the top.</p>
<pre><code>                                  loop
                            ∙ — — — — — — — — &gt; ∙
                loopⁿ y   / ^                 / ^
                        /   |               / loopⁿ y
                      /     | refl        /     |
                    ∙ — — — — — — — — &gt; ∙       |
                    ^       |           ^       |              ^   j
                    |       |           |       |            k | /
                    |       |           |       |              ∙ — &gt;
                    |       |    loop   |       |                i
                    |       ∙ — — — — — | — — &gt; ∙
loopⁿ (predℤ (sucℤ y))    /             |     /
                    |   /               |   /  loopⁿ y
                    | /                 | /
                    ∙ — — — — — — — — &gt; ∙
                            refl
</code></pre>
<p>Again, we have to be careful — this is really a “Cube-over”, because
the type of <code>y</code> varies over the <code>i</code> direction.</p>
<pre class="Agda">    <a id="24977" href="2--Paths-and-Identifications.2-6--Univalence.html#22372" class="Function">decode</a> <a id="24984" class="Symbol">(</a><a id="24985" href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a> <a id="24990" href="2--Paths-and-Identifications.2-6--Univalence.html#24990" class="Bound">i</a><a id="24991" class="Symbol">)</a> <a id="24993" href="2--Paths-and-Identifications.2-6--Univalence.html#24993" class="Bound">y</a> <a id="24995" href="2--Paths-and-Identifications.2-6--Univalence.html#24995" class="Bound">j</a> <a id="24997" class="Symbol">=</a> <a id="24999" href="Library.Prelude.html#650" class="Function">hcomp</a> <a id="25005" class="Symbol">(</a><a id="25006" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#6524" class="Function">∂</a> <a id="25008" href="2--Paths-and-Identifications.2-6--Univalence.html#24990" class="Bound">i</a> <a id="25010" href="Library.Prelude.html#387" class="Primitive Operator">∨</a> <a id="25012" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#6524" class="Function">∂</a> <a id="25014" href="2--Paths-and-Identifications.2-6--Univalence.html#24995" class="Bound">j</a><a id="25015" class="Symbol">)</a> <a id="25017" class="Symbol">(</a><a id="25018" href="2--Paths-and-Identifications.2-6--Univalence.html#25161" class="Function">decode-faces</a> <a id="25031" href="2--Paths-and-Identifications.2-6--Univalence.html#24990" class="Bound">i</a> <a id="25033" href="2--Paths-and-Identifications.2-6--Univalence.html#24993" class="Bound">y</a> <a id="25035" href="2--Paths-and-Identifications.2-6--Univalence.html#24995" class="Bound">j</a><a id="25036" class="Symbol">)</a>
      <a id="25044" class="Keyword">where</a>
</pre>
<p>Three of the sides are easy, they are just squares that are constant
in one of the directions.</p>
<pre class="Agda">      <a id="25161" href="2--Paths-and-Identifications.2-6--Univalence.html#25161" class="Function">decode-faces</a> <a id="25174" class="Symbol">:</a> <a id="25176" class="Symbol">(</a><a id="25177" href="2--Paths-and-Identifications.2-6--Univalence.html#25177" class="Bound">i</a> <a id="25179" class="Symbol">:</a> <a id="25181" href="Library.Primitive.html#1675" class="Datatype">I</a><a id="25182" class="Symbol">)</a> <a id="25184" class="Symbol">→</a> <a id="25186" class="Symbol">(</a><a id="25187" href="2--Paths-and-Identifications.2-6--Univalence.html#25187" class="Bound">y</a> <a id="25189" class="Symbol">:</a> <a id="25191" href="2--Paths-and-Identifications.2-6--Univalence.html#15541" class="Function">sucℤ-≡</a> <a id="25198" href="2--Paths-and-Identifications.2-6--Univalence.html#25177" class="Bound">i</a><a id="25199" class="Symbol">)</a> <a id="25201" class="Symbol">→</a> <a id="25203" class="Symbol">(</a><a id="25204" href="2--Paths-and-Identifications.2-6--Univalence.html#25204" class="Bound">j</a> <a id="25206" href="2--Paths-and-Identifications.2-6--Univalence.html#25206" class="Bound">k</a> <a id="25208" class="Symbol">:</a> <a id="25210" href="Library.Primitive.html#1675" class="Datatype">I</a><a id="25211" class="Symbol">)</a> <a id="25213" class="Symbol">→</a> <a id="25215" href="Library.Primitive.html#3205" class="Primitive">Partial</a> <a id="25223" class="Symbol">(</a><a id="25224" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#6524" class="Function">∂</a> <a id="25226" href="2--Paths-and-Identifications.2-6--Univalence.html#25177" class="Bound">i</a> <a id="25228" href="Library.Prelude.html#387" class="Primitive Operator">∨</a> <a id="25230" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#6524" class="Function">∂</a> <a id="25232" href="2--Paths-and-Identifications.2-6--Univalence.html#25204" class="Bound">j</a> <a id="25234" href="Library.Prelude.html#387" class="Primitive Operator">∨</a> <a id="25236" href="Library.Prelude.html#359" class="Primitive Operator">~</a> <a id="25238" href="2--Paths-and-Identifications.2-6--Univalence.html#25206" class="Bound">k</a><a id="25239" class="Symbol">)</a> <a id="25241" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a>
      <a id="25250" class="Comment">-- Exercise:</a>
      <a id="25269" href="2--Paths-and-Identifications.2-6--Univalence.html#25161" class="Function">decode-faces</a> <a id="25282" href="2--Paths-and-Identifications.2-6--Univalence.html#25282" class="Bound">i</a> <a id="25284" href="2--Paths-and-Identifications.2-6--Univalence.html#25284" class="Bound">y</a> <a id="25286" href="2--Paths-and-Identifications.2-6--Univalence.html#25286" class="Bound">j</a> <a id="25288" href="2--Paths-and-Identifications.2-6--Univalence.html#25288" class="Bound">k</a> <a id="25290" class="Symbol">(</a><a id="25291" href="2--Paths-and-Identifications.2-6--Univalence.html#25282" class="Bound">i</a> <a id="25293" class="Symbol">=</a> <a id="25295" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="25297" class="Symbol">)</a> <a id="25299" class="Symbol">=</a> <a id="25301" href="2--Paths-and-Identifications.2-6--Univalence.html#20195" class="Function">loopⁿ</a> <a id="25307" href="2--Paths-and-Identifications.2-6--Univalence.html#25284" class="Bound">y</a> <a id="25309" href="2--Paths-and-Identifications.2-6--Univalence.html#25286" class="Bound">j</a>
</pre>
<p>The <code>(i = i0)</code> face is slightly more interesting, here it is written
flat:</p>
<pre><code>            loopⁿ y
        ∙ — — — — — &gt; ∙
        ^             ^                  ^
   refl |             | refl           k |
        |             |                  ∙ — &gt;
        ∙ — — — — — &gt; ∙                    j
     loopⁿ (predℤ (sucℤ y))
</code></pre>
<p>A path <code>predℤ (sucℤ y) ≡ y</code> is provided by the retract part of the
equivalence <code class="Agda"><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#22485" class="Function">sucℤ-≃</a></code>, so we can use that rather than reconstructing
the path. It just has to be surround with <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#20195" class="Function">loopⁿ</a></code>.</p>
<pre class="Agda">      <a id="26014" class="Comment">-- Exercise:</a>
      <a id="26033" class="Comment">-- decode-faces i y j k (i = i0) = {!!}</a>
</pre>
<p>All that remains is to construct the base square and for this we have
to get our hands a little dirty. Written flat, this is the <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#25495" class="Function">SquareP</a></code></p>
<pre><code>                           loop
                       ∙ — — — — &gt; ∙
                       ^           ^                 ^
loopⁿ (predℤ (sucℤ y)) |           | loopⁿ y       j |
                       |           |                 ∙ — &gt;
                       ∙ — — — - &gt; ∙                   i
                           refl
</code></pre>
<p>This is really close to the <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#20929" class="Function">iterateⁿ-predℤ-square</a></code> that we defined in
advance, which looks like this:</p>
<pre><code>                           loop
                       ∙ — — — — &gt; ∙
                       ^           ^                 ^
       loopⁿ (predℤ n) |           | loopⁿ n       j |
                       |           |                 ∙ — &gt;
                       ∙ — — — - &gt; ∙                   i
                           refl
</code></pre>
<p>To make these match, we need to supply an <code>n</code> that is equal to <code>sucℤ y</code> on the left side and <code>y</code> on the right. This is exactly what
<code class="Agda"><a href="Library.Univalence.html#7366" class="Function">unglue</a></code>-ing <code>y</code> gives us: on the left side we apply the equivalence
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#20120" class="Function">sucℤ</a></code>, and on the right side, the identity equivalence.</p>
<pre class="Agda">      <a id="27420" href="2--Paths-and-Identifications.2-6--Univalence.html#25161" class="Function">decode-faces</a> <a id="27433" href="2--Paths-and-Identifications.2-6--Univalence.html#27433" class="Bound">i</a> <a id="27435" href="2--Paths-and-Identifications.2-6--Univalence.html#27435" class="Bound">y</a> <a id="27437" href="2--Paths-and-Identifications.2-6--Univalence.html#27437" class="Bound">j</a> <a id="27439" href="2--Paths-and-Identifications.2-6--Univalence.html#27439" class="Bound">k</a> <a id="27441" class="Symbol">(</a><a id="27442" href="2--Paths-and-Identifications.2-6--Univalence.html#27439" class="Bound">k</a> <a id="27444" class="Symbol">=</a> <a id="27446" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="27448" class="Symbol">)</a> <a id="27450" class="Symbol">=</a> <a id="27452" href="2--Paths-and-Identifications.2-6--Univalence.html#20929" class="Function">iterateⁿ-predℤ-square</a> <a id="27474" href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a> <a id="27479" class="Symbol">(</a><a id="27480" href="2--Paths-and-Identifications.2-6--Univalence.html#6983" class="Function">ua-unglue</a> <a id="27490" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#22485" class="Function">sucℤ-≃</a> <a id="27497" href="2--Paths-and-Identifications.2-6--Univalence.html#27433" class="Bound">i</a> <a id="27499" href="2--Paths-and-Identifications.2-6--Univalence.html#27435" class="Bound">y</a><a id="27500" class="Symbol">)</a> <a id="27502" href="2--Paths-and-Identifications.2-6--Univalence.html#27433" class="Bound">i</a> <a id="27504" href="2--Paths-and-Identifications.2-6--Univalence.html#27437" class="Bound">j</a>
</pre>
<p>Checking that one composite is equal to the identity is easy using
<code class="Agda"><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#5445" class="Function">J</a></code> as usual, because everything computes away to nothing when
the input path <code>p</code> is <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a></code>:</p>
<pre class="Agda">    <a id="27684" href="2--Paths-and-Identifications.2-6--Univalence.html#27684" class="Function">to-fro</a> <a id="27691" class="Symbol">:</a> <a id="27693" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#1716" class="Function">isSection</a> <a id="27703" class="Symbol">(</a><a id="27704" href="2--Paths-and-Identifications.2-6--Univalence.html#22372" class="Function">decode</a> <a id="27711" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a><a id="27715" class="Symbol">)</a> <a id="27717" class="Symbol">(</a><a id="27718" href="2--Paths-and-Identifications.2-6--Univalence.html#22218" class="Function">encode</a> <a id="27725" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a><a id="27729" class="Symbol">)</a>
    <a id="27735" class="Comment">-- Exercise:</a>
    <a id="27752" class="Comment">-- to-fro p = J {!!} {!!} {!!}</a>
</pre>
<p>And the other way can be verified by induction on <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a></code>.
(Remember that <code>decode base</code> is exactly <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#20195" class="Function">loopⁿ</a></code> by definition, so
we don’t have to worry about the complicated <code class="Agda"><a href="Library.Prelude.html#650" class="Function">hcomp</a></code>.)</p>
<pre class="Agda">    <a id="28074" href="2--Paths-and-Identifications.2-6--Univalence.html#28074" class="Function">fro-to</a> <a id="28081" class="Symbol">:</a> <a id="28083" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#4019" class="Function">isRetract</a> <a id="28093" class="Symbol">(</a><a id="28094" href="2--Paths-and-Identifications.2-6--Univalence.html#22372" class="Function">decode</a> <a id="28101" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a><a id="28105" class="Symbol">)</a> <a id="28107" class="Symbol">(</a><a id="28108" href="2--Paths-and-Identifications.2-6--Univalence.html#22218" class="Function">encode</a> <a id="28115" href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a><a id="28119" class="Symbol">)</a>
    <a id="28125" class="Comment">-- Exercise:</a>
    <a id="28142" class="Comment">-- fro-to n = {!!}</a>
</pre>
<p>And we’re done!</p>
<h2 id="addition-yet-again"><a class="header" href="#addition-yet-again">Addition Yet Again</a></h2>
<p>As a final demonstration in of univalence in this Lecture, let’s use
the <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#21472" class="Function">ΩS¹≃ℤ</a></code> equivalence to define addition of integers yet another
time. We now know that <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a></code> is equivalent to <code>base ≡ base</code> so we can
do this by finding a binary operation on <code>S¹</code> corresponding to
addition.</p>
<p>Geometrically, this operation is easy to describe. For any two points
on the circle, look at their angles from the basepoint and add those
angles together. (Or phrased another way, consider <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a></code> as the unit
circle in the complex plane, use multiplication of complex numbers.)</p>
<p>How do we describe this in type theory? If we fix one angle and let
the other one run from 0 to 360, the result runs around the circle
starting at the fixed angle. If we fix one of the points at <code>y</code> and
let the other run around <code>loop : base ≡ base</code>, we should get a path <code>y ≡ y</code> that also runs around <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a></code>. (Similar to <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a></code> itself, but
starting and ending at some point other than <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a></code>.)</p>
<pre class="Agda"><a id="rotate-loop"></a><a id="29451" href="2--Paths-and-Identifications.2-6--Univalence.html#29451" class="Function">rotate-loop</a> <a id="29463" class="Symbol">:</a> <a id="29465" class="Symbol">(</a><a id="29466" href="2--Paths-and-Identifications.2-6--Univalence.html#29466" class="Bound">y</a> <a id="29468" class="Symbol">:</a> <a id="29470" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a><a id="29472" class="Symbol">)</a> <a id="29474" class="Symbol">→</a> <a id="29476" href="2--Paths-and-Identifications.2-6--Univalence.html#29466" class="Bound">y</a> <a id="29478" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="29480" href="2--Paths-and-Identifications.2-6--Univalence.html#29466" class="Bound">y</a>
<a id="29482" class="Comment">-- Exercise: (Hint: We built the necessary square in Lecture 2-X!)</a>
<a id="29549" class="Comment">-- rotate-loop base       = loop</a>
<a id="29582" class="Comment">-- rotate-loop (loop i) j = {!!}</a>
</pre>
<p>Now the actual multiplication. The point <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13100" class="InductiveConstructor">base</a></code> of <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a></code> lies at
angle 0, so it should not move the other point at all. And in the
<code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#13112" class="InductiveConstructor">loop</a></code> case, the above operation <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#29451" class="Function">rotate-loop</a></code> is exactly what we
need.</p>
<pre class="Agda"><a id="_·S¹_"></a><a id="29966" href="2--Paths-and-Identifications.2-6--Univalence.html#29966" class="Function Operator">_·S¹_</a> <a id="29972" class="Symbol">:</a> <a id="29974" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a> <a id="29977" class="Symbol">→</a> <a id="29979" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a> <a id="29982" class="Symbol">→</a> <a id="29984" href="2--Paths-and-Identifications.2-1--Paths.html#13082" class="Datatype">S¹</a>
<a id="29987" class="Comment">-- Exercise:</a>
<a id="30000" class="Comment">-- base   ·S¹ y = {!!}</a>
<a id="30023" class="Comment">-- loop i ·S¹ y = {!!}</a>

<a id="30149" class="Keyword">infixl</a> <a id="30156" class="Number">30</a> <a id="30159" href="2--Paths-and-Identifications.2-6--Univalence.html#29966" class="Function Operator">_·S¹_</a>
</pre>
<p>Now combine this multiplication with the <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#21472" class="Function">ΩS¹≃ℤ</a></code> equivalence:
turn <code>x</code> and <code>y</code> into loops, multiply them, and turn the resulting
loop back into an element of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a></code>.</p>
<pre class="Agda"><a id="_+ℤᵐ_"></a><a id="30342" href="2--Paths-and-Identifications.2-6--Univalence.html#30342" class="Function Operator">_+ℤᵐ_</a> <a id="30348" class="Symbol">:</a> <a id="30350" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a> <a id="30352" class="Symbol">→</a> <a id="30354" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a> <a id="30356" class="Symbol">→</a> <a id="30358" href="1--Type-Theory.1-2--Inductive-Types.html#19039" class="Datatype">ℤ</a>
<a id="30360" class="Comment">-- Exercise:</a>
<a id="30373" class="Comment">-- x +ℤᵐ y = equivFun ΩS¹≃ℤ {!!}</a>

<a id="30533" href="2--Paths-and-Identifications.2-6--Univalence.html#30533" class="Function">_</a> <a id="30535" class="Symbol">=</a> <a id="30537" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="30552" class="Symbol">(</a><a id="30553" class="Number">0</a> <a id="30555" href="2--Paths-and-Identifications.2-6--Univalence.html#30342" class="Function Operator">+ℤᵐ</a> <a id="30559" class="Number">0</a><a id="30560" class="Symbol">)</a> <a id="30562" class="Number">0</a>
<a id="30564" href="2--Paths-and-Identifications.2-6--Univalence.html#30564" class="Function">_</a> <a id="30566" class="Symbol">=</a> <a id="30568" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="30583" class="Symbol">(</a><a id="30584" class="Number">0</a> <a id="30586" href="2--Paths-and-Identifications.2-6--Univalence.html#30342" class="Function Operator">+ℤᵐ</a> <a id="30590" class="Number">1</a><a id="30591" class="Symbol">)</a> <a id="30593" class="Number">1</a>
<a id="30595" href="2--Paths-and-Identifications.2-6--Univalence.html#30595" class="Function">_</a> <a id="30597" class="Symbol">=</a> <a id="30599" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="30614" class="Symbol">(</a><a id="30615" class="Number">1</a> <a id="30617" href="2--Paths-and-Identifications.2-6--Univalence.html#30342" class="Function Operator">+ℤᵐ</a> <a id="30621" class="Number">0</a><a id="30622" class="Symbol">)</a> <a id="30624" class="Number">1</a>
<a id="30626" href="2--Paths-and-Identifications.2-6--Univalence.html#30626" class="Function">_</a> <a id="30628" class="Symbol">=</a> <a id="30630" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="30645" class="Symbol">(</a><a id="30646" class="Number">19</a> <a id="30649" href="2--Paths-and-Identifications.2-6--Univalence.html#30342" class="Function Operator">+ℤᵐ</a> <a id="30653" class="Number">34</a><a id="30655" class="Symbol">)</a> <a id="30657" class="Number">53</a>
<a id="30660" href="2--Paths-and-Identifications.2-6--Univalence.html#30660" class="Function">_</a> <a id="30662" class="Symbol">=</a> <a id="30664" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="30679" class="Symbol">(</a><a id="30680" class="Number">-19</a> <a id="30684" href="2--Paths-and-Identifications.2-6--Univalence.html#30342" class="Function Operator">+ℤᵐ</a> <a id="30688" class="Number">34</a><a id="30690" class="Symbol">)</a> <a id="30692" class="Number">15</a>
</pre>
<h2 id="references-and-further-reading"><a class="header" href="#references-and-further-reading">References and Further Reading</a></h2>
<p>mvrnote: original proof for  S^1
proof of S^1 in other libraries</p>
<ul>
<li>https://arxiv.org/abs/1611.02108
Cubical Type Theory: a constructive interpretation of the univalence axiom
Cyril Cohen, Thierry Coquand, Simon Huber, Anders Mörtberg</li>
</ul>

                  </main>
                  <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                  </div>
                </div>
            </div>
        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>


    </div>
    </body>
</html>
