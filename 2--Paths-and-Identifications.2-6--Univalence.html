<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2.6: Univalence - Introduction to Homotopy Type Theory in Cubical Agda</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/Agda.css">
        <link rel="stylesheet" href="theme/css/Agda-highlight.css">
        <link rel="stylesheet" href="theme/pagetoc.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Home</a></li><li class="chapter-item affix "><a href="INSTALLING_AGDA.html">Installing Agda</a></li><li class="chapter-item affix "><a href="USING_AGDA.html">Using Agda</a></li><li class="chapter-item affix "><li class="part-title">Type Theory</li><li class="chapter-item "><a href="1--Type-Theory.1-1--Types-and-Functions.html">1.1: Types and Functions</a></li><li class="chapter-item "><a href="1--Type-Theory.1-2--Inductive-Types.html">1.2: Inductive Types</a></li><li class="chapter-item "><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html">1.3: Universes and More Inductive Types</a></li><li class="chapter-item "><a href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html">1.4: Record Types and Copatterns</a></li><li class="chapter-item "><a href="1--Type-Theory.1-5--Propositions-as-Types.html">1.5: Propositions as Types</a></li><li class="chapter-item affix "><li class="part-title">Paths and Identifications</li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-1--Paths.html">2.1: Paths</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html">2.2: Equivalences and Path Algebra</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html">2.3: Substitution and J</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html">2.4: Composition and Filling</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-5--Transport.html">2.5: Transport</a></li><li class="chapter-item expanded "><a href="2--Paths-and-Identifications.2-6--Univalence.html" class="active">2.6: Univalence</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-7--Propositions.html">2.7: Propositions</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-8--Sets.html">2.8: Sets</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-9--Contractible-Maps.html">2.9: Contractible Maps</a></li><li class="chapter-item affix "><li class="part-title">Topics</li><li class="chapter-item "><a href="3--Topics.3-1--Structure-Identity-Principle.html">3.1: The Structure Identity Principle</a></li><li class="chapter-item "><a href="3--Topics.3-2--Modalities.html">3.2: Modalities</a></li><li class="chapter-item "><a href="3--Topics.3-3--Constructive-Logic.html">3.3: Constructive Logic</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="Library.Primitive.html">Primitives</a></li><li class="chapter-item affix "><a href="Library.Prelude.html">Prelude</a></li><li class="chapter-item affix "><a href="Library.Univalence.html">Univalence</a></li><li class="chapter-item affix "><a href="UNICODE_DICTIONARY.html">Unicode Dictionary</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="ACKNOWLEDGEMENTS.html">Acknowledgements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <!-- <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li> -->
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Homotopy Type Theory in Cubical Agda</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/CQTS/introduction-to-cubical" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                  <main>
                    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<!--
<pre class="Agda"><a id="10" class="Keyword">module</a> <a id="17" href="2--Paths-and-Identifications.2-6--Univalence.html" class="Module">2--Paths-and-Identifications.2-6--Univalence</a> <a id="62" class="Keyword">where</a>

<a id="69" class="Keyword">open</a> <a id="74" class="Keyword">import</a> <a id="81" href="Library.Prelude.html" class="Module">Library.Prelude</a>
<a id="97" class="Keyword">open</a> <a id="102" class="Keyword">import</a> <a id="109" href="1--Type-Theory.1-2--Inductive-Types.html" class="Module">1--Type-Theory.1-2--Inductive-Types</a>
<a id="145" class="Keyword">open</a> <a id="150" class="Keyword">import</a> <a id="157" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html" class="Module">1--Type-Theory.1-3--Universes-and-More-Inductive-Types</a>
<a id="212" class="Keyword">open</a> <a id="217" class="Keyword">import</a> <a id="224" href="1--Type-Theory.1-5--Propositions-as-Types.html" class="Module">1--Type-Theory.1-5--Propositions-as-Types</a>
<a id="266" class="Keyword">open</a> <a id="271" class="Keyword">import</a> <a id="278" href="2--Paths-and-Identifications.2-1--Paths.html" class="Module">2--Paths-and-Identifications.2-1--Paths</a>
<a id="318" class="Keyword">open</a> <a id="323" class="Keyword">import</a> <a id="330" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html" class="Module">2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra</a>
<a id="394" class="Keyword">open</a> <a id="399" class="Keyword">import</a> <a id="406" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html" class="Module">2--Paths-and-Identifications.2-3--Substitution-and-J</a>
<a id="459" class="Keyword">open</a> <a id="464" class="Keyword">import</a> <a id="471" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html" class="Module">2--Paths-and-Identifications.2-4--Composition-and-Filling</a>
<a id="529" class="Keyword">open</a> <a id="534" class="Keyword">import</a> <a id="541" href="2--Paths-and-Identifications.2-5--Transport.html" class="Module">2--Paths-and-Identifications.2-5--Transport</a>
<a id="585" class="Keyword">open</a> <a id="590" class="Keyword">import</a> <a id="597" href="Library.Univalence.html" class="Module">Library.Univalence</a>

<a id="617" class="Keyword">private</a>
  <a id="627" class="Keyword">variable</a>
    <a id="640" href="2--Paths-and-Identifications.2-6--Univalence.html#640" class="Generalizable">ℓ</a> <a id="642" href="2--Paths-and-Identifications.2-6--Univalence.html#642" class="Generalizable">ℓ&#39;</a> <a id="645" href="2--Paths-and-Identifications.2-6--Univalence.html#645" class="Generalizable">ℓ&#39;&#39;</a> <a id="649" class="Symbol">:</a> <a id="651" href="Library.Primitive.html#1060" class="Postulate">Level</a>
    <a id="661" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="663" href="2--Paths-and-Identifications.2-6--Univalence.html#663" class="Generalizable">A&#39;</a> <a id="666" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a> <a id="668" href="2--Paths-and-Identifications.2-6--Univalence.html#668" class="Generalizable">B&#39;</a> <a id="671" href="2--Paths-and-Identifications.2-6--Univalence.html#671" class="Generalizable">C</a> <a id="673" class="Symbol">:</a> <a id="675" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="680" href="2--Paths-and-Identifications.2-6--Univalence.html#640" class="Generalizable">ℓ</a>
</pre>-->
<h1 id="lecture-2-6-univalence"><a class="header" href="#lecture-2-6-univalence">Lecture 2-6: Univalence</a></h1>
<p>We’ve spent a lot of time characterising paths in the various types we
have available. The one type we haven’t done this for is the universe
of types <code class="Agda"><a href="Library.Primitive.html#422" class="Primitive">Type</a></code>.</p>
<p>Transport turns any path into an equivalence, as we showed in
<code class="Agda"><a href="2--Paths-and-Identifications.2-5--Transport.html#5441" class="Function">path→equiv</a></code>. But can every equivalence be produced this way? The
<em>univalence principle</em> says yes, that <code class="Agda"><a href="2--Paths-and-Identifications.2-5--Transport.html#5441" class="Function">path→equiv</a></code> is itself an
equivalence, and so every equivalence of types <code>A ≃ B</code> can be turned
back into a path of types <code>A ≡ B</code>.</p>
<p>In the original versions of Homotopy Type Theory, the univalence
principle is simply asserted as an axiom.</p>
<pre><code>univalence-axiom : {A B : Type ℓ} → isEquiv (path→equiv {A = A} {B = B})
</code></pre>
<p>If this principle is provided as an unproven axiom rather than
something with a definition, constructions involving it can’t hope to
compute. For example, suppose we use this axiom to turn the
equivalence <code class="Agda"><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6878" class="Function">Bool≃RedOrBlue</a></code> into a path <code>Bool ≡ RedOrBlue</code>. If we
transport <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a></code> over this path, we would hope to get exactly
<code class="Agda"><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#2955" class="InductiveConstructor">red</a></code>, following the definition of the equivalence. But with the
above axiom, the transport expression is stuck and it has to be proven
manually that we indeed get <code class="Agda"><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#2955" class="InductiveConstructor">red</a></code>.</p>
<p>Cubical Type Theory’s central accomplishment is allowing the
univalence principle to compute in situations like this.</p>
<div class="info">
<p><span class="info-label">Aside:</span>
Really, the original univalence axiom is defined in a setting that
uses “identity types” mvrnote: link (defined as the
inductive type that has the <code class="Agda"><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#5310" class="Function">J</a></code> rule as its eliminator) as its
notion of equality, rather than the cubical path types we have been
using. But the spirit is the same.</p>
</div>
<h2 id="glue-types"><a class="header" href="#glue-types">Glue Types</a></h2>
<p>The feature of Cubical Type Theory needed for univalence is <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code>
types, a type constructor which has the following shape:</p>
<pre><code>Glue : (A : Type ℓ) {φ : I}
     → (Te : Partial φ (Σ[ T ∈ Type ℓ' ] T ≃ A))
     → Type ℓ'
</code></pre>
<p>The type constructor <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> takes a type <code>A</code>, a formula <code>φ</code>, and a
partial element <code>Te : Partial φ (Σ[ T ∈ Type ] (T ≃ A))</code> of types
equipped with an equivalence to <code>A</code> (defined only when <code>φ</code> is <code class="Agda"><a href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a></code>).</p>
<p>As usual, we should be thinking of ourselves in a context that already
has some interval variables in it, with <code>φ</code> a formula describing some
subcube.</p>
<p>Suppose we have an interval variable <code>i</code>, and let’s fix the formula
<code>φ</code> to be <code>φ = ∂ i</code>. We can depict an element of the partial type <code>Te : Partial (∂ i) (Σ[ T ∈ Type ℓ' ] T ≃ A)</code> as follows:</p>
<pre><code>             A i
     A i0  — — — &gt; A i1
       ^             ^                ^
Te i0  (             (  Te i1         )
       )             )                ∙ — &gt;
     T i0          T i1                 i
</code></pre>
<p>where the vertical squiggly lines are equivalences rather than paths.
The type <code>A</code> is defined everywhere along the dimension <code>i</code>, but the
type <code>T</code> is only defined when <code>φ</code> holds, so on the left and right
sides.</p>
<p>This picture a lot like the kind of thing we were <code class="Agda"><a href="Library.Prelude.html#650" class="Function">hcomp</a></code>ing over in
Lecture 2-X, except that it is open on the bottom rather than the top.
(This is a conventional choice — the equivalences go into <code>A</code>,
rather than out of it.)</p>
<p>A <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> type enable us to “cap off” this open box of types, giving us a . That
is, if <code>φ = ∂ i</code>, then <code>Glue A Te : Type</code> is the line of types living
<em>under</em> <code>A</code> in the capped off version of the above square.</p>
<p><code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> types come with some guarantees about how they compute in
special cases. Like <code class="Agda"><a href="Library.Prelude.html#650" class="Function">hcomp</a></code>, the line we get agrees with the partial
input anywhere the formula <code>φ</code> holds. In the above case, this means</p>
<p>∙ <code>Glue A Te</code> is <code>T i0</code> when <code>i = i0</code> and
∙ <code>Glue A Te</code> is <code>T i1</code> when <code>i = i1</code>.</p>
<p>For any element of <code>Glue A Te</code>, regardless of whether <code>φ</code> holds, we
can extract an underlying element of <code>A</code>. This operation is called
<code>unglue φ</code>, and has type <code>Glue A Te → A</code>. Because of the above
guarantees, if <code>φ</code> does in fact hold then the domain of this function
is equal to <code>T</code>. Luckily, in this situation we have access to an
equivalence <code>T ≃ A</code>, because <code>Te</code> is defined when <code>φ</code> holds, and this
equivalence provides the necessary function <code>T → A</code>.</p>
<p>To summarise, <code>Glue A Te</code> is a version of <code>A</code> that has the types <code>T</code>
glued on wherever <code>φ</code> holds, using the provided equivalences <code>Te</code> to
extract an element of <code>A</code> whenever asked.</p>
<p>The first and most important example of a <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> type gives us an
inverse to the <code class="Agda"><a href="2--Paths-and-Identifications.2-5--Transport.html#5441" class="Function">path→equiv</a></code> map, building a path out of an
equivalence of types.</p>
<pre><code>       B
  B — — — &gt; B
  ^         ^                         ^
e (         ( idEquiv                 )
  )         )                         ∙ — &gt;
  A         B                           i
</code></pre>
<pre class="Agda"><a id="ua"></a><a id="5276" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="5279" class="Symbol">:</a> <a id="5281" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="5283" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="5285" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a> <a id="5287" class="Symbol">→</a> <a id="5289" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="5291" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="5293" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a>
<a id="5295" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="5298" class="Symbol">{</a><a id="5299" class="Argument">A</a> <a id="5301" class="Symbol">=</a> <a id="5303" href="2--Paths-and-Identifications.2-6--Univalence.html#5303" class="Bound">A</a><a id="5304" class="Symbol">}</a> <a id="5306" class="Symbol">{</a><a id="5307" class="Argument">B</a> <a id="5309" class="Symbol">=</a> <a id="5311" href="2--Paths-and-Identifications.2-6--Univalence.html#5311" class="Bound">B</a><a id="5312" class="Symbol">}</a> <a id="5314" href="2--Paths-and-Identifications.2-6--Univalence.html#5314" class="Bound">e</a> <a id="5316" href="2--Paths-and-Identifications.2-6--Univalence.html#5316" class="Bound">i</a> <a id="5318" class="Symbol">=</a> <a id="5320" href="Library.Univalence.html#7163" class="Function">Glue</a> <a id="5325" href="2--Paths-and-Identifications.2-6--Univalence.html#5311" class="Bound">B</a> <a id="5327" class="Symbol">{</a><a id="5328" class="Argument">φ</a> <a id="5330" class="Symbol">=</a> <a id="5332" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#6469" class="Function">∂</a> <a id="5334" href="2--Paths-and-Identifications.2-6--Univalence.html#5316" class="Bound">i</a><a id="5335" class="Symbol">}</a>
  <a id="5339" class="Symbol">(λ</a> <a id="5342" class="Symbol">{</a> <a id="5344" class="Symbol">(</a><a id="5345" href="2--Paths-and-Identifications.2-6--Univalence.html#5316" class="Bound">i</a> <a id="5347" class="Symbol">=</a> <a id="5349" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="5351" class="Symbol">)</a> <a id="5353" class="Symbol">→</a> <a id="5355" class="Symbol">(</a><a id="5356" href="2--Paths-and-Identifications.2-6--Univalence.html#5303" class="Bound">A</a> <a id="5358" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="5360" href="2--Paths-and-Identifications.2-6--Univalence.html#5314" class="Bound">e</a><a id="5361" class="Symbol">)</a>
     <a id="5368" class="Symbol">;</a> <a id="5370" class="Symbol">(</a><a id="5371" href="2--Paths-and-Identifications.2-6--Univalence.html#5316" class="Bound">i</a> <a id="5373" class="Symbol">=</a> <a id="5375" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="5377" class="Symbol">)</a> <a id="5379" class="Symbol">→</a> <a id="5381" class="Symbol">(</a><a id="5382" href="2--Paths-and-Identifications.2-6--Univalence.html#5311" class="Bound">B</a> <a id="5384" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="5386" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#8879" class="Function">idEquiv</a> <a id="5394" href="2--Paths-and-Identifications.2-6--Univalence.html#5311" class="Bound">B</a><a id="5395" class="Symbol">)</a> <a id="5397" class="Symbol">})</a>
</pre>
<p>That is, we use <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> to produce a version of <code>B</code> along a line in
the <code>i</code> dimension, but when <code>i</code> is <code>i0</code>, we glue <code>A</code> on using the
equivalence.</p>
<p>So how do we produce elements of <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code>? Thankfully, we will almost
never have to do so manually, but here’s a place where it is useful:
converting between a path in <code>B</code> and a path-over <code>ua e</code> for some
equivalence.</p>
<pre class="Agda"><a id="Path→ua-PathP"></a><a id="5776" href="2--Paths-and-Identifications.2-6--Univalence.html#5776" class="Function">Path→ua-PathP</a> <a id="5790" class="Symbol">:</a> <a id="5792" class="Symbol">(</a><a id="5793" href="2--Paths-and-Identifications.2-6--Univalence.html#5793" class="Bound">e</a> <a id="5795" class="Symbol">:</a> <a id="5797" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="5799" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="5801" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="5802" class="Symbol">)</a> <a id="5804" class="Symbol">{</a><a id="5805" href="2--Paths-and-Identifications.2-6--Univalence.html#5805" class="Bound">x</a> <a id="5807" class="Symbol">:</a> <a id="5809" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a><a id="5810" class="Symbol">}</a> <a id="5812" class="Symbol">{</a><a id="5813" href="2--Paths-and-Identifications.2-6--Univalence.html#5813" class="Bound">y</a> <a id="5815" class="Symbol">:</a> <a id="5817" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="5818" class="Symbol">}</a>
  <a id="5822" class="Symbol">→</a> <a id="5824" href="2--Paths-and-Identifications.2-6--Univalence.html#5793" class="Bound">e</a> <a id="5826" class="Symbol">.</a><a id="5827" class="Field">map</a> <a id="5831" href="2--Paths-and-Identifications.2-6--Univalence.html#5805" class="Bound">x</a> <a id="5833" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="5835" href="2--Paths-and-Identifications.2-6--Univalence.html#5813" class="Bound">y</a>
  <a id="5839" class="Symbol">→</a> <a id="5841" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="5847" class="Symbol">(λ</a> <a id="5850" href="2--Paths-and-Identifications.2-6--Univalence.html#5850" class="Bound">i</a> <a id="5852" class="Symbol">→</a> <a id="5854" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="5857" href="2--Paths-and-Identifications.2-6--Univalence.html#5793" class="Bound">e</a> <a id="5859" href="2--Paths-and-Identifications.2-6--Univalence.html#5850" class="Bound">i</a><a id="5860" class="Symbol">)</a> <a id="5862" href="2--Paths-and-Identifications.2-6--Univalence.html#5805" class="Bound">x</a> <a id="5864" href="2--Paths-and-Identifications.2-6--Univalence.html#5813" class="Bound">y</a>
</pre>
<p>The <code class="Agda"><a href="Library.Univalence.html#7106" class="Primitive">glue</a></code> constructor takes two arguments: first, a partial element
of the partial type <code>T</code> that we used in the <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> type itself.
After all, if we happen to be lying somewhere that <code>φ</code> equals <code>i1</code>,
the <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> type is supposed to turn into exactly <code>T</code>, so we have to
explain which value of <code>T</code> the <code class="Agda"><a href="Library.Univalence.html#7106" class="Primitive">glue</a></code> is supposed to turn into.</p>
<p>The second argument is the value of <code>B</code> that will get used everywhere
that <code>φ</code> doesn’t hold. Agda will check that the two arguments line up
with the equivalences you provided to the <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> type.</p>
<p>Annotating the above diagram, the values we are providing are</p>
<pre><code>           p
</code></pre>
<p>(e x) : B — — — &gt; y : B
^             ^                  ^
e (             ( idEquiv          )
)             )                  ∙ — &gt;
x : A         y : B                 i</p>
<pre class="Agda"><a id="6704" href="2--Paths-and-Identifications.2-6--Univalence.html#5776" class="Function">Path→ua-PathP</a> <a id="6718" href="2--Paths-and-Identifications.2-6--Univalence.html#6718" class="Bound">e</a> <a id="6720" class="Symbol">{</a><a id="6721" class="Argument">x</a> <a id="6723" class="Symbol">=</a> <a id="6725" href="2--Paths-and-Identifications.2-6--Univalence.html#6725" class="Bound">x</a><a id="6726" class="Symbol">}</a> <a id="6728" class="Symbol">{</a><a id="6729" class="Argument">y</a> <a id="6731" class="Symbol">=</a> <a id="6733" href="2--Paths-and-Identifications.2-6--Univalence.html#6733" class="Bound">y</a><a id="6734" class="Symbol">}</a> <a id="6736" href="2--Paths-and-Identifications.2-6--Univalence.html#6736" class="Bound">p</a> <a id="6738" href="2--Paths-and-Identifications.2-6--Univalence.html#6738" class="Bound">i</a> <a id="6740" class="Symbol">=</a> <a id="6742" href="Library.Univalence.html#7106" class="Primitive">glue</a> <a id="6747" class="Symbol">{</a><a id="6748" class="Argument">φ</a> <a id="6750" class="Symbol">=</a> <a id="6752" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#6469" class="Function">∂</a> <a id="6754" href="2--Paths-and-Identifications.2-6--Univalence.html#6738" class="Bound">i</a><a id="6755" class="Symbol">}</a>
  <a id="6759" class="Symbol">(λ</a> <a id="6762" class="Symbol">{</a> <a id="6764" class="Symbol">(</a><a id="6765" href="2--Paths-and-Identifications.2-6--Univalence.html#6738" class="Bound">i</a> <a id="6767" class="Symbol">=</a> <a id="6769" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="6771" class="Symbol">)</a> <a id="6773" class="Symbol">→</a> <a id="6775" href="2--Paths-and-Identifications.2-6--Univalence.html#6725" class="Bound">x</a> <a id="6777" class="Symbol">;</a>
       <a id="6786" class="Symbol">(</a><a id="6787" href="2--Paths-and-Identifications.2-6--Univalence.html#6738" class="Bound">i</a> <a id="6789" class="Symbol">=</a> <a id="6791" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="6793" class="Symbol">)</a> <a id="6795" class="Symbol">→</a> <a id="6797" href="2--Paths-and-Identifications.2-6--Univalence.html#6733" class="Bound">y</a> <a id="6799" class="Symbol">})</a>
  <a id="6804" class="Symbol">(</a><a id="6805" href="2--Paths-and-Identifications.2-6--Univalence.html#6736" class="Bound">p</a> <a id="6807" href="2--Paths-and-Identifications.2-6--Univalence.html#6738" class="Bound">i</a><a id="6808" class="Symbol">)</a>
</pre>
<p>The eliminator <code class="Agda"><a href="Library.Univalence.html#7366" class="Function">unglue</a></code> works as you might expect on elements of
<code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> — regardless of where we are in the <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> type, we can
extract an element of <code>B</code>.</p>
<pre class="Agda"><a id="ua-unglue"></a><a id="6983" href="2--Paths-and-Identifications.2-6--Univalence.html#6983" class="Function">ua-unglue</a> <a id="6993" class="Symbol">:</a> <a id="6995" class="Symbol">(</a><a id="6996" href="2--Paths-and-Identifications.2-6--Univalence.html#6996" class="Bound">e</a> <a id="6998" class="Symbol">:</a> <a id="7000" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="7002" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="7004" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="7005" class="Symbol">)</a> <a id="7007" class="Symbol">→</a> <a id="7009" class="Symbol">(</a><a id="7010" href="2--Paths-and-Identifications.2-6--Univalence.html#7010" class="Bound">i</a> <a id="7012" class="Symbol">:</a> <a id="7014" href="Library.Primitive.html#1675" class="Datatype">I</a><a id="7015" class="Symbol">)</a> <a id="7017" class="Symbol">→</a> <a id="7019" class="Symbol">(</a><a id="7020" href="2--Paths-and-Identifications.2-6--Univalence.html#7020" class="Bound">x</a> <a id="7022" class="Symbol">:</a> <a id="7024" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="7027" href="2--Paths-and-Identifications.2-6--Univalence.html#6996" class="Bound">e</a> <a id="7029" href="2--Paths-and-Identifications.2-6--Univalence.html#7010" class="Bound">i</a><a id="7030" class="Symbol">)</a> <a id="7032" class="Symbol">→</a> <a id="7034" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a>
<a id="7036" href="2--Paths-and-Identifications.2-6--Univalence.html#6983" class="Function">ua-unglue</a> <a id="7046" href="2--Paths-and-Identifications.2-6--Univalence.html#7046" class="Bound">e</a> <a id="7048" href="2--Paths-and-Identifications.2-6--Univalence.html#7048" class="Bound">i</a> <a id="7050" href="2--Paths-and-Identifications.2-6--Univalence.html#7050" class="Bound">x</a> <a id="7052" class="Symbol">=</a> <a id="7054" href="Library.Univalence.html#7366" class="Function">unglue</a> <a id="7061" class="Symbol">(</a><a id="7062" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#6469" class="Function">∂</a> <a id="7064" href="2--Paths-and-Identifications.2-6--Univalence.html#7048" class="Bound">i</a><a id="7065" class="Symbol">)</a> <a id="7067" href="2--Paths-and-Identifications.2-6--Univalence.html#7050" class="Bound">x</a>
</pre>
<p>When we happen to be somewhere that <code>φ</code> equals <code>i1</code>, this will mean
applying the equivalence that we provided to the <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> type
constructor.</p>
<pre class="Agda"><a id="7223" class="Keyword">module</a> <a id="7230" href="2--Paths-and-Identifications.2-6--Univalence.html#7230" class="Module">_</a> <a id="7232" class="Symbol">{</a><a id="7233" href="2--Paths-and-Identifications.2-6--Univalence.html#7233" class="Bound">ℓ</a> <a id="7235" class="Symbol">:</a> <a id="7237" href="Library.Primitive.html#1060" class="Postulate">Level</a><a id="7242" class="Symbol">}</a> <a id="7244" class="Symbol">{</a><a id="7245" href="2--Paths-and-Identifications.2-6--Univalence.html#7245" class="Bound">A</a> <a id="7247" href="2--Paths-and-Identifications.2-6--Univalence.html#7247" class="Bound">B</a> <a id="7249" class="Symbol">:</a> <a id="7251" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="7256" href="2--Paths-and-Identifications.2-6--Univalence.html#7233" class="Bound">ℓ</a><a id="7257" class="Symbol">}</a> <a id="7259" class="Symbol">(</a><a id="7260" href="2--Paths-and-Identifications.2-6--Univalence.html#7260" class="Bound">e</a> <a id="7262" class="Symbol">:</a> <a id="7264" href="2--Paths-and-Identifications.2-6--Univalence.html#7245" class="Bound">A</a> <a id="7266" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="7268" href="2--Paths-and-Identifications.2-6--Univalence.html#7247" class="Bound">B</a><a id="7269" class="Symbol">)</a> <a id="7271" class="Keyword">where</a>
  <a id="7279" href="2--Paths-and-Identifications.2-6--Univalence.html#7279" class="Function">_</a> <a id="7281" class="Symbol">=</a> <a id="7283" class="Symbol">λ</a> <a id="7285" class="Symbol">(</a><a id="7286" href="2--Paths-and-Identifications.2-6--Univalence.html#7286" class="Bound">x</a> <a id="7288" class="Symbol">:</a> <a id="7290" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="7293" href="2--Paths-and-Identifications.2-6--Univalence.html#7260" class="Bound">e</a> <a id="7295" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="7297" class="Symbol">)</a> <a id="7299" class="Symbol">→</a> <a id="7301" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="7316" class="Symbol">(</a><a id="7317" href="2--Paths-and-Identifications.2-6--Univalence.html#6983" class="Function">ua-unglue</a> <a id="7327" href="2--Paths-and-Identifications.2-6--Univalence.html#7260" class="Bound">e</a> <a id="7329" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a> <a id="7332" href="2--Paths-and-Identifications.2-6--Univalence.html#7286" class="Bound">x</a><a id="7333" class="Symbol">)</a> <a id="7335" class="Symbol">(</a><a id="7336" href="2--Paths-and-Identifications.2-6--Univalence.html#7260" class="Bound">e</a> <a id="7338" class="Symbol">.</a><a id="7339" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5810" class="Field">map</a> <a id="7343" href="2--Paths-and-Identifications.2-6--Univalence.html#7286" class="Bound">x</a><a id="7344" class="Symbol">)</a>
  <a id="7348" href="2--Paths-and-Identifications.2-6--Univalence.html#7348" class="Function">_</a> <a id="7350" class="Symbol">=</a> <a id="7352" class="Symbol">λ</a> <a id="7354" class="Symbol">(</a><a id="7355" href="2--Paths-and-Identifications.2-6--Univalence.html#7355" class="Bound">x</a> <a id="7357" class="Symbol">:</a> <a id="7359" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="7362" href="2--Paths-and-Identifications.2-6--Univalence.html#7260" class="Bound">e</a> <a id="7364" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="7366" class="Symbol">)</a> <a id="7368" class="Symbol">→</a> <a id="7370" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="7385" class="Symbol">(</a><a id="7386" href="2--Paths-and-Identifications.2-6--Univalence.html#6983" class="Function">ua-unglue</a> <a id="7396" href="2--Paths-and-Identifications.2-6--Univalence.html#7260" class="Bound">e</a> <a id="7398" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a> <a id="7401" href="2--Paths-and-Identifications.2-6--Univalence.html#7355" class="Bound">x</a><a id="7402" class="Symbol">)</a> <a id="7404" href="2--Paths-and-Identifications.2-6--Univalence.html#7355" class="Bound">x</a>
</pre>
<p>Rearranging the arguments slightly, this is turned into an inverse to
<code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#5776" class="Function">Path→ua-PathP</a></code>.</p>
<pre class="Agda"><a id="ua-PathP→Path"></a><a id="7505" href="2--Paths-and-Identifications.2-6--Univalence.html#7505" class="Function">ua-PathP→Path</a> <a id="7519" class="Symbol">:</a> <a id="7521" class="Symbol">(</a><a id="7522" href="2--Paths-and-Identifications.2-6--Univalence.html#7522" class="Bound">e</a> <a id="7524" class="Symbol">:</a> <a id="7526" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="7528" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="7530" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="7531" class="Symbol">)</a> <a id="7533" class="Symbol">{</a><a id="7534" href="2--Paths-and-Identifications.2-6--Univalence.html#7534" class="Bound">x</a> <a id="7536" class="Symbol">:</a> <a id="7538" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a><a id="7539" class="Symbol">}</a> <a id="7541" class="Symbol">{</a><a id="7542" href="2--Paths-and-Identifications.2-6--Univalence.html#7542" class="Bound">y</a> <a id="7544" class="Symbol">:</a> <a id="7546" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="7547" class="Symbol">}</a>
 <a id="7550" class="Symbol">→</a> <a id="7552" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="7558" class="Symbol">(λ</a> <a id="7561" href="2--Paths-and-Identifications.2-6--Univalence.html#7561" class="Bound">i</a> <a id="7563" class="Symbol">→</a> <a id="7565" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="7568" href="2--Paths-and-Identifications.2-6--Univalence.html#7522" class="Bound">e</a> <a id="7570" href="2--Paths-and-Identifications.2-6--Univalence.html#7561" class="Bound">i</a><a id="7571" class="Symbol">)</a> <a id="7573" href="2--Paths-and-Identifications.2-6--Univalence.html#7534" class="Bound">x</a> <a id="7575" href="2--Paths-and-Identifications.2-6--Univalence.html#7542" class="Bound">y</a>
 <a id="7578" class="Symbol">→</a> <a id="7580" href="2--Paths-and-Identifications.2-6--Univalence.html#7522" class="Bound">e</a> <a id="7582" class="Symbol">.</a><a id="7583" class="Field">map</a> <a id="7587" href="2--Paths-and-Identifications.2-6--Univalence.html#7534" class="Bound">x</a> <a id="7589" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="7591" href="2--Paths-and-Identifications.2-6--Univalence.html#7542" class="Bound">y</a>
<a id="7593" href="2--Paths-and-Identifications.2-6--Univalence.html#7505" class="Function">ua-PathP→Path</a> <a id="7607" href="2--Paths-and-Identifications.2-6--Univalence.html#7607" class="Bound">e</a> <a id="7609" href="2--Paths-and-Identifications.2-6--Univalence.html#7609" class="Bound">p</a> <a id="7611" href="2--Paths-and-Identifications.2-6--Univalence.html#7611" class="Bound">i</a> <a id="7613" class="Symbol">=</a> <a id="7615" href="2--Paths-and-Identifications.2-6--Univalence.html#6983" class="Function">ua-unglue</a> <a id="7625" href="2--Paths-and-Identifications.2-6--Univalence.html#7607" class="Bound">e</a> <a id="7627" href="2--Paths-and-Identifications.2-6--Univalence.html#7611" class="Bound">i</a> <a id="7629" class="Symbol">(</a><a id="7630" href="2--Paths-and-Identifications.2-6--Univalence.html#7609" class="Bound">p</a> <a id="7632" href="2--Paths-and-Identifications.2-6--Univalence.html#7611" class="Bound">i</a><a id="7633" class="Symbol">)</a>
</pre>
<p>These <code class="Agda"><a href="Library.Univalence.html#7106" class="Primitive">glue</a></code> and <code class="Agda"><a href="Library.Univalence.html#7366" class="Function">unglue</a></code> operations are inverses by definition,
and so no more work is necessary to show <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#5776" class="Function">Path→ua-PathP</a></code> is an
equivalence.</p>
<pre class="Agda"><a id="Path≃ua-PathP"></a><a id="7792" href="2--Paths-and-Identifications.2-6--Univalence.html#7792" class="Function">Path≃ua-PathP</a> <a id="7806" class="Symbol">:</a> <a id="7808" class="Symbol">(</a><a id="7809" href="2--Paths-and-Identifications.2-6--Univalence.html#7809" class="Bound">e</a> <a id="7811" class="Symbol">:</a> <a id="7813" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="7815" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="7817" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="7818" class="Symbol">)</a> <a id="7820" class="Symbol">{</a><a id="7821" href="2--Paths-and-Identifications.2-6--Univalence.html#7821" class="Bound">x</a> <a id="7823" class="Symbol">:</a> <a id="7825" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a><a id="7826" class="Symbol">}</a> <a id="7828" class="Symbol">{</a><a id="7829" href="2--Paths-and-Identifications.2-6--Univalence.html#7829" class="Bound">y</a> <a id="7831" class="Symbol">:</a> <a id="7833" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="7834" class="Symbol">}</a>
 <a id="7837" class="Symbol">→</a> <a id="7839" class="Symbol">(</a><a id="7840" href="2--Paths-and-Identifications.2-6--Univalence.html#7809" class="Bound">e</a> <a id="7842" class="Symbol">.</a><a id="7843" class="Field">map</a> <a id="7847" href="2--Paths-and-Identifications.2-6--Univalence.html#7821" class="Bound">x</a> <a id="7849" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="7851" href="2--Paths-and-Identifications.2-6--Univalence.html#7829" class="Bound">y</a><a id="7852" class="Symbol">)</a>
 <a id="7855" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="7857" class="Symbol">(</a><a id="7858" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="7864" class="Symbol">(λ</a> <a id="7867" href="2--Paths-and-Identifications.2-6--Univalence.html#7867" class="Bound">i</a> <a id="7869" class="Symbol">→</a> <a id="7871" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="7874" href="2--Paths-and-Identifications.2-6--Univalence.html#7809" class="Bound">e</a> <a id="7876" href="2--Paths-and-Identifications.2-6--Univalence.html#7867" class="Bound">i</a><a id="7877" class="Symbol">)</a> <a id="7879" href="2--Paths-and-Identifications.2-6--Univalence.html#7821" class="Bound">x</a> <a id="7881" href="2--Paths-and-Identifications.2-6--Univalence.html#7829" class="Bound">y</a><a id="7882" class="Symbol">)</a>
<a id="7884" href="2--Paths-and-Identifications.2-6--Univalence.html#7792" class="Function">Path≃ua-PathP</a> <a id="7898" href="2--Paths-and-Identifications.2-6--Univalence.html#7898" class="Bound">e</a> 
  <a id="7903" class="Symbol">=</a> <a id="7905" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#7262" class="Function">inv→equiv</a> <a id="7915" class="Symbol">(</a><a id="7916" href="2--Paths-and-Identifications.2-6--Univalence.html#5776" class="Function">Path→ua-PathP</a> <a id="7930" href="2--Paths-and-Identifications.2-6--Univalence.html#7898" class="Bound">e</a><a id="7931" class="Symbol">)</a> <a id="7933" class="Symbol">(</a><a id="7934" href="2--Paths-and-Identifications.2-6--Univalence.html#7505" class="Function">ua-PathP→Path</a> <a id="7948" href="2--Paths-and-Identifications.2-6--Univalence.html#7898" class="Bound">e</a><a id="7949" class="Symbol">)</a> <a id="7951" class="Symbol">(λ</a> <a id="7954" href="2--Paths-and-Identifications.2-6--Univalence.html#7954" class="Bound">_</a> <a id="7956" class="Symbol">→</a> <a id="7958" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a><a id="7962" class="Symbol">)</a> <a id="7964" class="Symbol">(λ</a> <a id="7967" href="2--Paths-and-Identifications.2-6--Univalence.html#7967" class="Bound">_</a> <a id="7969" class="Symbol">→</a> <a id="7971" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a><a id="7975" class="Symbol">)</a>
</pre>
<p>When <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a></code> is applied to the identity equivalence on <code>A</code>, we get
the <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a></code> path from <code>A</code> to itself.</p>
<pre class="Agda"><a id="ua-idEquiv"></a><a id="8091" href="2--Paths-and-Identifications.2-6--Univalence.html#8091" class="Function">ua-idEquiv</a> <a id="8102" class="Symbol">:</a> <a id="8104" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="8107" class="Symbol">(</a><a id="8108" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#8879" class="Function">idEquiv</a> <a id="8116" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a><a id="8117" class="Symbol">)</a> <a id="8119" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="8121" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a>
</pre>
<p>Written as a square, we are trying to construct the square of types
where on three of the sides we are constant at the type <code>A</code> and on the
remaining side we have <code>ua (idEquiv A)</code>.</p>
<pre><code>            A — — — — — — — — &gt; A
          / ^                 / ^
        /   )               /   )
      /     (             /     (
    A — — — — — — — — &gt; A       )
    ^       (           ^       (                    ^   j
    )       )           )       )                    ) /
    (       (           (       (                    ∙ — &gt;
    )       )           )       )                      i
    (       A — — — — — ( — — &gt; A
    )                   )     /
    (                   (   /
    )                   ) /
    A — — — — — — — — &gt; A
</code></pre>
<p>Using <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code> again here with <code>(A , idEquiv A)</code> on all the
vertical faces gives us a square of types on the bottom. When <code>i = i1</code>, <code>j = i0</code> or <code>j = i1</code>, this <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code>-type computes away to give
exactly <code>A</code>. When <code>i = i0</code>, we are left with the line of types </p>
<pre><code>Glue A {φ = ∂ j} 
  (λ { (j = i0) → (A , idEquiv A)
     ; (j = i1) → (A , idEquiv A) })
</code></pre>
<p>but this is exactly the definition of <code>ua (idEquiv A)</code>.</p>
<pre class="Agda"><a id="9345" href="2--Paths-and-Identifications.2-6--Univalence.html#8091" class="Function">ua-idEquiv</a> <a id="9356" class="Symbol">{</a><a id="9357" class="Argument">A</a> <a id="9359" class="Symbol">=</a> <a id="9361" href="2--Paths-and-Identifications.2-6--Univalence.html#9361" class="Bound">A</a><a id="9362" class="Symbol">}</a> <a id="9364" href="2--Paths-and-Identifications.2-6--Univalence.html#9364" class="Bound">i</a> <a id="9366" href="2--Paths-and-Identifications.2-6--Univalence.html#9366" class="Bound">j</a> <a id="9368" class="Symbol">=</a> <a id="9370" href="Library.Univalence.html#7163" class="Function">Glue</a> <a id="9375" href="2--Paths-and-Identifications.2-6--Univalence.html#9361" class="Bound">A</a> <a id="9377" class="Symbol">{</a><a id="9378" class="Argument">φ</a> <a id="9380" class="Symbol">=</a> <a id="9382" href="2--Paths-and-Identifications.2-6--Univalence.html#9364" class="Bound">i</a> <a id="9384" href="Library.Prelude.html#387" class="Primitive Operator">∨</a> <a id="9386" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#6469" class="Function">∂</a> <a id="9388" href="2--Paths-and-Identifications.2-6--Univalence.html#9366" class="Bound">j</a><a id="9389" class="Symbol">}</a> <a id="9391" class="Symbol">(λ</a> <a id="9394" href="2--Paths-and-Identifications.2-6--Univalence.html#9394" class="Bound">_</a> <a id="9396" class="Symbol">→</a> <a id="9398" href="2--Paths-and-Identifications.2-6--Univalence.html#9361" class="Bound">A</a> <a id="9400" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="9402" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#8879" class="Function">idEquiv</a> <a id="9410" href="2--Paths-and-Identifications.2-6--Univalence.html#9361" class="Bound">A</a><a id="9411" class="Symbol">)</a>
</pre>
<p>Transporting over <code>ua e</code> is the same as applying the function
underlying the equivalence <code>e</code>. Really, we get a transport over
<code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a></code>, which is cleared up by a use of <code class="Agda"><a href="2--Paths-and-Identifications.2-5--Transport.html#4143" class="Function">transport-refl</a></code>. This is
an instance of the computation rule for <code class="Agda"><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a></code> on <code class="Agda"><a href="Library.Univalence.html#7163" class="Function">Glue</a></code>
types, which is very complicated in full generality.</p>
<pre class="Agda"><a id="ua-comp"></a><a id="9738" href="2--Paths-and-Identifications.2-6--Univalence.html#9738" class="Function">ua-comp</a> <a id="9746" class="Symbol">:</a> <a id="9748" class="Symbol">(</a><a id="9749" href="2--Paths-and-Identifications.2-6--Univalence.html#9749" class="Bound">e</a> <a id="9751" class="Symbol">:</a> <a id="9753" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="9755" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="9757" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="9758" class="Symbol">)</a> <a id="9760" class="Symbol">→</a> <a id="9762" class="Symbol">(</a><a id="9763" href="2--Paths-and-Identifications.2-6--Univalence.html#9763" class="Bound">x</a> <a id="9765" class="Symbol">:</a> <a id="9767" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a><a id="9768" class="Symbol">)</a> <a id="9770" class="Symbol">→</a> <a id="9772" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a> <a id="9782" class="Symbol">(</a><a id="9783" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="9786" href="2--Paths-and-Identifications.2-6--Univalence.html#9749" class="Bound">e</a><a id="9787" class="Symbol">)</a> <a id="9789" href="2--Paths-and-Identifications.2-6--Univalence.html#9763" class="Bound">x</a> <a id="9791" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="9793" href="2--Paths-and-Identifications.2-6--Univalence.html#9749" class="Bound">e</a> <a id="9795" class="Symbol">.</a><a id="9796" class="Field">map</a> <a id="9800" href="2--Paths-and-Identifications.2-6--Univalence.html#9763" class="Bound">x</a>
<a id="9802" href="2--Paths-and-Identifications.2-6--Univalence.html#9738" class="Function">ua-comp</a> <a id="9810" href="2--Paths-and-Identifications.2-6--Univalence.html#9810" class="Bound">e</a> <a id="9812" href="2--Paths-and-Identifications.2-6--Univalence.html#9812" class="Bound">x</a> <a id="9814" class="Symbol">=</a> <a id="9816" href="2--Paths-and-Identifications.2-5--Transport.html#4143" class="Function">transport-refl</a> <a id="9831" class="Symbol">(</a><a id="9832" href="2--Paths-and-Identifications.2-6--Univalence.html#9810" class="Bound">e</a> <a id="9834" class="Symbol">.</a><a id="9835" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5810" class="Field">map</a> <a id="9839" href="2--Paths-and-Identifications.2-6--Univalence.html#9812" class="Bound">x</a><a id="9840" class="Symbol">)</a>
</pre>
<p>For most types we encounter this holds definitionally the same way
that <code class="Agda"><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a></code>ing over <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a></code> does, because in those cases the
<code class="Agda"><a href="2--Paths-and-Identifications.2-5--Transport.html#4143" class="Function">transport-refl</a></code> above truly does become the reflexivity path. And
so Cubical Agda does achieve is the property we hoped for at the top
of this Lecture. </p>
<pre class="Agda"><a id="10144" href="2--Paths-and-Identifications.2-6--Univalence.html#10144" class="Function">_</a> <a id="10146" class="Symbol">=</a> <a id="10148" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="10163" class="Symbol">(</a><a id="10164" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a> <a id="10174" class="Symbol">(</a><a id="10175" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10178" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#20994" class="Function">not-≃</a><a id="10183" class="Symbol">)</a> <a id="10185" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a><a id="10189" class="Symbol">)</a> <a id="10191" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a>
<a id="10197" href="2--Paths-and-Identifications.2-6--Univalence.html#10197" class="Function">_</a> <a id="10199" class="Symbol">=</a> <a id="10201" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="10216" class="Symbol">(</a><a id="10217" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a> <a id="10227" class="Symbol">(</a><a id="10228" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10231" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6878" class="Function">Bool≃RedOrBlue</a><a id="10245" class="Symbol">)</a> <a id="10247" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a><a id="10251" class="Symbol">)</a> <a id="10253" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#2955" class="InductiveConstructor">red</a>

<a id="10258" href="2--Paths-and-Identifications.2-6--Univalence.html#10258" class="Function">_</a> <a id="10260" class="Symbol">=</a> <a id="10262" class="Symbol">λ</a> <a id="10264" class="Symbol">(</a><a id="10265" href="2--Paths-and-Identifications.2-6--Univalence.html#10265" class="Bound">e</a> <a id="10267" class="Symbol">:</a> <a id="10269" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="10274" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="10276" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="10280" class="Symbol">)</a> <a id="10282" class="Symbol">(</a><a id="10283" href="2--Paths-and-Identifications.2-6--Univalence.html#10283" class="Bound">x</a> <a id="10285" class="Symbol">:</a> <a id="10287" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="10291" class="Symbol">)</a> 
  <a id="10296" class="Symbol">→</a> <a id="10298" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="10313" class="Symbol">(</a><a id="10314" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a> <a id="10324" class="Symbol">(</a><a id="10325" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10328" href="2--Paths-and-Identifications.2-6--Univalence.html#10265" class="Bound">e</a><a id="10329" class="Symbol">)</a> <a id="10331" href="2--Paths-and-Identifications.2-6--Univalence.html#10283" class="Bound">x</a><a id="10332" class="Symbol">)</a> <a id="10334" class="Symbol">(</a><a id="10335" href="2--Paths-and-Identifications.2-6--Univalence.html#10265" class="Bound">e</a> <a id="10337" class="Symbol">.</a><a id="10338" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5810" class="Field">map</a> <a id="10342" href="2--Paths-and-Identifications.2-6--Univalence.html#10283" class="Bound">x</a><a id="10343" class="Symbol">)</a>

<a id="10346" href="2--Paths-and-Identifications.2-6--Univalence.html#10346" class="Function">_</a> <a id="10348" class="Symbol">=</a> <a id="10350" class="Symbol">λ</a> <a id="10352" class="Symbol">(</a><a id="10353" href="2--Paths-and-Identifications.2-6--Univalence.html#10353" class="Bound">e</a> <a id="10355" class="Symbol">:</a> <a id="10357" href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a> <a id="10360" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="10362" href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a><a id="10364" class="Symbol">)</a> <a id="10366" class="Symbol">(</a><a id="10367" href="2--Paths-and-Identifications.2-6--Univalence.html#10367" class="Bound">x</a> <a id="10369" class="Symbol">:</a> <a id="10371" href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a><a id="10373" class="Symbol">)</a>
  <a id="10377" class="Symbol">→</a> <a id="10379" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="10394" class="Symbol">(</a><a id="10395" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a> <a id="10405" class="Symbol">(</a><a id="10406" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10409" href="2--Paths-and-Identifications.2-6--Univalence.html#10353" class="Bound">e</a><a id="10410" class="Symbol">)</a> <a id="10412" href="2--Paths-and-Identifications.2-6--Univalence.html#10367" class="Bound">x</a><a id="10413" class="Symbol">)</a> <a id="10415" class="Symbol">(</a><a id="10416" href="2--Paths-and-Identifications.2-6--Univalence.html#10353" class="Bound">e</a> <a id="10418" class="Symbol">.</a><a id="10419" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5810" class="Field">map</a> <a id="10423" href="2--Paths-and-Identifications.2-6--Univalence.html#10367" class="Bound">x</a><a id="10424" class="Symbol">)</a>
</pre>
<p>Finally, univalence is inverse to <code class="Agda"><a href="2--Paths-and-Identifications.2-5--Transport.html#5441" class="Function">path→equiv</a></code>. We show one half of
this now using <code class="Agda"><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#5310" class="Function">J</a></code>, but will need to wait until Lecture 2-X to show
the other direction.</p>
<pre class="Agda"><a id="au"></a><a id="10597" href="2--Paths-and-Identifications.2-6--Univalence.html#10597" class="Function">au</a> <a id="10600" class="Symbol">:</a> <a id="10602" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="10604" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="10606" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a> <a id="10608" class="Symbol">→</a> <a id="10610" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="10612" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="10614" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a>
<a id="10616" href="2--Paths-and-Identifications.2-6--Univalence.html#10597" class="Function">au</a> <a id="10619" class="Symbol">=</a> <a id="10621" href="2--Paths-and-Identifications.2-5--Transport.html#5441" class="Function">path→equiv</a>

<a id="ua-au"></a><a id="10633" href="2--Paths-and-Identifications.2-6--Univalence.html#10633" class="Function">ua-au</a> <a id="10639" class="Symbol">:</a> <a id="10641" class="Symbol">(</a><a id="10642" href="2--Paths-and-Identifications.2-6--Univalence.html#10642" class="Bound">p</a> <a id="10644" class="Symbol">:</a> <a id="10646" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a> <a id="10648" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="10650" href="2--Paths-and-Identifications.2-6--Univalence.html#666" class="Generalizable">B</a><a id="10651" class="Symbol">)</a> <a id="10653" class="Symbol">→</a> <a id="10655" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10658" class="Symbol">(</a><a id="10659" href="2--Paths-and-Identifications.2-6--Univalence.html#10597" class="Function">au</a> <a id="10662" href="2--Paths-and-Identifications.2-6--Univalence.html#10642" class="Bound">p</a><a id="10663" class="Symbol">)</a> <a id="10665" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="10667" href="2--Paths-and-Identifications.2-6--Univalence.html#10642" class="Bound">p</a>
<a id="10669" href="2--Paths-and-Identifications.2-6--Univalence.html#10633" class="Function">ua-au</a> <a id="10675" class="Symbol">=</a> <a id="10677" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#5310" class="Function">J</a> <a id="10679" class="Symbol">(λ</a> <a id="10682" href="2--Paths-and-Identifications.2-6--Univalence.html#10682" class="Bound">_</a> <a id="10684" href="2--Paths-and-Identifications.2-6--Univalence.html#10684" class="Bound">p</a> <a id="10686" class="Symbol">→</a> <a id="10688" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10691" class="Symbol">(</a><a id="10692" href="2--Paths-and-Identifications.2-6--Univalence.html#10597" class="Function">au</a> <a id="10695" href="2--Paths-and-Identifications.2-6--Univalence.html#10684" class="Bound">p</a><a id="10696" class="Symbol">)</a> <a id="10698" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="10700" href="2--Paths-and-Identifications.2-6--Univalence.html#10684" class="Bound">p</a><a id="10701" class="Symbol">)</a> <a id="10703" href="2--Paths-and-Identifications.2-6--Univalence.html#10716" class="Function">path</a>
  <a id="10710" class="Keyword">where</a> <a id="10716" href="2--Paths-and-Identifications.2-6--Univalence.html#10716" class="Function">path</a> <a id="10721" class="Symbol">=</a> <a id="10723" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10726" class="Symbol">(</a><a id="10727" href="2--Paths-and-Identifications.2-6--Univalence.html#10597" class="Function">au</a> <a id="10730" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a><a id="10734" class="Symbol">)</a>   <a id="10738" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#30613" class="Function">≡⟨</a> <a id="10741" href="2--Paths-and-Identifications.2-1--Paths.html#17114" class="Function">ap</a> <a id="10744" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10747" href="2--Paths-and-Identifications.2-5--Transport.html#5939" class="Function">path→equiv-refl</a> <a id="10763" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#30613" class="Function">⟩</a>
               <a id="10780" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="10783" class="Symbol">(</a><a id="10784" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#8879" class="Function">idEquiv</a> <a id="10792" class="Symbol">_)</a> <a id="10795" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#30613" class="Function">≡⟨</a> <a id="10798" href="2--Paths-and-Identifications.2-6--Univalence.html#8091" class="Function">ua-idEquiv</a> <a id="10809" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#30613" class="Function">⟩</a>
               <a id="10826" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a> <a id="10831" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#30710" class="Function Operator">∎</a>
</pre>
<p>Back in <code class="Agda"><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#17132" class="Function">×-map-≃</a></code>, we saw that <code class="Agda"><a href="Library.Prelude.html#1692" class="Function">×</a></code> respects equivalences.
Univalence gives us a second, much easier way to prove this:</p>
<pre class="Agda"><a id="×-map-≡"></a><a id="10966" href="2--Paths-and-Identifications.2-6--Univalence.html#10966" class="Function">×-map-≡</a> <a id="10974" class="Symbol">:</a> <a id="10976" class="Symbol">{</a><a id="10977" href="2--Paths-and-Identifications.2-6--Univalence.html#10977" class="Bound">A</a> <a id="10979" href="2--Paths-and-Identifications.2-6--Univalence.html#10979" class="Bound">A&#39;</a> <a id="10982" href="2--Paths-and-Identifications.2-6--Univalence.html#10982" class="Bound">B</a> <a id="10984" href="2--Paths-and-Identifications.2-6--Univalence.html#10984" class="Bound">B&#39;</a> <a id="10987" class="Symbol">:</a> <a id="10989" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="10994" href="2--Paths-and-Identifications.2-6--Univalence.html#640" class="Generalizable">ℓ</a><a id="10995" class="Symbol">}</a>
  <a id="10999" class="Symbol">→</a> <a id="11001" class="Symbol">(</a><a id="11002" href="2--Paths-and-Identifications.2-6--Univalence.html#10977" class="Bound">A</a> <a id="11004" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="11006" href="2--Paths-and-Identifications.2-6--Univalence.html#10979" class="Bound">A&#39;</a><a id="11008" class="Symbol">)</a> <a id="11010" class="Symbol">→</a> <a id="11012" class="Symbol">(</a><a id="11013" href="2--Paths-and-Identifications.2-6--Univalence.html#10982" class="Bound">B</a> <a id="11015" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="11017" href="2--Paths-and-Identifications.2-6--Univalence.html#10984" class="Bound">B&#39;</a><a id="11019" class="Symbol">)</a> <a id="11021" class="Symbol">→</a> <a id="11023" class="Symbol">(</a><a id="11024" href="2--Paths-and-Identifications.2-6--Univalence.html#10977" class="Bound">A</a> <a id="11026" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="11028" href="2--Paths-and-Identifications.2-6--Univalence.html#10982" class="Bound">B</a><a id="11029" class="Symbol">)</a> <a id="11031" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="11033" class="Symbol">(</a><a id="11034" href="2--Paths-and-Identifications.2-6--Univalence.html#10979" class="Bound">A&#39;</a> <a id="11037" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="11039" href="2--Paths-and-Identifications.2-6--Univalence.html#10984" class="Bound">B&#39;</a><a id="11041" class="Symbol">)</a>
<a id="11043" class="Comment">-- Exercise:</a>
<a id="11056" class="Comment">-- ×-map-≡ p q = {!!}</a>
</pre><!--
<pre class="Agda"><a id="11091" href="2--Paths-and-Identifications.2-6--Univalence.html#10966" class="Function">×-map-≡</a> <a id="11099" href="2--Paths-and-Identifications.2-6--Univalence.html#11099" class="Bound">p</a> <a id="11101" href="2--Paths-and-Identifications.2-6--Univalence.html#11101" class="Bound">q</a> <a id="11103" href="2--Paths-and-Identifications.2-6--Univalence.html#11103" class="Bound">i</a> <a id="11105" class="Symbol">=</a> <a id="11107" href="2--Paths-and-Identifications.2-6--Univalence.html#11099" class="Bound">p</a> <a id="11109" href="2--Paths-and-Identifications.2-6--Univalence.html#11103" class="Bound">i</a> <a id="11111" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="11113" href="2--Paths-and-Identifications.2-6--Univalence.html#11101" class="Bound">q</a> <a id="11115" href="2--Paths-and-Identifications.2-6--Univalence.html#11103" class="Bound">i</a>

</pre>-->
<pre class="Agda">
<a id="×-map-≃-ua"></a><a id="11131" href="2--Paths-and-Identifications.2-6--Univalence.html#11131" class="Function">×-map-≃-ua</a> <a id="11142" class="Symbol">:</a> <a id="11144" class="Symbol">{</a><a id="11145" href="2--Paths-and-Identifications.2-6--Univalence.html#11145" class="Bound">A</a> <a id="11147" href="2--Paths-and-Identifications.2-6--Univalence.html#11147" class="Bound">A&#39;</a> <a id="11150" href="2--Paths-and-Identifications.2-6--Univalence.html#11150" class="Bound">B</a> <a id="11152" href="2--Paths-and-Identifications.2-6--Univalence.html#11152" class="Bound">B&#39;</a> <a id="11155" class="Symbol">:</a> <a id="11157" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="11162" href="2--Paths-and-Identifications.2-6--Univalence.html#640" class="Generalizable">ℓ</a><a id="11163" class="Symbol">}</a>
  <a id="11167" class="Symbol">→</a> <a id="11169" class="Symbol">(</a><a id="11170" href="2--Paths-and-Identifications.2-6--Univalence.html#11145" class="Bound">A</a> <a id="11172" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="11174" href="2--Paths-and-Identifications.2-6--Univalence.html#11147" class="Bound">A&#39;</a><a id="11176" class="Symbol">)</a> <a id="11178" class="Symbol">→</a> <a id="11180" class="Symbol">(</a><a id="11181" href="2--Paths-and-Identifications.2-6--Univalence.html#11150" class="Bound">B</a> <a id="11183" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="11185" href="2--Paths-and-Identifications.2-6--Univalence.html#11152" class="Bound">B&#39;</a><a id="11187" class="Symbol">)</a> <a id="11189" class="Symbol">→</a> <a id="11191" class="Symbol">(</a><a id="11192" href="2--Paths-and-Identifications.2-6--Univalence.html#11145" class="Bound">A</a> <a id="11194" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="11196" href="2--Paths-and-Identifications.2-6--Univalence.html#11150" class="Bound">B</a><a id="11197" class="Symbol">)</a> <a id="11199" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="11201" class="Symbol">(</a><a id="11202" href="2--Paths-and-Identifications.2-6--Univalence.html#11147" class="Bound">A&#39;</a> <a id="11205" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="11207" href="2--Paths-and-Identifications.2-6--Univalence.html#11152" class="Bound">B&#39;</a><a id="11209" class="Symbol">)</a>
<a id="11211" class="Comment">-- Exercise:</a>
<a id="11224" class="Comment">-- ×-map-≃-ua f g = au {!!}</a>
</pre><!--
<pre class="Agda"><a id="11265" href="2--Paths-and-Identifications.2-6--Univalence.html#11131" class="Function">×-map-≃-ua</a> <a id="11276" href="2--Paths-and-Identifications.2-6--Univalence.html#11276" class="Bound">f</a> <a id="11278" href="2--Paths-and-Identifications.2-6--Univalence.html#11278" class="Bound">g</a> <a id="11280" class="Symbol">=</a> <a id="11282" href="2--Paths-and-Identifications.2-6--Univalence.html#10597" class="Function">au</a> <a id="11285" class="Symbol">(</a><a id="11286" href="2--Paths-and-Identifications.2-6--Univalence.html#10966" class="Function">×-map-≡</a> <a id="11294" class="Symbol">(</a><a id="11295" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="11298" href="2--Paths-and-Identifications.2-6--Univalence.html#11276" class="Bound">f</a><a id="11299" class="Symbol">)</a> <a id="11301" class="Symbol">(</a><a id="11302" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="11305" href="2--Paths-and-Identifications.2-6--Univalence.html#11278" class="Bound">g</a><a id="11306" class="Symbol">))</a>

</pre>-->
<p>This is nice, but we now have to check that the underlying function of
this equivalence is the function we expect; that is, <code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#3016" class="Function">×-map</a></code>.
Thankfully, we checked in Lecture 2-X that transporting over a path
like <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#10966" class="Function">×-map-≡</a></code> computes to a transport in each of the components, so we
just have to use <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#9738" class="Function">ua-comp</a></code> on both sides to clear up those transports.</p>
<pre class="Agda"><a id="×-map-≃-underlying"></a><a id="11682" href="2--Paths-and-Identifications.2-6--Univalence.html#11682" class="Function">×-map-≃-underlying</a> <a id="11701" class="Symbol">:</a> <a id="11703" class="Symbol">{</a><a id="11704" href="2--Paths-and-Identifications.2-6--Univalence.html#11704" class="Bound">A</a> <a id="11706" href="2--Paths-and-Identifications.2-6--Univalence.html#11706" class="Bound">A&#39;</a> <a id="11709" href="2--Paths-and-Identifications.2-6--Univalence.html#11709" class="Bound">B</a> <a id="11711" href="2--Paths-and-Identifications.2-6--Univalence.html#11711" class="Bound">B&#39;</a> <a id="11714" class="Symbol">:</a> <a id="11716" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="11721" href="2--Paths-and-Identifications.2-6--Univalence.html#640" class="Generalizable">ℓ</a><a id="11722" class="Symbol">}</a> <a id="11724" class="Symbol">→</a> <a id="11726" class="Symbol">(</a><a id="11727" href="2--Paths-and-Identifications.2-6--Univalence.html#11727" class="Bound">f</a> <a id="11729" class="Symbol">:</a> <a id="11731" href="2--Paths-and-Identifications.2-6--Univalence.html#11704" class="Bound">A</a> <a id="11733" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="11735" href="2--Paths-and-Identifications.2-6--Univalence.html#11706" class="Bound">A&#39;</a><a id="11737" class="Symbol">)</a> <a id="11739" class="Symbol">→</a> <a id="11741" class="Symbol">(</a><a id="11742" href="2--Paths-and-Identifications.2-6--Univalence.html#11742" class="Bound">g</a> <a id="11744" class="Symbol">:</a> <a id="11746" href="2--Paths-and-Identifications.2-6--Univalence.html#11709" class="Bound">B</a> <a id="11748" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="11750" href="2--Paths-and-Identifications.2-6--Univalence.html#11711" class="Bound">B&#39;</a><a id="11752" class="Symbol">)</a>
  <a id="11756" class="Symbol">→</a> <a id="11758" class="Symbol">(</a><a id="11759" href="2--Paths-and-Identifications.2-6--Univalence.html#11131" class="Function">×-map-≃-ua</a> <a id="11770" href="2--Paths-and-Identifications.2-6--Univalence.html#11727" class="Bound">f</a> <a id="11772" href="2--Paths-and-Identifications.2-6--Univalence.html#11742" class="Bound">g</a><a id="11773" class="Symbol">)</a> <a id="11775" class="Symbol">.</a><a id="11776" class="Field">map</a> <a id="11780" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="11782" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#3016" class="Function">×-map</a> <a id="11788" class="Symbol">(</a><a id="11789" href="2--Paths-and-Identifications.2-6--Univalence.html#11727" class="Bound">f</a> <a id="11791" class="Symbol">.</a><a id="11792" class="Field">map</a><a id="11795" class="Symbol">)</a> <a id="11797" class="Symbol">(</a><a id="11798" href="2--Paths-and-Identifications.2-6--Univalence.html#11742" class="Bound">g</a> <a id="11800" class="Symbol">.</a><a id="11801" class="Field">map</a><a id="11804" class="Symbol">)</a>
<a id="11806" class="Comment">-- Exercise:</a>
<a id="11819" class="Comment">-- ×-map-≃-uat f g = {!!}</a>
</pre><!--
<pre class="Agda"><a id="11858" href="2--Paths-and-Identifications.2-6--Univalence.html#11682" class="Function">×-map-≃-underlying</a> <a id="11877" href="2--Paths-and-Identifications.2-6--Univalence.html#11877" class="Bound">f</a> <a id="11879" href="2--Paths-and-Identifications.2-6--Univalence.html#11879" class="Bound">g</a> <a id="11881" href="2--Paths-and-Identifications.2-6--Univalence.html#11881" class="Bound">i</a> <a id="11883" class="Symbol">(</a><a id="11884" href="2--Paths-and-Identifications.2-6--Univalence.html#11884" class="Bound">a</a> <a id="11886" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="11888" href="2--Paths-and-Identifications.2-6--Univalence.html#11888" class="Bound">b</a><a id="11889" class="Symbol">)</a> <a id="11891" class="Symbol">=</a> <a id="11893" href="2--Paths-and-Identifications.2-6--Univalence.html#9738" class="Function">ua-comp</a> <a id="11901" href="2--Paths-and-Identifications.2-6--Univalence.html#11877" class="Bound">f</a> <a id="11903" href="2--Paths-and-Identifications.2-6--Univalence.html#11884" class="Bound">a</a> <a id="11905" href="2--Paths-and-Identifications.2-6--Univalence.html#11881" class="Bound">i</a> <a id="11907" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="11909" href="2--Paths-and-Identifications.2-6--Univalence.html#9738" class="Function">ua-comp</a> <a id="11917" href="2--Paths-and-Identifications.2-6--Univalence.html#11879" class="Bound">g</a> <a id="11919" href="2--Paths-and-Identifications.2-6--Univalence.html#11888" class="Bound">b</a> <a id="11921" href="2--Paths-and-Identifications.2-6--Univalence.html#11881" class="Bound">i</a>

</pre>-->
<p>Then, we can transport the map proof that <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#11131" class="Function">×-map-≃-ua</a></code> is an
equivalence back over to the simpler map.</p>
<pre class="Agda"><a id="×-map-≃-again"></a><a id="12051" href="2--Paths-and-Identifications.2-6--Univalence.html#12051" class="Function">×-map-≃-again</a> <a id="12065" class="Symbol">:</a> <a id="12067" class="Symbol">{</a><a id="12068" href="2--Paths-and-Identifications.2-6--Univalence.html#12068" class="Bound">A</a> <a id="12070" href="2--Paths-and-Identifications.2-6--Univalence.html#12070" class="Bound">A&#39;</a> <a id="12073" href="2--Paths-and-Identifications.2-6--Univalence.html#12073" class="Bound">B</a> <a id="12075" href="2--Paths-and-Identifications.2-6--Univalence.html#12075" class="Bound">B&#39;</a> <a id="12078" class="Symbol">:</a> <a id="12080" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="12085" href="2--Paths-and-Identifications.2-6--Univalence.html#640" class="Generalizable">ℓ</a><a id="12086" class="Symbol">}</a>
  <a id="12090" class="Symbol">→</a> <a id="12092" class="Symbol">(</a><a id="12093" href="2--Paths-and-Identifications.2-6--Univalence.html#12068" class="Bound">A</a> <a id="12095" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="12097" href="2--Paths-and-Identifications.2-6--Univalence.html#12070" class="Bound">A&#39;</a><a id="12099" class="Symbol">)</a> <a id="12101" class="Symbol">→</a> <a id="12103" class="Symbol">(</a><a id="12104" href="2--Paths-and-Identifications.2-6--Univalence.html#12073" class="Bound">B</a> <a id="12106" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="12108" href="2--Paths-and-Identifications.2-6--Univalence.html#12075" class="Bound">B&#39;</a><a id="12110" class="Symbol">)</a> <a id="12112" class="Symbol">→</a> <a id="12114" class="Symbol">(</a><a id="12115" href="2--Paths-and-Identifications.2-6--Univalence.html#12068" class="Bound">A</a> <a id="12117" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="12119" href="2--Paths-and-Identifications.2-6--Univalence.html#12073" class="Bound">B</a><a id="12120" class="Symbol">)</a> <a id="12122" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="12124" class="Symbol">(</a><a id="12125" href="2--Paths-and-Identifications.2-6--Univalence.html#12070" class="Bound">A&#39;</a> <a id="12128" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="12130" href="2--Paths-and-Identifications.2-6--Univalence.html#12075" class="Bound">B&#39;</a><a id="12132" class="Symbol">)</a>
<a id="12134" href="2--Paths-and-Identifications.2-6--Univalence.html#12051" class="Function">×-map-≃-again</a> <a id="12148" href="2--Paths-and-Identifications.2-6--Univalence.html#12148" class="Bound">f</a> <a id="12150" href="2--Paths-and-Identifications.2-6--Univalence.html#12150" class="Bound">g</a> <a id="12152" class="Symbol">.</a><a id="12153" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5810" class="Field">map</a> <a id="12157" class="Symbol">=</a> <a id="12159" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#3016" class="Function">×-map</a> <a id="12165" class="Symbol">(</a><a id="12166" href="2--Paths-and-Identifications.2-6--Univalence.html#12148" class="Bound">f</a> <a id="12168" class="Symbol">.</a><a id="12169" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5810" class="Field">map</a><a id="12172" class="Symbol">)</a> <a id="12174" class="Symbol">(</a><a id="12175" href="2--Paths-and-Identifications.2-6--Univalence.html#12150" class="Bound">g</a> <a id="12177" class="Symbol">.</a><a id="12178" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5810" class="Field">map</a><a id="12181" class="Symbol">)</a>
<a id="12183" href="2--Paths-and-Identifications.2-6--Univalence.html#12051" class="Function">×-map-≃-again</a> <a id="12197" href="2--Paths-and-Identifications.2-6--Univalence.html#12197" class="Bound">f</a> <a id="12199" href="2--Paths-and-Identifications.2-6--Univalence.html#12199" class="Bound">g</a> <a id="12201" class="Symbol">.</a><a id="12202" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5826" class="Field">proof</a> <a id="12208" class="Symbol">=</a> <a id="12210" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1180" class="Function">subst</a> <a id="12216" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5531" class="Record">isEquiv</a> <a id="12224" class="Symbol">(</a><a id="12225" href="2--Paths-and-Identifications.2-6--Univalence.html#11682" class="Function">×-map-≃-underlying</a> <a id="12244" href="2--Paths-and-Identifications.2-6--Univalence.html#12197" class="Bound">f</a> <a id="12246" href="2--Paths-and-Identifications.2-6--Univalence.html#12199" class="Bound">g</a><a id="12247" class="Symbol">)</a> <a id="12249" class="Symbol">(</a><a id="12250" href="2--Paths-and-Identifications.2-6--Univalence.html#11131" class="Function">×-map-≃-ua</a> <a id="12261" href="2--Paths-and-Identifications.2-6--Univalence.html#12197" class="Bound">f</a> <a id="12263" href="2--Paths-and-Identifications.2-6--Univalence.html#12199" class="Bound">g</a> <a id="12265" class="Symbol">.</a><a id="12266" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5826" class="Field">proof</a><a id="12271" class="Symbol">)</a>
</pre>
<p>There is a downside to proving this kind of equivalence using
univalence: <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#11131" class="Function">×-map-≃-ua</a></code> only works for types that all lie in the
same universe, whereas our original <code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#3016" class="Function">×-map</a></code> is completely universe
polymorphic.</p>
<h2 id="dependent-univalence"><a class="header" href="#dependent-univalence">Dependent Univalence</a></h2>
<p>mvrnote: useful anywhere?</p>
<p>from Cubical.Foundations.Univalence.Dependent</p>
<pre class="Agda"><a id="12594" class="Comment">-- module _</a>
  <a id="12608" class="Comment">-- {A B : Type ℓ} {P : A → Type ℓ&#39;} {Q : B → Type ℓ&#39;}</a>
  <a id="12664" class="Comment">-- (e : A ≃ B) (F : (a : A) → P a → Q (e .map a))</a>
  <a id="12716" class="Comment">-- (iseq : (a : A) → isEquiv (F a))</a>
  <a id="12754" class="Comment">-- where</a>
  <a id="12765" class="Comment">-- private</a>
  <a id="12778" class="Comment">--   -- Bundle `F` and `equiv` into a pointwise equivalence of `P` and `Q`:</a>
  <a id="12856" class="Comment">--   Γ : (a : A) → P a ≃ Q (e .map a)</a>
  <a id="12896" class="Comment">--   Γ a = equiv (F a) (iseq a)</a>

  <a id="12931" class="Comment">-- uaP : PathP (λ i → ua e i → Type ℓ&#39;) P Q</a>
  <a id="12977" class="Comment">-- uaP i x = Glue Base {∂ i} equiv-boundary where</a>
  <a id="13029" class="Comment">--   -- Like `ua`, `uaOver` is obtained from a line of</a>
  <a id="13086" class="Comment">--   -- Glue-types, except that they are glued</a>
  <a id="13135" class="Comment">--   -- over a line dependent on `ua e : A ≡ B`.</a>

  <a id="13187" class="Comment">--   -- `x` is a point along the path `A ≡ B` obtained</a>
  <a id="13244" class="Comment">--   -- from univalence, i.e. glueing over `B`:</a>
  <a id="13294" class="Comment">--   --</a>
  <a id="13304" class="Comment">--   --  A = = (ua e) = = B</a>
  <a id="13334" class="Comment">--   --  |                |</a>
  <a id="13364" class="Comment">--   -- (e)          (idEquiv B)</a>
  <a id="13399" class="Comment">--   --  |                |</a>
  <a id="13429" class="Comment">--   --  v                v</a>
  <a id="13459" class="Comment">--   --  B =====(B)====== B</a>
  <a id="13489" class="Comment">--   _ : Glue B {φ = i ∨ ~ i} (λ { (i = i0) → A , e ; (i = i1) → B , idEquiv B })</a>
  <a id="13573" class="Comment">--   _ = x</a>

  <a id="13587" class="Comment">--   -- We can therefore `unglue` it to obtain a term in the base line of `ua e`,</a>
  <a id="13671" class="Comment">--   -- i.e. term of type `B`:</a>
  <a id="13704" class="Comment">--   b : B</a>
  <a id="13717" class="Comment">--   b = unglue (∂ i) x</a>

  <a id="13744" class="Comment">--   -- This gives us a line `(i : I) ⊢ Base` in the universe of types,</a>
  <a id="13818" class="Comment">--   -- along which we can glue the equivalences `Γ x` and `idEquiv (Q x)`:</a>
  <a id="13896" class="Comment">--   --</a>
  <a id="13906" class="Comment">--   -- P (e x) = = = = = = Q x</a>
  <a id="13940" class="Comment">--   --    |                |</a>
  <a id="13972" class="Comment">--   --  (Γ x)        (idEquiv (Q x))</a>
  <a id="14012" class="Comment">--   --    |                |</a>
  <a id="14044" class="Comment">--   --    v                v</a>
  <a id="14076" class="Comment">--   --   Q x ===(Base)=== Q x</a>
  <a id="14109" class="Comment">--   Base : Type ℓ&#39;</a>
  <a id="14131" class="Comment">--   Base = Q b</a>

  <a id="14150" class="Comment">--   equiv-boundary : Partial (∂ i) (Σ[ T ∈ Type ℓ&#39; ] T ≃ Base)</a>
  <a id="14216" class="Comment">--   equiv-boundary (i = i0) = P x , Γ x</a>
  <a id="14259" class="Comment">--   equiv-boundary (i = i1) = Q x , idEquiv (Q x)</a>

  <a id="14313" class="Comment">--   -- Note that above `(i = i0) ⊢ x : A` and `(i = i1) ⊢ x : B`,</a>
  <a id="14382" class="Comment">--   -- thus `P x` and `Q x` are well-typed.</a>
  <a id="14429" class="Comment">--   _ : Partial i B</a>
  <a id="14452" class="Comment">--   _ = λ { (i = i1) → x }</a>

  <a id="14483" class="Comment">--   _ : Partial (~ i) A</a>
  <a id="14510" class="Comment">--   _ = λ { (i = i0) → x }</a>
</pre>
<pre class="Agda"><a id="14547" class="Comment">-- module _ {A A&#39; : Type ℓ} {B : A → Type ℓ&#39;} {B&#39; : A&#39; → Type ℓ&#39;} (e₁ : A ≃ A&#39;) (e₂ : (x : A) → B x ≃ B&#39; (e₁ .map x)) where</a>
<a id="14671" class="Comment">--   Σ-map-ua : (Σ[ a ∈ A ] B a) ≃ (Σ[ a&#39; ∈ A&#39; ] B&#39; a&#39;)</a>
<a id="14727" class="Comment">--   Σ-map-ua = au λ i → Σ[ a ∈ ua e₁ i ] uaP e₁ (λ x → e₂ x .map) (λ x → e₂ x .proof) i a</a>

<a id="14819" class="Comment">--   Σ-map-ua-step1 : Σ-map-ua .map ≡ λ (a , b) → (transport (ua e₁) a) , transport (λ i → uaP {P = B} {Q = B&#39;} e₁ (λ x → e₂ x .map) (λ x → e₂ x .proof) i (transport-filler (ua e₁) a i)) b</a>
<a id="15008" class="Comment">--   Σ-map-ua-step1 = refl</a>

<a id="15036" class="Comment">--   Σ-map-ua-underlying : Σ-map-ua .map ≡ Σ-map (e₁ .map) (λ a → e₂ a .map)</a>
<a id="15113" class="Comment">--   Σ-map-ua-underlying i (a , b) .fst = ua-comp e₁ a i</a>
<a id="15170" class="Comment">--   Σ-map-ua-underlying i (a , b) .snd = {!!}</a>
</pre>
<h2 id="addition-as-path-composition"><a class="header" href="#addition-as-path-composition">Addition as Path Composition</a></h2>
<p>Here’s a fun first application: we can implement addition in
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a></code> as composition of paths of type <code>ℤ ≡ ℤ</code>. This leads to a
one-line proof that addition is invertible.</p>
<p>We showed previously that <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#19415" class="Function">sucℤ</a></code> is an equivalence, and
univalence lets us turn this into a path <code>ℤ ≡ ℤ</code>.</p>
<pre class="Agda"><a id="sucℤ-≡"></a><a id="15538" href="2--Paths-and-Identifications.2-6--Univalence.html#15538" class="Function">sucℤ-≡</a> <a id="15545" class="Symbol">:</a> <a id="15547" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="15549" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="15551" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
<a id="15553" href="2--Paths-and-Identifications.2-6--Univalence.html#15538" class="Function">sucℤ-≡</a> <a id="15560" class="Symbol">=</a> <a id="15562" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="15565" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#21340" class="Function">sucℤ-≃</a>
</pre>
<p>This is the path that corresponds to adding 1, and by composing this
path with itself repeatedly we can produce a path that corresponds to
adding any fixed integer.</p>
<p>This iterated composition makes sense for any path starting and ending
at the same element, so we define it in general. For negative
integers, we simply compose with the inverse of the loop. There are
two ways to define it, repeatedly composing on the left or composing
on the right. This choice will matter for later definitions, so
compose on the ∙right∙.</p>
<pre class="Agda"><a id="iterateⁿ"></a><a id="16106" href="2--Paths-and-Identifications.2-6--Univalence.html#16106" class="Function">iterateⁿ</a> <a id="16115" class="Symbol">:</a> <a id="16117" class="Symbol">{</a><a id="16118" href="2--Paths-and-Identifications.2-6--Univalence.html#16118" class="Bound">x</a> <a id="16120" class="Symbol">:</a> <a id="16122" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a><a id="16123" class="Symbol">}</a> <a id="16125" class="Symbol">→</a> <a id="16127" href="2--Paths-and-Identifications.2-6--Univalence.html#16118" class="Bound">x</a> <a id="16129" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="16131" href="2--Paths-and-Identifications.2-6--Univalence.html#16118" class="Bound">x</a> <a id="16133" class="Symbol">→</a> <a id="16135" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="16137" class="Symbol">→</a> <a id="16139" href="2--Paths-and-Identifications.2-6--Univalence.html#16118" class="Bound">x</a> <a id="16141" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="16143" href="2--Paths-and-Identifications.2-6--Univalence.html#16118" class="Bound">x</a>
<a id="16145" class="Comment">-- Exercise: (Remember to be careful with `negsuc`!)</a>
<a id="16198" class="Comment">-- iterateⁿ p z = {!!}</a>
</pre><!--
<pre class="Agda"><a id="16234" href="2--Paths-and-Identifications.2-6--Univalence.html#16106" class="Function">iterateⁿ</a> <a id="16243" href="2--Paths-and-Identifications.2-6--Univalence.html#16243" class="Bound">p</a> <a id="16245" class="Symbol">(</a><a id="16246" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="16250" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="16254" class="Symbol">)</a> <a id="16256" class="Symbol">=</a> <a id="16258" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a>
<a id="16263" href="2--Paths-and-Identifications.2-6--Univalence.html#16106" class="Function">iterateⁿ</a> <a id="16272" href="2--Paths-and-Identifications.2-6--Univalence.html#16272" class="Bound">p</a> <a id="16274" class="Symbol">(</a><a id="16275" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="16279" class="Symbol">(</a><a id="16280" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="16284" href="2--Paths-and-Identifications.2-6--Univalence.html#16284" class="Bound">n</a><a id="16285" class="Symbol">))</a> <a id="16288" class="Symbol">=</a> <a id="16290" href="2--Paths-and-Identifications.2-6--Univalence.html#16106" class="Function">iterateⁿ</a> <a id="16299" href="2--Paths-and-Identifications.2-6--Univalence.html#16272" class="Bound">p</a> <a id="16301" class="Symbol">(</a><a id="16302" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="16306" href="2--Paths-and-Identifications.2-6--Univalence.html#16284" class="Bound">n</a><a id="16307" class="Symbol">)</a> <a id="16309" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#15893" class="Function Operator">∙</a> <a id="16311" href="2--Paths-and-Identifications.2-6--Univalence.html#16272" class="Bound">p</a>
<a id="16313" href="2--Paths-and-Identifications.2-6--Univalence.html#16106" class="Function">iterateⁿ</a> <a id="16322" href="2--Paths-and-Identifications.2-6--Univalence.html#16322" class="Bound">p</a> <a id="16324" class="Symbol">(</a><a id="16325" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="16332" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="16336" class="Symbol">)</a> <a id="16338" class="Symbol">=</a> <a id="16340" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#22904" class="Function">sym</a> <a id="16344" href="2--Paths-and-Identifications.2-6--Univalence.html#16322" class="Bound">p</a>
<a id="16346" href="2--Paths-and-Identifications.2-6--Univalence.html#16106" class="Function">iterateⁿ</a> <a id="16355" href="2--Paths-and-Identifications.2-6--Univalence.html#16355" class="Bound">p</a> <a id="16357" class="Symbol">(</a><a id="16358" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="16365" class="Symbol">(</a><a id="16366" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="16370" href="2--Paths-and-Identifications.2-6--Univalence.html#16370" class="Bound">n</a><a id="16371" class="Symbol">))</a> <a id="16374" class="Symbol">=</a> <a id="16376" href="2--Paths-and-Identifications.2-6--Univalence.html#16106" class="Function">iterateⁿ</a> <a id="16385" href="2--Paths-and-Identifications.2-6--Univalence.html#16355" class="Bound">p</a> <a id="16387" class="Symbol">(</a><a id="16388" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="16395" href="2--Paths-and-Identifications.2-6--Univalence.html#16370" class="Bound">n</a><a id="16396" class="Symbol">)</a> <a id="16398" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#15893" class="Function Operator">∙</a> <a id="16400" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#22904" class="Function">sym</a> <a id="16404" href="2--Paths-and-Identifications.2-6--Univalence.html#16355" class="Bound">p</a>

</pre>-->
<pre class="Agda">
<a id="16420" class="Comment">-- To make sure you composed the right way:</a>
<a id="16464" href="2--Paths-and-Identifications.2-6--Univalence.html#16464" class="Function">_</a> <a id="16466" class="Symbol">=</a> <a id="16468" class="Symbol">λ</a> <a id="16470" class="Symbol">{</a><a id="16471" href="2--Paths-and-Identifications.2-6--Univalence.html#16471" class="Bound">A</a> <a id="16473" class="Symbol">:</a> <a id="16475" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="16479" class="Symbol">}</a> <a id="16481" class="Symbol">{</a><a id="16482" href="2--Paths-and-Identifications.2-6--Univalence.html#16482" class="Bound">x</a> <a id="16484" class="Symbol">:</a> <a id="16486" href="2--Paths-and-Identifications.2-6--Univalence.html#16471" class="Bound">A</a><a id="16487" class="Symbol">}</a> <a id="16489" class="Symbol">(</a><a id="16490" href="2--Paths-and-Identifications.2-6--Univalence.html#16490" class="Bound">p</a> <a id="16492" class="Symbol">:</a> <a id="16494" href="2--Paths-and-Identifications.2-6--Univalence.html#16482" class="Bound">x</a> <a id="16496" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="16498" href="2--Paths-and-Identifications.2-6--Univalence.html#16482" class="Bound">x</a><a id="16499" class="Symbol">)</a> <a id="16501" class="Symbol">→</a> <a id="16503" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="16518" class="Symbol">(</a><a id="16519" href="2--Paths-and-Identifications.2-6--Univalence.html#16106" class="Function">iterateⁿ</a> <a id="16528" href="2--Paths-and-Identifications.2-6--Univalence.html#16490" class="Bound">p</a> <a id="16530" class="Number">2</a><a id="16531" class="Symbol">)</a>    <a id="16536" class="Symbol">((</a><a id="16538" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a> <a id="16543" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#15893" class="Function Operator">∙</a> <a id="16545" href="2--Paths-and-Identifications.2-6--Univalence.html#16490" class="Bound">p</a><a id="16546" class="Symbol">)</a> <a id="16548" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#15893" class="Function Operator">∙</a> <a id="16550" href="2--Paths-and-Identifications.2-6--Univalence.html#16490" class="Bound">p</a><a id="16551" class="Symbol">)</a>
<a id="16553" href="2--Paths-and-Identifications.2-6--Univalence.html#16553" class="Function">_</a> <a id="16555" class="Symbol">=</a> <a id="16557" class="Symbol">λ</a> <a id="16559" class="Symbol">{</a><a id="16560" href="2--Paths-and-Identifications.2-6--Univalence.html#16560" class="Bound">A</a> <a id="16562" class="Symbol">:</a> <a id="16564" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="16568" class="Symbol">}</a> <a id="16570" class="Symbol">{</a><a id="16571" href="2--Paths-and-Identifications.2-6--Univalence.html#16571" class="Bound">x</a> <a id="16573" class="Symbol">:</a> <a id="16575" href="2--Paths-and-Identifications.2-6--Univalence.html#16560" class="Bound">A</a><a id="16576" class="Symbol">}</a> <a id="16578" class="Symbol">(</a><a id="16579" href="2--Paths-and-Identifications.2-6--Univalence.html#16579" class="Bound">p</a> <a id="16581" class="Symbol">:</a> <a id="16583" href="2--Paths-and-Identifications.2-6--Univalence.html#16571" class="Bound">x</a> <a id="16585" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="16587" href="2--Paths-and-Identifications.2-6--Univalence.html#16571" class="Bound">x</a><a id="16588" class="Symbol">)</a> <a id="16590" class="Symbol">→</a> <a id="16592" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="16607" class="Symbol">(</a><a id="16608" href="2--Paths-and-Identifications.2-6--Univalence.html#16106" class="Function">iterateⁿ</a> <a id="16617" href="2--Paths-and-Identifications.2-6--Univalence.html#16579" class="Bound">p</a> <a id="16619" class="Symbol">(</a><a id="16620" class="Number">-2</a><a id="16622" class="Symbol">))</a> <a id="16625" class="Symbol">((</a><a id="16627" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#22904" class="Function">sym</a> <a id="16631" href="2--Paths-and-Identifications.2-6--Univalence.html#16579" class="Bound">p</a><a id="16632" class="Symbol">)</a> <a id="16634" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#15893" class="Function Operator">∙</a> <a id="16636" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#22904" class="Function">sym</a> <a id="16640" href="2--Paths-and-Identifications.2-6--Univalence.html#16579" class="Bound">p</a><a id="16641" class="Symbol">)</a>
</pre>
<p>Then the path corresponding to adding any fixed integer is:</p>
<pre class="Agda"><a id="add-ℤ-≡"></a><a id="16713" href="2--Paths-and-Identifications.2-6--Univalence.html#16713" class="Function">add-ℤ-≡</a> <a id="16721" class="Symbol">:</a> <a id="16723" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="16725" class="Symbol">→</a> <a id="16727" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="16729" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="16731" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
<a id="16733" href="2--Paths-and-Identifications.2-6--Univalence.html#16713" class="Function">add-ℤ-≡</a> <a id="16741" class="Symbol">=</a> <a id="16743" href="2--Paths-and-Identifications.2-6--Univalence.html#16106" class="Function">iterateⁿ</a> <a id="16752" href="2--Paths-and-Identifications.2-6--Univalence.html#15538" class="Function">sucℤ-≡</a>
</pre>
<p>Here’s the upshot: we can define addition of integers by turning one
of them into a path using <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#16713" class="Function">add-ℤ-≡</a></code> and then transporting the other
integer along that path. Transport along a path created by univalence
applies the underlying function, which in this case is <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#19415" class="Function">sucℤ</a></code>. And
so transporting along this path repeatedly indeed adds one integer to
the other!</p>
<pre class="Agda"><a id="_+ℤᵘ_"></a><a id="17128" href="2--Paths-and-Identifications.2-6--Univalence.html#17128" class="Function Operator">_+ℤᵘ_</a> <a id="17134" class="Symbol">:</a> <a id="17136" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="17138" class="Symbol">→</a> <a id="17140" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="17142" class="Symbol">→</a> <a id="17144" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
<a id="17146" href="2--Paths-and-Identifications.2-6--Univalence.html#17146" class="Bound">m</a> <a id="17148" href="2--Paths-and-Identifications.2-6--Univalence.html#17128" class="Function Operator">+ℤᵘ</a> <a id="17152" href="2--Paths-and-Identifications.2-6--Univalence.html#17152" class="Bound">n</a> <a id="17154" class="Symbol">=</a> <a id="17156" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a> <a id="17166" class="Symbol">(</a><a id="17167" href="2--Paths-and-Identifications.2-6--Univalence.html#16713" class="Function">add-ℤ-≡</a> <a id="17175" href="2--Paths-and-Identifications.2-6--Univalence.html#17152" class="Bound">n</a><a id="17176" class="Symbol">)</a> <a id="17178" href="2--Paths-and-Identifications.2-6--Univalence.html#17146" class="Bound">m</a>

<a id="17181" href="2--Paths-and-Identifications.2-6--Univalence.html#17181" class="Function">_</a> <a id="17183" class="Symbol">=</a> <a id="17185" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="17200" class="Symbol">(</a><a id="17201" class="Number">0</a> <a id="17203" href="2--Paths-and-Identifications.2-6--Univalence.html#17128" class="Function Operator">+ℤᵘ</a> <a id="17207" class="Number">0</a><a id="17208" class="Symbol">)</a> <a id="17210" class="Number">0</a>
<a id="17212" href="2--Paths-and-Identifications.2-6--Univalence.html#17212" class="Function">_</a> <a id="17214" class="Symbol">=</a> <a id="17216" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="17231" class="Symbol">(</a><a id="17232" class="Number">0</a> <a id="17234" href="2--Paths-and-Identifications.2-6--Univalence.html#17128" class="Function Operator">+ℤᵘ</a> <a id="17238" class="Number">1</a><a id="17239" class="Symbol">)</a> <a id="17241" class="Number">1</a>
<a id="17243" href="2--Paths-and-Identifications.2-6--Univalence.html#17243" class="Function">_</a> <a id="17245" class="Symbol">=</a> <a id="17247" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="17262" class="Symbol">(</a><a id="17263" class="Number">1</a> <a id="17265" href="2--Paths-and-Identifications.2-6--Univalence.html#17128" class="Function Operator">+ℤᵘ</a> <a id="17269" class="Number">0</a><a id="17270" class="Symbol">)</a> <a id="17272" class="Number">1</a>
<a id="17274" href="2--Paths-and-Identifications.2-6--Univalence.html#17274" class="Function">_</a> <a id="17276" class="Symbol">=</a> <a id="17278" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="17293" class="Symbol">(</a><a id="17294" class="Number">19</a> <a id="17297" href="2--Paths-and-Identifications.2-6--Univalence.html#17128" class="Function Operator">+ℤᵘ</a> <a id="17301" class="Number">34</a><a id="17303" class="Symbol">)</a> <a id="17305" class="Number">53</a>
<a id="17308" href="2--Paths-and-Identifications.2-6--Univalence.html#17308" class="Function">_</a> <a id="17310" class="Symbol">=</a> <a id="17312" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="17327" class="Symbol">(</a><a id="17328" class="Number">-19</a> <a id="17332" href="2--Paths-and-Identifications.2-6--Univalence.html#17128" class="Function Operator">+ℤᵘ</a> <a id="17336" class="Number">34</a><a id="17338" class="Symbol">)</a> <a id="17340" class="Number">15</a>
</pre>
<p>It is easy to show that this always agrees with the ordinary addition
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function">+ℤ</a></code>, by case-splitting on <code>n</code>.</p>
<pre class="Agda"><a id="+ℤᵘ≡+ℤ"></a><a id="17457" href="2--Paths-and-Identifications.2-6--Univalence.html#17457" class="Function">+ℤᵘ≡+ℤ</a> <a id="17464" class="Symbol">:</a> <a id="17466" href="2--Paths-and-Identifications.2-6--Univalence.html#17128" class="Function Operator">_+ℤᵘ_</a> <a id="17472" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="17474" href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function Operator">_+ℤ_</a>
<a id="17479" class="Comment">-- Exercise:</a>
<a id="17492" class="Comment">-- +ℤᵘ≡+ℤ i m n = {!!}</a>
</pre><!--
<pre class="Agda"><a id="17528" href="2--Paths-and-Identifications.2-6--Univalence.html#17457" class="Function">+ℤᵘ≡+ℤ</a> <a id="17535" href="2--Paths-and-Identifications.2-6--Univalence.html#17535" class="Bound">i</a> <a id="17537" href="2--Paths-and-Identifications.2-6--Univalence.html#17537" class="Bound">m</a> <a id="17539" class="Symbol">(</a><a id="17540" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="17544" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="17548" class="Symbol">)</a> <a id="17550" class="Symbol">=</a> <a id="17552" href="2--Paths-and-Identifications.2-6--Univalence.html#17537" class="Bound">m</a>
<a id="17554" href="2--Paths-and-Identifications.2-6--Univalence.html#17457" class="Function">+ℤᵘ≡+ℤ</a> <a id="17561" href="2--Paths-and-Identifications.2-6--Univalence.html#17561" class="Bound">i</a> <a id="17563" href="2--Paths-and-Identifications.2-6--Univalence.html#17563" class="Bound">m</a> <a id="17565" class="Symbol">(</a><a id="17566" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="17570" class="Symbol">(</a><a id="17571" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="17575" href="2--Paths-and-Identifications.2-6--Univalence.html#17575" class="Bound">n</a><a id="17576" class="Symbol">))</a> <a id="17579" class="Symbol">=</a> <a id="17581" href="1--Type-Theory.1-2--Inductive-Types.html#19415" class="Function">sucℤ</a> <a id="17586" class="Symbol">(</a><a id="17587" href="2--Paths-and-Identifications.2-6--Univalence.html#17457" class="Function">+ℤᵘ≡+ℤ</a> <a id="17594" href="2--Paths-and-Identifications.2-6--Univalence.html#17561" class="Bound">i</a> <a id="17596" href="2--Paths-and-Identifications.2-6--Univalence.html#17563" class="Bound">m</a> <a id="17598" class="Symbol">(</a><a id="17599" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="17603" href="2--Paths-and-Identifications.2-6--Univalence.html#17575" class="Bound">n</a><a id="17604" class="Symbol">))</a>
<a id="17607" href="2--Paths-and-Identifications.2-6--Univalence.html#17457" class="Function">+ℤᵘ≡+ℤ</a> <a id="17614" href="2--Paths-and-Identifications.2-6--Univalence.html#17614" class="Bound">i</a> <a id="17616" href="2--Paths-and-Identifications.2-6--Univalence.html#17616" class="Bound">m</a> <a id="17618" class="Symbol">(</a><a id="17619" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="17626" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="17630" class="Symbol">)</a> <a id="17632" class="Symbol">=</a> <a id="17634" href="1--Type-Theory.1-2--Inductive-Types.html#19642" class="Function">predℤ</a> <a id="17640" href="2--Paths-and-Identifications.2-6--Univalence.html#17616" class="Bound">m</a>
<a id="17642" href="2--Paths-and-Identifications.2-6--Univalence.html#17457" class="Function">+ℤᵘ≡+ℤ</a> <a id="17649" href="2--Paths-and-Identifications.2-6--Univalence.html#17649" class="Bound">i</a> <a id="17651" href="2--Paths-and-Identifications.2-6--Univalence.html#17651" class="Bound">m</a> <a id="17653" class="Symbol">(</a><a id="17654" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="17661" class="Symbol">(</a><a id="17662" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="17666" href="2--Paths-and-Identifications.2-6--Univalence.html#17666" class="Bound">n</a><a id="17667" class="Symbol">))</a> <a id="17670" class="Symbol">=</a> <a id="17672" href="1--Type-Theory.1-2--Inductive-Types.html#19642" class="Function">predℤ</a> <a id="17678" class="Symbol">(</a><a id="17679" href="2--Paths-and-Identifications.2-6--Univalence.html#17457" class="Function">+ℤᵘ≡+ℤ</a> <a id="17686" href="2--Paths-and-Identifications.2-6--Univalence.html#17649" class="Bound">i</a> <a id="17688" href="2--Paths-and-Identifications.2-6--Univalence.html#17651" class="Bound">m</a> <a id="17690" class="Symbol">(</a><a id="17691" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="17698" href="2--Paths-and-Identifications.2-6--Univalence.html#17666" class="Bound">n</a><a id="17699" class="Symbol">))</a>

</pre>-->
<p>Now, a nice trick. Because <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#17128" class="Function">+ℤᵘ</a></code> for a fixed <code>n</code> is defined via
<code class="Agda"><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a></code>, it is automatically an equivalence:</p>
<pre class="Agda"><a id="isEquiv-+ℤᵘ"></a><a id="17842" href="2--Paths-and-Identifications.2-6--Univalence.html#17842" class="Function">isEquiv-+ℤᵘ</a> <a id="17854" class="Symbol">:</a> <a id="17856" class="Symbol">(</a><a id="17857" href="2--Paths-and-Identifications.2-6--Univalence.html#17857" class="Bound">m</a> <a id="17859" class="Symbol">:</a> <a id="17861" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a><a id="17862" class="Symbol">)</a> <a id="17864" class="Symbol">→</a> <a id="17866" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5531" class="Record">isEquiv</a> <a id="17874" class="Symbol">(λ</a> <a id="17877" href="2--Paths-and-Identifications.2-6--Univalence.html#17877" class="Bound">n</a> <a id="17879" class="Symbol">→</a> <a id="17881" href="2--Paths-and-Identifications.2-6--Univalence.html#17877" class="Bound">n</a> <a id="17883" href="2--Paths-and-Identifications.2-6--Univalence.html#17128" class="Function Operator">+ℤᵘ</a> <a id="17887" href="2--Paths-and-Identifications.2-6--Univalence.html#17857" class="Bound">m</a><a id="17888" class="Symbol">)</a>
<a id="17890" class="Comment">-- Exercise: (Hint: <code class="Agda"><a href="2--Paths-and-Identifications.2-5--Transport.html#5441" class="Function">path→equiv</a></code>)</a>
<a id="17926" class="Comment">-- isEquiv-+ℤᵘ n = {!!}</a>
</pre><!--
<pre class="Agda"><a id="17963" href="2--Paths-and-Identifications.2-6--Univalence.html#17842" class="Function">isEquiv-+ℤᵘ</a> <a id="17975" href="2--Paths-and-Identifications.2-6--Univalence.html#17975" class="Bound">n</a> <a id="17977" class="Symbol">=</a> <a id="17979" href="2--Paths-and-Identifications.2-5--Transport.html#5441" class="Function">path→equiv</a> <a id="17990" class="Symbol">(</a><a id="17991" href="2--Paths-and-Identifications.2-6--Univalence.html#16713" class="Function">add-ℤ-≡</a> <a id="17999" href="2--Paths-and-Identifications.2-6--Univalence.html#17975" class="Bound">n</a><a id="18000" class="Symbol">)</a> <a id="18002" class="Symbol">.</a><a id="18003" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5826" class="Field">proof</a>

</pre>-->
<p>And because we have just shown that <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#17128" class="Function">+ℤᵘ</a></code> is equal to
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function">+ℤ</a></code>, we get a proof that the same is true for <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function">+ℤ</a></code> with
no extra effort.</p>
<pre class="Agda"><a id="isEquiv-+ℤ"></a><a id="18166" href="2--Paths-and-Identifications.2-6--Univalence.html#18166" class="Function">isEquiv-+ℤ</a> <a id="18177" class="Symbol">:</a> <a id="18179" class="Symbol">(</a><a id="18180" href="2--Paths-and-Identifications.2-6--Univalence.html#18180" class="Bound">m</a> <a id="18182" class="Symbol">:</a> <a id="18184" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a><a id="18185" class="Symbol">)</a> <a id="18187" class="Symbol">→</a> <a id="18189" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5531" class="Record">isEquiv</a> <a id="18197" class="Symbol">(λ</a> <a id="18200" href="2--Paths-and-Identifications.2-6--Univalence.html#18200" class="Bound">n</a> <a id="18202" class="Symbol">→</a> <a id="18204" href="2--Paths-and-Identifications.2-6--Univalence.html#18200" class="Bound">n</a> <a id="18206" href="1--Type-Theory.1-2--Inductive-Types.html#20555" class="Function Operator">+ℤ</a> <a id="18209" href="2--Paths-and-Identifications.2-6--Univalence.html#18180" class="Bound">m</a><a id="18210" class="Symbol">)</a>
<a id="18212" class="Comment">-- Exercise:</a>
<a id="18225" class="Comment">-- isEquiv-+ℤ = subst {!!} {!!} {!!}</a>
</pre><!--
<pre class="Agda"><a id="18275" href="2--Paths-and-Identifications.2-6--Univalence.html#18166" class="Function">isEquiv-+ℤ</a> <a id="18286" class="Symbol">=</a> <a id="18288" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1180" class="Function">subst</a> <a id="18294" class="Symbol">(λ</a> <a id="18297" href="2--Paths-and-Identifications.2-6--Univalence.html#18297" class="Bound">plus</a> <a id="18302" class="Symbol">→</a> <a id="18304" class="Symbol">(</a><a id="18305" href="2--Paths-and-Identifications.2-6--Univalence.html#18305" class="Bound">m</a> <a id="18307" class="Symbol">:</a> <a id="18309" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a><a id="18310" class="Symbol">)</a> <a id="18312" class="Symbol">→</a> <a id="18314" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5531" class="Record">isEquiv</a> <a id="18322" class="Symbol">(λ</a> <a id="18325" href="2--Paths-and-Identifications.2-6--Univalence.html#18325" class="Bound">n</a> <a id="18327" class="Symbol">→</a> <a id="18329" href="2--Paths-and-Identifications.2-6--Univalence.html#18297" class="Bound">plus</a> <a id="18334" href="2--Paths-and-Identifications.2-6--Univalence.html#18325" class="Bound">n</a> <a id="18336" href="2--Paths-and-Identifications.2-6--Univalence.html#18305" class="Bound">m</a><a id="18337" class="Symbol">))</a> <a id="18340" href="2--Paths-and-Identifications.2-6--Univalence.html#17457" class="Function">+ℤᵘ≡+ℤ</a> <a id="18347" href="2--Paths-and-Identifications.2-6--Univalence.html#17842" class="Function">isEquiv-+ℤᵘ</a>

</pre>-->
<h2 id="the-fundamental-group-of-the-circle"><a class="header" href="#the-fundamental-group-of-the-circle">The Fundamental Group of the Circle</a></h2>
<p>An amazing consequence of univalence is that it grants type theory
access to a lot of higher-dimensional homotopical structure. The
primary way it does this is by letting us construct interesting type
families.</p>
<p>Here’s a first example: the “double cover” of the circle <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a></code>. This
is a type family with two elements over <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a></code>, for which
<code class="Agda"><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1843" class="Function">transport</a></code>ing along the <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a></code> flips those two points.</p>
<pre class="Agda"><a id="not-Path"></a><a id="18825" href="2--Paths-and-Identifications.2-6--Univalence.html#18825" class="Function">not-Path</a> <a id="18834" class="Symbol">:</a> <a id="18836" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a> <a id="18841" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="18843" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="18848" href="2--Paths-and-Identifications.2-6--Univalence.html#18825" class="Function">not-Path</a> <a id="18857" class="Symbol">=</a> <a id="18859" href="2--Paths-and-Identifications.2-6--Univalence.html#5276" class="Function">ua</a> <a id="18862" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#20994" class="Function">not-≃</a>

<a id="double-cover"></a><a id="18869" href="2--Paths-and-Identifications.2-6--Univalence.html#18869" class="Function">double-cover</a> <a id="18882" class="Symbol">:</a> <a id="18884" href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a> <a id="18887" class="Symbol">→</a> <a id="18889" href="Library.Primitive.html#422" class="Primitive">Type</a>
<a id="18894" href="2--Paths-and-Identifications.2-6--Univalence.html#18869" class="Function">double-cover</a> <a id="18907" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a> <a id="18912" class="Symbol">=</a> <a id="18914" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="18919" href="2--Paths-and-Identifications.2-6--Univalence.html#18869" class="Function">double-cover</a> <a id="18932" class="Symbol">(</a><a id="18933" href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a> <a id="18938" href="2--Paths-and-Identifications.2-6--Univalence.html#18938" class="Bound">i</a><a id="18939" class="Symbol">)</a> <a id="18941" class="Symbol">=</a> <a id="18943" href="2--Paths-and-Identifications.2-6--Univalence.html#18825" class="Function">not-Path</a> <a id="18952" href="2--Paths-and-Identifications.2-6--Univalence.html#18938" class="Bound">i</a>
</pre>
<p>mvrnote: picture is mandatory here from hott game?</p>
<p>This type family lets us show that the circle is non-trivial, which is
a fact we didn’t know for sure previously!</p>
<pre class="Agda"><a id="refl≢loop"></a><a id="19130" href="2--Paths-and-Identifications.2-6--Univalence.html#19130" class="Function">refl≢loop</a> <a id="19140" class="Symbol">:</a> <a id="19142" href="1--Type-Theory.1-5--Propositions-as-Types.html#5103" class="Function Operator">¬</a> <a id="19144" class="Symbol">(</a><a id="19145" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a> <a id="19150" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="19152" href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a><a id="19156" class="Symbol">)</a>
<a id="19158" class="Comment">-- Exercise: (Hint: Use <code class="Agda"><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1180" class="Function">subst</a></code> to prove `true ≡ false`.)</a>
<a id="19218" class="Comment">-- refl≢loop p = {!!}</a>
</pre><!--
<pre class="Agda"><a id="19253" href="2--Paths-and-Identifications.2-6--Univalence.html#19130" class="Function">refl≢loop</a> <a id="19263" href="2--Paths-and-Identifications.2-6--Univalence.html#19263" class="Bound">p</a> <a id="19265" class="Symbol">=</a> <a id="19267" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#2491" class="Function">true≢false</a> <a id="19278" class="Symbol">(λ</a> <a id="19281" href="2--Paths-and-Identifications.2-6--Univalence.html#19281" class="Bound">i</a> <a id="19283" class="Symbol">→</a> <a id="19285" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#1180" class="Function">subst</a> <a id="19291" href="2--Paths-and-Identifications.2-6--Univalence.html#18869" class="Function">double-cover</a> <a id="19304" class="Symbol">(</a><a id="19305" href="2--Paths-and-Identifications.2-6--Univalence.html#19263" class="Bound">p</a> <a id="19307" href="2--Paths-and-Identifications.2-6--Univalence.html#19281" class="Bound">i</a><a id="19308" class="Symbol">)</a> <a id="19310" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a><a id="19314" class="Symbol">)</a>

</pre>-->
<div class="info">
<p><span class="info-label">Aside:</span>
Without univalence or some other additional feature of type theory
beyond what we’ve seen so far, it is impossible to prove that <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a></code>
is nontrivial! With the bare constructions of type theory, it is
consistent to assume that <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a></code> is contractible.</p>
</div>
<p>There’s nothing special about <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> here. Rather than placing
two points over each point of the circle, we could put an entire copy
of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a></code>:</p>
<pre class="Agda"><a id="helix"></a><a id="19751" href="2--Paths-and-Identifications.2-6--Univalence.html#19751" class="Function">helix</a> <a id="19757" class="Symbol">:</a> <a id="19759" href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a> <a id="19762" class="Symbol">→</a> <a id="19764" href="Library.Primitive.html#422" class="Primitive">Type</a>
<a id="19769" href="2--Paths-and-Identifications.2-6--Univalence.html#19751" class="Function">helix</a> <a id="19775" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a> <a id="19780" class="Symbol">=</a> <a id="19782" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
<a id="19784" href="2--Paths-and-Identifications.2-6--Univalence.html#19751" class="Function">helix</a> <a id="19790" class="Symbol">(</a><a id="19791" href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a> <a id="19796" href="2--Paths-and-Identifications.2-6--Univalence.html#19796" class="Bound">i</a><a id="19797" class="Symbol">)</a> <a id="19799" class="Symbol">=</a> <a id="19801" href="2--Paths-and-Identifications.2-6--Univalence.html#15538" class="Function">sucℤ-≡</a> <a id="19808" href="2--Paths-and-Identifications.2-6--Univalence.html#19796" class="Bound">i</a>
</pre>
<p>In the remainder of this section we will prove a crucial fact about
<code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a></code>: that the type of paths from <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a></code> to itself is equivalent
to the integers. That is, the following function is an equivalence:</p>
<pre class="Agda"><a id="loopⁿ"></a><a id="20025" href="2--Paths-and-Identifications.2-6--Univalence.html#20025" class="Function">loopⁿ</a> <a id="20031" class="Symbol">:</a> <a id="20033" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="20035" class="Symbol">→</a> <a id="20037" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a> <a id="20042" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="20044" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a>
<a id="20049" href="2--Paths-and-Identifications.2-6--Univalence.html#20025" class="Function">loopⁿ</a> <a id="20055" class="Symbol">=</a> <a id="20057" href="2--Paths-and-Identifications.2-6--Univalence.html#16106" class="Function">iterateⁿ</a> <a id="20066" href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a>
</pre>
<p>This will be an encode-decode proof like those we did in Lecture 2-X,
with some slight differences which we will discuss when we encounter
them.</p>
<p>With the benefit of having done this before, we can tell you that the
following square is going to come in handy.</p>
<pre><code>                          p
                     ∙ — — — — &gt; ∙
                     ^           ^                      ^
iterateⁿ p (predℤ n) |           | iterateⁿ p n       j |
                     |           |                      ∙ — &gt;
                     ∙ — — — - &gt; ∙                        i
                         refl
</code></pre>
<p>It can be constructed pretty easily by induction on <code>n</code>.</p>
<pre class="Agda"><a id="iterateⁿ-predℤ-square"></a><a id="20759" href="2--Paths-and-Identifications.2-6--Univalence.html#20759" class="Function">iterateⁿ-predℤ-square</a> <a id="20781" class="Symbol">:</a> <a id="20783" class="Symbol">{</a><a id="20784" href="2--Paths-and-Identifications.2-6--Univalence.html#20784" class="Bound">x</a> <a id="20786" class="Symbol">:</a> <a id="20788" href="2--Paths-and-Identifications.2-6--Univalence.html#661" class="Generalizable">A</a><a id="20789" class="Symbol">}</a> <a id="20791" class="Symbol">→</a> <a id="20793" class="Symbol">(</a><a id="20794" href="2--Paths-and-Identifications.2-6--Univalence.html#20794" class="Bound">p</a> <a id="20796" class="Symbol">:</a> <a id="20798" href="2--Paths-and-Identifications.2-6--Univalence.html#20784" class="Bound">x</a> <a id="20800" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="20802" href="2--Paths-and-Identifications.2-6--Univalence.html#20784" class="Bound">x</a><a id="20803" class="Symbol">)</a> <a id="20805" class="Symbol">→</a> <a id="20807" class="Symbol">(</a><a id="20808" href="2--Paths-and-Identifications.2-6--Univalence.html#20808" class="Bound">n</a> <a id="20810" class="Symbol">:</a> <a id="20812" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a><a id="20813" class="Symbol">)</a> <a id="20815" class="Symbol">→</a> <a id="20817" href="2--Paths-and-Identifications.2-1--Paths.html#23426" class="Function">Square</a> <a id="20824" class="Symbol">(</a><a id="20825" href="2--Paths-and-Identifications.2-6--Univalence.html#16106" class="Function">iterateⁿ</a> <a id="20834" href="2--Paths-and-Identifications.2-6--Univalence.html#20794" class="Bound">p</a> <a id="20836" class="Symbol">(</a><a id="20837" href="1--Type-Theory.1-2--Inductive-Types.html#19642" class="Function">predℤ</a> <a id="20843" href="2--Paths-and-Identifications.2-6--Univalence.html#20808" class="Bound">n</a><a id="20844" class="Symbol">))</a> <a id="20847" class="Symbol">(</a><a id="20848" href="2--Paths-and-Identifications.2-6--Univalence.html#16106" class="Function">iterateⁿ</a> <a id="20857" href="2--Paths-and-Identifications.2-6--Univalence.html#20794" class="Bound">p</a> <a id="20859" href="2--Paths-and-Identifications.2-6--Univalence.html#20808" class="Bound">n</a><a id="20860" class="Symbol">)</a> <a id="20862" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a> <a id="20867" href="2--Paths-and-Identifications.2-6--Univalence.html#20794" class="Bound">p</a>
<a id="20869" class="Comment">-- Exercise: (Hint: `∙-filler`.)</a>
<a id="20902" class="Comment">-- iterateⁿ-predℤ-square p n i j = {!!}</a>
</pre><!--
<pre class="Agda"><a id="20955" href="2--Paths-and-Identifications.2-6--Univalence.html#20759" class="Function">iterateⁿ-predℤ-square</a> <a id="20977" href="2--Paths-and-Identifications.2-6--Univalence.html#20977" class="Bound">p</a> <a id="20979" class="Symbol">(</a><a id="20980" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="20984" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="20988" class="Symbol">)</a>    <a id="20993" href="2--Paths-and-Identifications.2-6--Univalence.html#20993" class="Bound">i</a> <a id="20995" href="2--Paths-and-Identifications.2-6--Univalence.html#20995" class="Bound">j</a> <a id="20997" class="Symbol">=</a> <a id="20999" href="2--Paths-and-Identifications.2-6--Univalence.html#20977" class="Bound">p</a> <a id="21001" class="Symbol">(</a><a id="21002" href="2--Paths-and-Identifications.2-6--Univalence.html#20993" class="Bound">i</a> <a id="21004" href="Library.Prelude.html#387" class="Primitive Operator">∨</a> <a id="21006" href="Library.Prelude.html#359" class="Primitive Operator">~</a> <a id="21008" href="2--Paths-and-Identifications.2-6--Univalence.html#20995" class="Bound">j</a><a id="21009" class="Symbol">)</a>
<a id="21011" href="2--Paths-and-Identifications.2-6--Univalence.html#20759" class="Function">iterateⁿ-predℤ-square</a> <a id="21033" href="2--Paths-and-Identifications.2-6--Univalence.html#21033" class="Bound">p</a> <a id="21035" class="Symbol">(</a><a id="21036" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="21040" class="Symbol">(</a><a id="21041" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="21045" href="2--Paths-and-Identifications.2-6--Univalence.html#21045" class="Bound">n</a><a id="21046" class="Symbol">))</a> <a id="21049" href="2--Paths-and-Identifications.2-6--Univalence.html#21049" class="Bound">i</a> <a id="21051" href="2--Paths-and-Identifications.2-6--Univalence.html#21051" class="Bound">j</a> <a id="21053" class="Symbol">=</a> <a id="21055" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#24542" class="Function">∙-filler</a> <a id="21064" class="Symbol">(</a><a id="21065" href="2--Paths-and-Identifications.2-6--Univalence.html#16106" class="Function">iterateⁿ</a> <a id="21074" href="2--Paths-and-Identifications.2-6--Univalence.html#21033" class="Bound">p</a> <a id="21076" class="Symbol">(</a><a id="21077" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="21081" href="2--Paths-and-Identifications.2-6--Univalence.html#21045" class="Bound">n</a><a id="21082" class="Symbol">))</a> <a id="21085" href="2--Paths-and-Identifications.2-6--Univalence.html#21033" class="Bound">p</a> <a id="21087" href="2--Paths-and-Identifications.2-6--Univalence.html#21049" class="Bound">i</a> <a id="21089" href="2--Paths-and-Identifications.2-6--Univalence.html#21051" class="Bound">j</a>
<a id="21091" href="2--Paths-and-Identifications.2-6--Univalence.html#20759" class="Function">iterateⁿ-predℤ-square</a> <a id="21113" href="2--Paths-and-Identifications.2-6--Univalence.html#21113" class="Bound">p</a> <a id="21115" class="Symbol">(</a><a id="21116" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="21123" href="2--Paths-and-Identifications.2-6--Univalence.html#21123" class="Bound">n</a><a id="21124" class="Symbol">)</a>    <a id="21129" href="2--Paths-and-Identifications.2-6--Univalence.html#21129" class="Bound">i</a> <a id="21131" href="2--Paths-and-Identifications.2-6--Univalence.html#21131" class="Bound">j</a> <a id="21133" class="Symbol">=</a> <a id="21135" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#24542" class="Function">∙-filler</a> <a id="21144" class="Symbol">(</a><a id="21145" href="2--Paths-and-Identifications.2-6--Univalence.html#16106" class="Function">iterateⁿ</a> <a id="21154" href="2--Paths-and-Identifications.2-6--Univalence.html#21113" class="Bound">p</a> <a id="21156" class="Symbol">(</a><a id="21157" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="21164" href="2--Paths-and-Identifications.2-6--Univalence.html#21123" class="Bound">n</a><a id="21165" class="Symbol">))</a> <a id="21168" class="Symbol">(</a><a id="21169" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#22904" class="Function">sym</a> <a id="21173" href="2--Paths-and-Identifications.2-6--Univalence.html#21113" class="Bound">p</a><a id="21174" class="Symbol">)</a> <a id="21176" class="Symbol">(</a><a id="21177" href="Library.Prelude.html#359" class="Primitive Operator">~</a> <a id="21179" href="2--Paths-and-Identifications.2-6--Univalence.html#21129" class="Bound">i</a><a id="21180" class="Symbol">)</a> <a id="21182" href="2--Paths-and-Identifications.2-6--Univalence.html#21131" class="Bound">j</a>

</pre>-->
<p>Now let’s jump straight into the proof.</p>
<pre class="Agda"><a id="ΩS¹≃ℤ"></a><a id="21247" href="2--Paths-and-Identifications.2-6--Univalence.html#21247" class="Function">ΩS¹≃ℤ</a> <a id="21253" class="Symbol">:</a> <a id="21255" class="Symbol">(</a><a id="21256" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a> <a id="21261" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="21263" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a><a id="21267" class="Symbol">)</a> <a id="21269" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5998" class="Function Operator">≃</a> <a id="21271" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
<a id="21273" href="2--Paths-and-Identifications.2-6--Univalence.html#21247" class="Function">ΩS¹≃ℤ</a> <a id="21279" class="Symbol">=</a> <a id="21281" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#7262" class="Function">inv→equiv</a> <a id="21291" class="Symbol">(</a><a id="21292" href="2--Paths-and-Identifications.2-6--Univalence.html#21993" class="Function">encode</a> <a id="21299" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a><a id="21303" class="Symbol">)</a> <a id="21305" class="Symbol">(</a><a id="21306" href="2--Paths-and-Identifications.2-6--Univalence.html#22147" class="Function">decode</a> <a id="21313" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a><a id="21317" class="Symbol">)</a> <a id="21319" href="2--Paths-and-Identifications.2-6--Univalence.html#27819" class="Function">fro-to</a> <a id="21326" href="2--Paths-and-Identifications.2-6--Univalence.html#27430" class="Function">to-fro</a>
  <a id="21335" class="Keyword">where</a>
</pre>
<div class="info">
<p><span class="info-label">Aside:</span>
In homotopy theory, the space of paths beginning and ending at a fixed
point of a space is called the <em>loop space</em> based at that point, and
is usually denoted using <code>Ω</code>.</p>
</div>
<p>First, the codes for the paths. Because we are ultimately only
interested in <code>base ≡ base</code>, we just give codes for paths of the form
<code>base ≡ x</code>. For this, we use exactly the <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#19751" class="Function">helix</a></code> type family defined
above.</p>
<pre class="Agda">    <a id="21752" href="2--Paths-and-Identifications.2-6--Univalence.html#21752" class="Function">code</a> <a id="21757" class="Symbol">:</a> <a id="21759" href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a> <a id="21762" class="Symbol">→</a> <a id="21764" href="Library.Primitive.html#422" class="Primitive">Type</a>
    <a id="21773" href="2--Paths-and-Identifications.2-6--Univalence.html#21752" class="Function">code</a> <a id="21778" class="Symbol">=</a> <a id="21780" href="2--Paths-and-Identifications.2-6--Univalence.html#19751" class="Function">helix</a>
</pre>
<p>Then <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#21939" class="Function">encodeRefl</a></code> and <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#21993" class="Function">encode</a></code> are defined as usual,
though <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#21939" class="Function">encodeRefl</a></code> is particularly simple because we only care
about <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a></code>.</p>
<pre class="Agda">    <a id="21939" href="2--Paths-and-Identifications.2-6--Univalence.html#21939" class="Function">encodeRefl</a> <a id="21950" class="Symbol">:</a> <a id="21952" href="2--Paths-and-Identifications.2-6--Univalence.html#21752" class="Function">code</a> <a id="21957" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a>
    <a id="21966" href="2--Paths-and-Identifications.2-6--Univalence.html#21939" class="Function">encodeRefl</a> <a id="21977" class="Symbol">=</a> <a id="21979" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="21983" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a>

    <a id="21993" href="2--Paths-and-Identifications.2-6--Univalence.html#21993" class="Function">encode</a> <a id="22000" class="Symbol">:</a> <a id="22002" class="Symbol">(</a><a id="22003" href="2--Paths-and-Identifications.2-6--Univalence.html#22003" class="Bound">x</a> <a id="22005" class="Symbol">:</a> <a id="22007" href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a><a id="22009" class="Symbol">)</a> <a id="22011" class="Symbol">→</a> <a id="22013" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a> <a id="22018" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="22020" href="2--Paths-and-Identifications.2-6--Univalence.html#22003" class="Bound">x</a> <a id="22022" class="Symbol">→</a> <a id="22024" href="2--Paths-and-Identifications.2-6--Univalence.html#21752" class="Function">code</a> <a id="22029" href="2--Paths-and-Identifications.2-6--Univalence.html#22003" class="Bound">x</a>
    <a id="22035" href="2--Paths-and-Identifications.2-6--Univalence.html#21993" class="Function">encode</a> <a id="22042" href="2--Paths-and-Identifications.2-6--Univalence.html#22042" class="Bound">x</a> <a id="22044" href="2--Paths-and-Identifications.2-6--Univalence.html#22044" class="Bound">p</a> <a id="22046" class="Symbol">=</a> <a id="22048" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#5310" class="Function">J</a> <a id="22050" class="Symbol">(λ</a> <a id="22053" href="2--Paths-and-Identifications.2-6--Univalence.html#22053" class="Bound">y</a> <a id="22055" href="2--Paths-and-Identifications.2-6--Univalence.html#22055" class="Bound">_</a> <a id="22057" class="Symbol">→</a> <a id="22059" href="2--Paths-and-Identifications.2-6--Univalence.html#21752" class="Function">code</a> <a id="22064" href="2--Paths-and-Identifications.2-6--Univalence.html#22053" class="Bound">y</a><a id="22065" class="Symbol">)</a> <a id="22067" href="2--Paths-and-Identifications.2-6--Univalence.html#21939" class="Function">encodeRefl</a> <a id="22078" href="2--Paths-and-Identifications.2-6--Univalence.html#22044" class="Bound">p</a>
</pre>
<p>Now for <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#22147" class="Function">decode</a></code>, which will take a lot more work.</p>
<pre class="Agda">    <a id="22147" href="2--Paths-and-Identifications.2-6--Univalence.html#22147" class="Function">decode</a> <a id="22154" class="Symbol">:</a> <a id="22156" class="Symbol">(</a><a id="22157" href="2--Paths-and-Identifications.2-6--Univalence.html#22157" class="Bound">x</a> <a id="22159" class="Symbol">:</a> <a id="22161" href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a><a id="22163" class="Symbol">)</a> <a id="22165" class="Symbol">→</a> <a id="22167" href="2--Paths-and-Identifications.2-6--Univalence.html#21752" class="Function">code</a> <a id="22172" href="2--Paths-and-Identifications.2-6--Univalence.html#22157" class="Bound">x</a> <a id="22174" class="Symbol">→</a> <a id="22176" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a> <a id="22181" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="22183" href="2--Paths-and-Identifications.2-6--Univalence.html#22157" class="Bound">x</a>
</pre>
<p>We now case-split on <code>x</code>, so we will need to give cases for
<code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a></code> and <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a></code>. The <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a></code> case is easy: we
have an element of <code>code base</code>, i.e. an integer, and we need to
produce a path <code>base ≡ base</code>. For this we have the function
<code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#20025" class="Function">loopⁿ</a></code> from earlier.</p>
<pre class="Agda">    <a id="22460" href="2--Paths-and-Identifications.2-6--Univalence.html#22147" class="Function">decode</a> <a id="22467" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a> <a id="22472" class="Symbol">=</a> <a id="22474" href="2--Paths-and-Identifications.2-6--Univalence.html#20025" class="Function">loopⁿ</a>
</pre>
<p>In the <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a></code> case, we will be asked to fill in the following
<code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#24507" class="Function">SquareP</a></code>, where <code>y : code (loop i)</code>, or recalling the definition,
<code>y : sucℤ-≡ i</code>: (In the following diagrams, all the vertices are
always <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a></code>.)</p>
<pre><code>            loop
        ∙ — — — — &gt; ∙
        ^           ^                   ^
loopⁿ y |           | loopⁿ y         j |
        |           |                   ∙ — &gt;
        ∙ — — — — &gt; ∙                     i
            refl
</code></pre>
<p>It might look odd to have <code>loopⁿ y j</code> on both sides: it seems it ought
to be impossible to fill this square, because we have <code>n</code> copies of
<code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a></code> going around one way and <code>n+1</code> copies going around the
other.</p>
<p>The reason is that the variable <code>y</code> has type <code>sucℤ-≡ i</code> rather than
being a a fixed integer: it varies along the type family <code>code (loop i)</code> as <code>i</code> goes from <code class="Agda"><a href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a></code> to <code class="Agda"><a href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a></code>. By the definition of <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#19751" class="Function">helix</a></code>,
<code>y</code> has type <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a></code> when <code>i</code> is <code class="Agda"><a href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a></code> or <code class="Agda"><a href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a></code>, but while moving
along the path between these, we have transported <code>n</code> to <code>suc n</code>. And
so the square should commute: going around either way should be <code>loopⁿ (suc n)</code>.</p>
<p>We can build this square as an <code class="Agda"><a href="Library.Prelude.html#650" class="Function">hcomp</a></code>. Here’s the cube we are
going to fill, with the desired square sitting on the top.</p>
<pre><code>                                  loop
                            ∙ — — — — — — — — &gt; ∙
                loopⁿ y   / ^                 / ^
                        /   |               / loopⁿ y
                      /     | refl        /     |
                    ∙ — — — — — — — — &gt; ∙       |
                    ^       |           ^       |              ^   j
                    |       |           |       |            k | /
                    |       |           |       |              ∙ — &gt;
                    |       |    loop   |       |                i
                    |       ∙ — — — — — | — — &gt; ∙
loopⁿ (predℤ (sucℤ y))    /             |     /
                    |   /               |   /  loopⁿ y
                    | /                 | /
                    ∙ — — — — — — — — &gt; ∙
                            refl
</code></pre>
<p>Again, we have to be careful — this is really a “Cube-over”, because
the type of <code>y</code> varies over the <code>i</code> direction.</p>
<pre class="Agda">    <a id="24752" href="2--Paths-and-Identifications.2-6--Univalence.html#22147" class="Function">decode</a> <a id="24759" class="Symbol">(</a><a id="24760" href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a> <a id="24765" href="2--Paths-and-Identifications.2-6--Univalence.html#24765" class="Bound">i</a><a id="24766" class="Symbol">)</a> <a id="24768" href="2--Paths-and-Identifications.2-6--Univalence.html#24768" class="Bound">y</a> <a id="24770" href="2--Paths-and-Identifications.2-6--Univalence.html#24770" class="Bound">j</a> <a id="24772" class="Symbol">=</a> <a id="24774" href="Library.Prelude.html#650" class="Function">hcomp</a> <a id="24780" class="Symbol">(</a><a id="24781" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#6469" class="Function">∂</a> <a id="24783" href="2--Paths-and-Identifications.2-6--Univalence.html#24765" class="Bound">i</a> <a id="24785" href="Library.Prelude.html#387" class="Primitive Operator">∨</a> <a id="24787" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#6469" class="Function">∂</a> <a id="24789" href="2--Paths-and-Identifications.2-6--Univalence.html#24770" class="Bound">j</a><a id="24790" class="Symbol">)</a> <a id="24792" class="Symbol">(</a><a id="24793" href="2--Paths-and-Identifications.2-6--Univalence.html#24936" class="Function">decode-faces</a> <a id="24806" href="2--Paths-and-Identifications.2-6--Univalence.html#24765" class="Bound">i</a> <a id="24808" href="2--Paths-and-Identifications.2-6--Univalence.html#24768" class="Bound">y</a> <a id="24810" href="2--Paths-and-Identifications.2-6--Univalence.html#24770" class="Bound">j</a><a id="24811" class="Symbol">)</a>
      <a id="24819" class="Keyword">where</a>
</pre>
<p>Three of the sides are easy, they are just squares that are constant
in one of the directions.</p>
<pre class="Agda">      <a id="24936" href="2--Paths-and-Identifications.2-6--Univalence.html#24936" class="Function">decode-faces</a> <a id="24949" class="Symbol">:</a> <a id="24951" class="Symbol">(</a><a id="24952" href="2--Paths-and-Identifications.2-6--Univalence.html#24952" class="Bound">i</a> <a id="24954" class="Symbol">:</a> <a id="24956" href="Library.Primitive.html#1675" class="Datatype">I</a><a id="24957" class="Symbol">)</a> <a id="24959" class="Symbol">→</a> <a id="24961" class="Symbol">(</a><a id="24962" href="2--Paths-and-Identifications.2-6--Univalence.html#24962" class="Bound">y</a> <a id="24964" class="Symbol">:</a> <a id="24966" href="2--Paths-and-Identifications.2-6--Univalence.html#15538" class="Function">sucℤ-≡</a> <a id="24973" href="2--Paths-and-Identifications.2-6--Univalence.html#24952" class="Bound">i</a><a id="24974" class="Symbol">)</a> <a id="24976" class="Symbol">→</a> <a id="24978" class="Symbol">(</a><a id="24979" href="2--Paths-and-Identifications.2-6--Univalence.html#24979" class="Bound">j</a> <a id="24981" href="2--Paths-and-Identifications.2-6--Univalence.html#24981" class="Bound">k</a> <a id="24983" class="Symbol">:</a> <a id="24985" href="Library.Primitive.html#1675" class="Datatype">I</a><a id="24986" class="Symbol">)</a> <a id="24988" class="Symbol">→</a> <a id="24990" href="Library.Primitive.html#3205" class="Primitive">Partial</a> <a id="24998" class="Symbol">(</a><a id="24999" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#6469" class="Function">∂</a> <a id="25001" href="2--Paths-and-Identifications.2-6--Univalence.html#24952" class="Bound">i</a> <a id="25003" href="Library.Prelude.html#387" class="Primitive Operator">∨</a> <a id="25005" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#6469" class="Function">∂</a> <a id="25007" href="2--Paths-and-Identifications.2-6--Univalence.html#24979" class="Bound">j</a> <a id="25009" href="Library.Prelude.html#387" class="Primitive Operator">∨</a> <a id="25011" href="Library.Prelude.html#359" class="Primitive Operator">~</a> <a id="25013" href="2--Paths-and-Identifications.2-6--Univalence.html#24981" class="Bound">k</a><a id="25014" class="Symbol">)</a> <a id="25016" href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a>
      <a id="25025" class="Comment">-- Exercise:</a>
      <a id="25044" href="2--Paths-and-Identifications.2-6--Univalence.html#24936" class="Function">decode-faces</a> <a id="25057" href="2--Paths-and-Identifications.2-6--Univalence.html#25057" class="Bound">i</a> <a id="25059" href="2--Paths-and-Identifications.2-6--Univalence.html#25059" class="Bound">y</a> <a id="25061" href="2--Paths-and-Identifications.2-6--Univalence.html#25061" class="Bound">j</a> <a id="25063" href="2--Paths-and-Identifications.2-6--Univalence.html#25063" class="Bound">k</a> <a id="25065" class="Symbol">(</a><a id="25066" href="2--Paths-and-Identifications.2-6--Univalence.html#25057" class="Bound">i</a> <a id="25068" class="Symbol">=</a> <a id="25070" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="25072" class="Symbol">)</a> <a id="25074" class="Symbol">=</a> <a id="25076" href="2--Paths-and-Identifications.2-6--Univalence.html#20025" class="Function">loopⁿ</a> <a id="25082" href="2--Paths-and-Identifications.2-6--Univalence.html#25059" class="Bound">y</a> <a id="25084" href="2--Paths-and-Identifications.2-6--Univalence.html#25061" class="Bound">j</a>
</pre><!--
<pre class="Agda">      <a id="25105" href="2--Paths-and-Identifications.2-6--Univalence.html#24936" class="Function">decode-faces</a> <a id="25118" href="2--Paths-and-Identifications.2-6--Univalence.html#25118" class="Bound">i</a> <a id="25120" href="2--Paths-and-Identifications.2-6--Univalence.html#25120" class="Bound">y</a> <a id="25122" href="2--Paths-and-Identifications.2-6--Univalence.html#25122" class="Bound">j</a> <a id="25124" href="2--Paths-and-Identifications.2-6--Univalence.html#25124" class="Bound">k</a> <a id="25126" class="Symbol">(</a><a id="25127" href="2--Paths-and-Identifications.2-6--Univalence.html#25122" class="Bound">j</a> <a id="25129" class="Symbol">=</a> <a id="25131" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="25133" class="Symbol">)</a> <a id="25135" class="Symbol">=</a> <a id="25137" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a>
      <a id="25148" href="2--Paths-and-Identifications.2-6--Univalence.html#24936" class="Function">decode-faces</a> <a id="25161" href="2--Paths-and-Identifications.2-6--Univalence.html#25161" class="Bound">i</a> <a id="25163" href="2--Paths-and-Identifications.2-6--Univalence.html#25163" class="Bound">y</a> <a id="25165" href="2--Paths-and-Identifications.2-6--Univalence.html#25165" class="Bound">j</a> <a id="25167" href="2--Paths-and-Identifications.2-6--Univalence.html#25167" class="Bound">k</a> <a id="25169" class="Symbol">(</a><a id="25170" href="2--Paths-and-Identifications.2-6--Univalence.html#25165" class="Bound">j</a> <a id="25172" class="Symbol">=</a> <a id="25174" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="25176" class="Symbol">)</a> <a id="25178" class="Symbol">=</a> <a id="25180" href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a> <a id="25185" href="2--Paths-and-Identifications.2-6--Univalence.html#25161" class="Bound">i</a>

</pre>-->
<p>The <code>(i = i0)</code> face is slightly more interesting, here it is written
flat:</p>
<pre><code>            loopⁿ y
        ∙ — — — — — &gt; ∙
        ^             ^                  ^
   refl |             | refl           k |
        |             |                  ∙ — &gt;
        ∙ — — — — — &gt; ∙                    j
     loopⁿ (predℤ (sucℤ y))
</code></pre>
<p>A path <code>predℤ (sucℤ y) ≡ y</code> is provided by the retract part of the
equivalence <code class="Agda"><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#21340" class="Function">sucℤ-≃</a></code>, so we can use that rather than reconstructing
the path. It just has to be surround with <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#20025" class="Function">loopⁿ</a></code>.</p>
<pre class="Agda">      <a id="25761" class="Comment">-- Exercise:</a>
      <a id="25780" class="Comment">-- decode-faces i y j k (i = i0) = {!!}</a>
</pre><!--
<pre class="Agda">      <a id="25839" href="2--Paths-and-Identifications.2-6--Univalence.html#24936" class="Function">decode-faces</a> <a id="25852" href="2--Paths-and-Identifications.2-6--Univalence.html#25852" class="Bound">i</a> <a id="25854" href="2--Paths-and-Identifications.2-6--Univalence.html#25854" class="Bound">y</a> <a id="25856" href="2--Paths-and-Identifications.2-6--Univalence.html#25856" class="Bound">j</a> <a id="25858" href="2--Paths-and-Identifications.2-6--Univalence.html#25858" class="Bound">k</a> <a id="25860" class="Symbol">(</a><a id="25861" href="2--Paths-and-Identifications.2-6--Univalence.html#25852" class="Bound">i</a> <a id="25863" class="Symbol">=</a> <a id="25865" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="25867" class="Symbol">)</a> <a id="25869" class="Symbol">=</a> <a id="25871" href="2--Paths-and-Identifications.2-6--Univalence.html#20025" class="Function">loopⁿ</a> <a id="25877" class="Symbol">(</a><a id="25878" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#21340" class="Function">sucℤ-≃</a> <a id="25885" class="Symbol">.</a><a id="25886" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5826" class="Field">proof</a> <a id="25892" class="Symbol">.</a><a id="25893" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5668" class="Field">retract</a> <a id="25901" class="Symbol">.</a><a id="25902" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#4241" class="Field">proof</a> <a id="25908" href="2--Paths-and-Identifications.2-6--Univalence.html#25854" class="Bound">y</a> <a id="25910" href="2--Paths-and-Identifications.2-6--Univalence.html#25858" class="Bound">k</a><a id="25911" class="Symbol">)</a> <a id="25913" href="2--Paths-and-Identifications.2-6--Univalence.html#25856" class="Bound">j</a>

</pre>-->
<p>All that remains is to construct the base square and for this we have
to get our hands a little dirty. Written flat, this is the <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#24507" class="Function">SquareP</a></code></p>
<pre><code>                           loop
                       ∙ — — — — &gt; ∙
                       ^           ^                 ^
loopⁿ (predℤ (sucℤ y)) |           | loopⁿ y       j |
                       |           |                 ∙ — &gt;
                       ∙ — — — - &gt; ∙                   i
                           refl
</code></pre>
<p>This is really close to the <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#20759" class="Function">iterateⁿ-predℤ-square</a></code> that we defined in
advance, which looks like this:</p>
<pre><code>                           loop
                       ∙ — — — — &gt; ∙
                       ^           ^                 ^
       loopⁿ (predℤ n) |           | loopⁿ n       j |
                       |           |                 ∙ — &gt;
                       ∙ — — — - &gt; ∙                   i
                           refl
</code></pre>
<p>To make these match, we need to supply an <code>n</code> that is equal to <code>sucℤ y</code> on the left side and <code>y</code> on the right. This is exactly what
<code class="Agda"><a href="Library.Univalence.html#7366" class="Function">unglue</a></code>-ing <code>y</code> gives us: on the left side we apply the equivalence
<code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#19415" class="Function">sucℤ</a></code>, and on the right side, the identity equivalence.</p>
<pre class="Agda">      <a id="27166" href="2--Paths-and-Identifications.2-6--Univalence.html#24936" class="Function">decode-faces</a> <a id="27179" href="2--Paths-and-Identifications.2-6--Univalence.html#27179" class="Bound">i</a> <a id="27181" href="2--Paths-and-Identifications.2-6--Univalence.html#27181" class="Bound">y</a> <a id="27183" href="2--Paths-and-Identifications.2-6--Univalence.html#27183" class="Bound">j</a> <a id="27185" href="2--Paths-and-Identifications.2-6--Univalence.html#27185" class="Bound">k</a> <a id="27187" class="Symbol">(</a><a id="27188" href="2--Paths-and-Identifications.2-6--Univalence.html#27185" class="Bound">k</a> <a id="27190" class="Symbol">=</a> <a id="27192" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="27194" class="Symbol">)</a> <a id="27196" class="Symbol">=</a> <a id="27198" href="2--Paths-and-Identifications.2-6--Univalence.html#20759" class="Function">iterateⁿ-predℤ-square</a> <a id="27220" href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a> <a id="27225" class="Symbol">(</a><a id="27226" href="2--Paths-and-Identifications.2-6--Univalence.html#6983" class="Function">ua-unglue</a> <a id="27236" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#21340" class="Function">sucℤ-≃</a> <a id="27243" href="2--Paths-and-Identifications.2-6--Univalence.html#27179" class="Bound">i</a> <a id="27245" href="2--Paths-and-Identifications.2-6--Univalence.html#27181" class="Bound">y</a><a id="27246" class="Symbol">)</a> <a id="27248" href="2--Paths-and-Identifications.2-6--Univalence.html#27179" class="Bound">i</a> <a id="27250" href="2--Paths-and-Identifications.2-6--Univalence.html#27183" class="Bound">j</a>
</pre>
<p>Checking that one composite is equal to the identity is easy using
<code class="Agda"><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#5310" class="Function">J</a></code> as usual, because everything computes away to nothing when
the input path <code>p</code> is <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a></code>:</p>
<pre class="Agda">    <a id="27430" href="2--Paths-and-Identifications.2-6--Univalence.html#27430" class="Function">to-fro</a> <a id="27437" class="Symbol">:</a> <a id="27439" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#1688" class="Function">isSection</a> <a id="27449" class="Symbol">(</a><a id="27450" href="2--Paths-and-Identifications.2-6--Univalence.html#22147" class="Function">decode</a> <a id="27457" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a><a id="27461" class="Symbol">)</a> <a id="27463" class="Symbol">(</a><a id="27464" href="2--Paths-and-Identifications.2-6--Univalence.html#21993" class="Function">encode</a> <a id="27471" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a><a id="27475" class="Symbol">)</a>
    <a id="27481" class="Comment">-- Exercise:</a>
    <a id="27498" class="Comment">-- to-fro p = J {!!} {!!} {!!}</a>
</pre><!--
<pre class="Agda">    <a id="27546" href="2--Paths-and-Identifications.2-6--Univalence.html#27430" class="Function">to-fro</a> <a id="27553" href="2--Paths-and-Identifications.2-6--Univalence.html#27553" class="Bound">p</a> <a id="27555" class="Symbol">=</a> <a id="27557" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html#5310" class="Function">J</a> <a id="27559" class="Symbol">(λ</a> <a id="27562" href="2--Paths-and-Identifications.2-6--Univalence.html#27562" class="Bound">y</a> <a id="27564" href="2--Paths-and-Identifications.2-6--Univalence.html#27564" class="Bound">q</a> <a id="27566" class="Symbol">→</a> <a id="27568" href="2--Paths-and-Identifications.2-6--Univalence.html#22147" class="Function">decode</a> <a id="27575" href="2--Paths-and-Identifications.2-6--Univalence.html#27562" class="Bound">y</a> <a id="27577" class="Symbol">(</a><a id="27578" href="2--Paths-and-Identifications.2-6--Univalence.html#21993" class="Function">encode</a> <a id="27585" href="2--Paths-and-Identifications.2-6--Univalence.html#27562" class="Bound">y</a> <a id="27587" href="2--Paths-and-Identifications.2-6--Univalence.html#27564" class="Bound">q</a><a id="27588" class="Symbol">)</a> <a id="27590" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="27592" href="2--Paths-and-Identifications.2-6--Univalence.html#27564" class="Bound">q</a><a id="27593" class="Symbol">)</a> <a id="27595" class="Symbol">(λ</a> <a id="27598" href="2--Paths-and-Identifications.2-6--Univalence.html#27598" class="Bound">_</a> <a id="27600" class="Symbol">→</a> <a id="27602" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a><a id="27606" class="Symbol">)</a> <a id="27608" href="2--Paths-and-Identifications.2-6--Univalence.html#27553" class="Bound">p</a>

</pre>-->
<p>And the other way can be verified by induction on <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a></code>.
(Remember that <code>decode base</code> is exactly <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#20025" class="Function">loopⁿ</a></code> by definition, so
we don’t have to worry about the complicated <code class="Agda"><a href="Library.Prelude.html#650" class="Function">hcomp</a></code>.)</p>
<pre class="Agda">    <a id="27819" href="2--Paths-and-Identifications.2-6--Univalence.html#27819" class="Function">fro-to</a> <a id="27826" class="Symbol">:</a> <a id="27828" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#3991" class="Function">isRetract</a> <a id="27838" class="Symbol">(</a><a id="27839" href="2--Paths-and-Identifications.2-6--Univalence.html#22147" class="Function">decode</a> <a id="27846" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a><a id="27850" class="Symbol">)</a> <a id="27852" class="Symbol">(</a><a id="27853" href="2--Paths-and-Identifications.2-6--Univalence.html#21993" class="Function">encode</a> <a id="27860" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a><a id="27864" class="Symbol">)</a>
    <a id="27870" class="Comment">-- Exercise:</a>
    <a id="27887" class="Comment">-- fro-to n = {!!}</a>
</pre><!--
<pre class="Agda">    <a id="27923" href="2--Paths-and-Identifications.2-6--Univalence.html#27819" class="Function">fro-to</a> <a id="27930" class="Symbol">(</a><a id="27931" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="27935" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="27939" class="Symbol">)</a> <a id="27941" class="Symbol">=</a> <a id="27943" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a>
    <a id="27952" href="2--Paths-and-Identifications.2-6--Univalence.html#27819" class="Function">fro-to</a> <a id="27959" class="Symbol">(</a><a id="27960" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="27964" class="Symbol">(</a><a id="27965" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="27969" href="2--Paths-and-Identifications.2-6--Univalence.html#27969" class="Bound">n</a><a id="27970" class="Symbol">))</a> <a id="27973" class="Symbol">=</a> <a id="27975" href="2--Paths-and-Identifications.2-1--Paths.html#17114" class="Function">ap</a> <a id="27978" href="1--Type-Theory.1-2--Inductive-Types.html#19415" class="Function">sucℤ</a> <a id="27983" class="Symbol">(</a><a id="27984" href="2--Paths-and-Identifications.2-6--Univalence.html#27819" class="Function">fro-to</a> <a id="27991" class="Symbol">(</a><a id="27992" href="1--Type-Theory.1-2--Inductive-Types.html#18351" class="InductiveConstructor">pos</a> <a id="27996" href="2--Paths-and-Identifications.2-6--Univalence.html#27969" class="Bound">n</a><a id="27997" class="Symbol">))</a>
    <a id="28004" href="2--Paths-and-Identifications.2-6--Univalence.html#27819" class="Function">fro-to</a> <a id="28011" class="Symbol">(</a><a id="28012" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="28019" href="Library.Prelude.html#3646" class="InductiveConstructor">zero</a><a id="28023" class="Symbol">)</a> <a id="28025" class="Symbol">=</a> <a id="28027" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a>
    <a id="28036" href="2--Paths-and-Identifications.2-6--Univalence.html#27819" class="Function">fro-to</a> <a id="28043" class="Symbol">(</a><a id="28044" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="28051" class="Symbol">(</a><a id="28052" href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a> <a id="28056" href="2--Paths-and-Identifications.2-6--Univalence.html#28056" class="Bound">n</a><a id="28057" class="Symbol">))</a> <a id="28060" class="Symbol">=</a> <a id="28062" href="2--Paths-and-Identifications.2-1--Paths.html#17114" class="Function">ap</a> <a id="28065" href="1--Type-Theory.1-2--Inductive-Types.html#19642" class="Function">predℤ</a> <a id="28071" class="Symbol">(</a><a id="28072" href="2--Paths-and-Identifications.2-6--Univalence.html#27819" class="Function">fro-to</a> <a id="28079" class="Symbol">(</a><a id="28080" href="1--Type-Theory.1-2--Inductive-Types.html#18368" class="InductiveConstructor">negsuc</a> <a id="28087" href="2--Paths-and-Identifications.2-6--Univalence.html#28056" class="Bound">n</a><a id="28088" class="Symbol">))</a>

</pre>-->
<p>And we’re done!</p>
<h2 id="addition-yet-again"><a class="header" href="#addition-yet-again">Addition Yet Again</a></h2>
<p>As a final demonstration in of univalence in this Lecture, let’s use
the <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#21247" class="Function">ΩS¹≃ℤ</a></code> equivalence to define addition of integers yet another
time. We now know that <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a></code> is equivalent to <code>base ≡ base</code> so we can
do this by finding a binary operation on <code>S¹</code> corresponding to
addition.</p>
<p>Geometrically, this operation is easy to describe. For any two points
on the circle, look at their angles from the basepoint and add those
angles together. (Or phrased another way, consider <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a></code> as the unit
circle in the complex plane, use multiplication of complex numbers.)</p>
<p>How do we describe this in type theory? If we fix one angle and let
the other one run from 0 to 360, the result runs around the circle
starting at the fixed angle. If we fix one of the points at <code>y</code> and
let the other run around <code>loop : base ≡ base</code>, we should get a path <code>y ≡ y</code> that also runs around <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a></code>. (Similar to <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a></code> itself, but
starting and ending at some point other than <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a></code>.)</p>
<pre class="Agda"><a id="rotate-loop"></a><a id="29114" href="2--Paths-and-Identifications.2-6--Univalence.html#29114" class="Function">rotate-loop</a> <a id="29126" class="Symbol">:</a> <a id="29128" class="Symbol">(</a><a id="29129" href="2--Paths-and-Identifications.2-6--Univalence.html#29129" class="Bound">y</a> <a id="29131" class="Symbol">:</a> <a id="29133" href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a><a id="29135" class="Symbol">)</a> <a id="29137" class="Symbol">→</a> <a id="29139" href="2--Paths-and-Identifications.2-6--Univalence.html#29129" class="Bound">y</a> <a id="29141" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="29143" href="2--Paths-and-Identifications.2-6--Univalence.html#29129" class="Bound">y</a>
<a id="29145" class="Comment">-- Exercise: (Hint: We built the necessary square in Lecture 2-X!)</a>
<a id="29212" class="Comment">-- rotate-loop base       = loop</a>
<a id="29245" class="Comment">-- rotate-loop (loop i) j = {!!}</a>
</pre><!--
<pre class="Agda"><a id="29291" href="2--Paths-and-Identifications.2-6--Univalence.html#29114" class="Function">rotate-loop</a> <a id="29303" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a>       <a id="29314" class="Symbol">=</a> <a id="29316" href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a>
<a id="29321" href="2--Paths-and-Identifications.2-6--Univalence.html#29114" class="Function">rotate-loop</a> <a id="29333" class="Symbol">(</a><a id="29334" href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a> <a id="29339" href="2--Paths-and-Identifications.2-6--Univalence.html#29339" class="Bound">i</a><a id="29340" class="Symbol">)</a> <a id="29342" href="2--Paths-and-Identifications.2-6--Univalence.html#29342" class="Bound">j</a> <a id="29344" class="Symbol">=</a> <a id="29346" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html#16991" class="Function">diamond</a> <a id="29354" href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a> <a id="29359" href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a> <a id="29364" href="2--Paths-and-Identifications.2-6--Univalence.html#29339" class="Bound">i</a> <a id="29366" href="2--Paths-and-Identifications.2-6--Univalence.html#29342" class="Bound">j</a>

</pre>-->
<p>Now the actual multiplication. The point <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a></code> of <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a></code> lies at
angle 0, so it should not move the other point at all. And in the
<code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a></code> case, the above operation <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#29114" class="Function">rotate-loop</a></code> is exactly what we
need.</p>
<pre class="Agda"><a id="_·S¹_"></a><a id="29601" href="2--Paths-and-Identifications.2-6--Univalence.html#29601" class="Function Operator">_·S¹_</a> <a id="29607" class="Symbol">:</a> <a id="29609" href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a> <a id="29612" class="Symbol">→</a> <a id="29614" href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a> <a id="29617" class="Symbol">→</a> <a id="29619" href="2--Paths-and-Identifications.2-1--Paths.html#12556" class="Datatype">S¹</a>
<a id="29622" class="Comment">-- Exercise:</a>
<a id="29635" class="Comment">-- base   ·S¹ y = {!!}</a>
<a id="29658" class="Comment">-- loop i ·S¹ y = {!!}</a>
</pre><!--
<pre class="Agda"><a id="29694" href="2--Paths-and-Identifications.2-1--Paths.html#12574" class="InductiveConstructor">base</a>   <a id="29701" href="2--Paths-and-Identifications.2-6--Univalence.html#29601" class="Function Operator">·S¹</a> <a id="29705" href="2--Paths-and-Identifications.2-6--Univalence.html#29705" class="Bound">y</a> <a id="29707" class="Symbol">=</a> <a id="29709" href="2--Paths-and-Identifications.2-6--Univalence.html#29705" class="Bound">y</a>
<a id="29711" href="2--Paths-and-Identifications.2-1--Paths.html#12586" class="InductiveConstructor">loop</a> <a id="29716" href="2--Paths-and-Identifications.2-6--Univalence.html#29716" class="Bound">i</a> <a id="29718" href="2--Paths-and-Identifications.2-6--Univalence.html#29601" class="Function Operator">·S¹</a> <a id="29722" href="2--Paths-and-Identifications.2-6--Univalence.html#29722" class="Bound">y</a> <a id="29724" class="Symbol">=</a> <a id="29726" href="2--Paths-and-Identifications.2-6--Univalence.html#29114" class="Function">rotate-loop</a> <a id="29738" href="2--Paths-and-Identifications.2-6--Univalence.html#29722" class="Bound">y</a> <a id="29740" href="2--Paths-and-Identifications.2-6--Univalence.html#29716" class="Bound">i</a>

</pre>-->
<pre class="Agda">
<a id="29756" class="Keyword">infixl</a> <a id="29763" class="Number">30</a> <a id="29766" href="2--Paths-and-Identifications.2-6--Univalence.html#29601" class="Function Operator">_·S¹_</a>
</pre>
<p>Now combine this multiplication with the <code class="Agda"><a href="2--Paths-and-Identifications.2-6--Univalence.html#21247" class="Function">ΩS¹≃ℤ</a></code> equivalence:
turn <code>x</code> and <code>y</code> into loops, multiply them, and turn the resulting
loop back into an element of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a></code>.</p>
<pre class="Agda"><a id="_+ℤᵐ_"></a><a id="29949" href="2--Paths-and-Identifications.2-6--Univalence.html#29949" class="Function Operator">_+ℤᵐ_</a> <a id="29955" class="Symbol">:</a> <a id="29957" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="29959" class="Symbol">→</a> <a id="29961" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a> <a id="29963" class="Symbol">→</a> <a id="29965" href="1--Type-Theory.1-2--Inductive-Types.html#18334" class="Datatype">ℤ</a>
<a id="29967" class="Comment">-- Exercise:</a>
<a id="29980" class="Comment">-- x +ℤᵐ y = equivFun ΩS¹≃ℤ {!!}</a>
</pre><!--
<pre class="Agda"><a id="30026" href="2--Paths-and-Identifications.2-6--Univalence.html#30026" class="Bound">x</a> <a id="30028" href="2--Paths-and-Identifications.2-6--Univalence.html#29949" class="Function Operator">+ℤᵐ</a> <a id="30032" href="2--Paths-and-Identifications.2-6--Univalence.html#30032" class="Bound">y</a> <a id="30034" class="Symbol">=</a> <a id="30036" href="2--Paths-and-Identifications.2-6--Univalence.html#21247" class="Function">ΩS¹≃ℤ</a> <a id="30042" class="Symbol">.</a><a id="30043" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5810" class="Field">map</a> <a id="30047" class="Symbol">(λ</a> <a id="30050" href="2--Paths-and-Identifications.2-6--Univalence.html#30050" class="Bound">i</a> <a id="30052" class="Symbol">→</a> <a id="30054" class="Symbol">(</a><a id="30055" href="2--Paths-and-Identifications.2-6--Univalence.html#21247" class="Function">ΩS¹≃ℤ</a> <a id="30061" class="Symbol">.</a><a id="30062" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5826" class="Field">proof</a> <a id="30068" class="Symbol">.</a><a id="30069" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5642" class="Field">section</a> <a id="30077" class="Symbol">.</a><a id="30078" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#2554" class="Field">map</a> <a id="30082" href="2--Paths-and-Identifications.2-6--Univalence.html#30026" class="Bound">x</a> <a id="30084" href="2--Paths-and-Identifications.2-6--Univalence.html#30050" class="Bound">i</a><a id="30085" class="Symbol">)</a> <a id="30087" href="2--Paths-and-Identifications.2-6--Univalence.html#29601" class="Function Operator">·S¹</a> <a id="30091" class="Symbol">(</a><a id="30092" href="2--Paths-and-Identifications.2-6--Univalence.html#21247" class="Function">ΩS¹≃ℤ</a> <a id="30098" class="Symbol">.</a><a id="30099" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5826" class="Field">proof</a> <a id="30105" class="Symbol">.</a><a id="30106" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5642" class="Field">section</a> <a id="30114" class="Symbol">.</a><a id="30115" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#2554" class="Field">map</a> <a id="30119" href="2--Paths-and-Identifications.2-6--Univalence.html#30032" class="Bound">y</a> <a id="30121" href="2--Paths-and-Identifications.2-6--Univalence.html#30050" class="Bound">i</a><a id="30122" class="Symbol">))</a>

</pre>-->
<pre class="Agda">
<a id="30139" href="2--Paths-and-Identifications.2-6--Univalence.html#30139" class="Function">_</a> <a id="30141" class="Symbol">=</a> <a id="30143" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="30158" class="Symbol">(</a><a id="30159" class="Number">0</a> <a id="30161" href="2--Paths-and-Identifications.2-6--Univalence.html#29949" class="Function Operator">+ℤᵐ</a> <a id="30165" class="Number">0</a><a id="30166" class="Symbol">)</a> <a id="30168" class="Number">0</a>
<a id="30170" href="2--Paths-and-Identifications.2-6--Univalence.html#30170" class="Function">_</a> <a id="30172" class="Symbol">=</a> <a id="30174" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="30189" class="Symbol">(</a><a id="30190" class="Number">0</a> <a id="30192" href="2--Paths-and-Identifications.2-6--Univalence.html#29949" class="Function Operator">+ℤᵐ</a> <a id="30196" class="Number">1</a><a id="30197" class="Symbol">)</a> <a id="30199" class="Number">1</a>
<a id="30201" href="2--Paths-and-Identifications.2-6--Univalence.html#30201" class="Function">_</a> <a id="30203" class="Symbol">=</a> <a id="30205" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="30220" class="Symbol">(</a><a id="30221" class="Number">1</a> <a id="30223" href="2--Paths-and-Identifications.2-6--Univalence.html#29949" class="Function Operator">+ℤᵐ</a> <a id="30227" class="Number">0</a><a id="30228" class="Symbol">)</a> <a id="30230" class="Number">1</a>
<a id="30232" href="2--Paths-and-Identifications.2-6--Univalence.html#30232" class="Function">_</a> <a id="30234" class="Symbol">=</a> <a id="30236" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="30251" class="Symbol">(</a><a id="30252" class="Number">19</a> <a id="30255" href="2--Paths-and-Identifications.2-6--Univalence.html#29949" class="Function Operator">+ℤᵐ</a> <a id="30259" class="Number">34</a><a id="30261" class="Symbol">)</a> <a id="30263" class="Number">53</a>
<a id="30266" href="2--Paths-and-Identifications.2-6--Univalence.html#30266" class="Function">_</a> <a id="30268" class="Symbol">=</a> <a id="30270" href="Library.Prelude.html#2894" class="InductiveConstructor">test-identical</a> <a id="30285" class="Symbol">(</a><a id="30286" class="Number">-19</a> <a id="30290" href="2--Paths-and-Identifications.2-6--Univalence.html#29949" class="Function Operator">+ℤᵐ</a> <a id="30294" class="Number">34</a><a id="30296" class="Symbol">)</a> <a id="30298" class="Number">15</a>
</pre>
<h2 id="references-and-further-reading"><a class="header" href="#references-and-further-reading">References and Further Reading</a></h2>
<p>mvrnote: original proof for  S^1
proof of S^1 in other libraries</p>
<ul>
<li>https://arxiv.org/abs/1611.02108
Cubical Type Theory: a constructive interpretation of the univalence axiom
Cyril Cohen, Thierry Coquand, Simon Huber, Anders Mörtberg</li>
</ul>

                  </main>
                  <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                  </div>
                </div>
            </div>
        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>


    </div>
    </body>
</html>
