<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2.7: Propositions - Introduction to Homotopy Type Theory in Cubical Agda</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/Agda.css">
        <link rel="stylesheet" href="theme/css/Agda-highlight.css">
        <link rel="stylesheet" href="theme/pagetoc.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="chapter-item affix "><a href="INSTALLING_AGDA.html">Installing Agda</a></li><li class="chapter-item affix "><a href="USING_AGDA.html">Using Agda</a></li><li class="chapter-item affix "><li class="part-title">Type Theory</li><li class="chapter-item "><a href="1--Type-Theory.1-1--Types-and-Functions.html">1.1: Types and Functions</a></li><li class="chapter-item "><a href="1--Type-Theory.1-2--Inductive-Types.html">1.2: Inductive Types</a></li><li class="chapter-item "><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html">1.3: Universes and More Inductive Types</a></li><li class="chapter-item "><a href="1--Type-Theory.1-4--Record-Types-and-Copatterns.html">1.4: Record Types and Copatterns</a></li><li class="chapter-item "><a href="1--Type-Theory.1-5--Propositions-as-Types.html">1.5: Propositions as Types</a></li><li class="chapter-item affix "><li class="part-title">Paths and Identifications</li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-1--Paths.html">2.1: Paths</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html">2.2: Equivalences and Path Algebra</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-3--Substitution-and-J.html">2.3: Substitution and J</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html">2.4: Composition and Filling</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-5--Transport.html">2.5: Transport</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-6--Univalence.html">2.6: Univalence</a></li><li class="chapter-item expanded "><a href="2--Paths-and-Identifications.2-7--Propositions.html" class="active">2.7: Propositions</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-8--Sets-and-Higher-Types.html">2.8: Sets and Higher Types</a></li><li class="chapter-item "><a href="2--Paths-and-Identifications.2-9--Contractible-Maps.html">2.9: Contractible Maps</a></li><li class="chapter-item affix "><li class="part-title">Topics</li><li class="chapter-item "><a href="3--Topics.3-1--Structure-Identity-Principle.html">3.1: The Structure Identity Principle</a></li><li class="chapter-item "><a href="3--Topics.3-2--Modalities.html">3.2: Modalities</a></li><li class="chapter-item "><a href="3--Topics.3-3--Constructive-Logic.html">3.3: Constructive Logic</a></li><li class="chapter-item affix "><li class="part-title">Behind-the-Scenes</li><li class="chapter-item "><a href="Library.Primitive.html">Primitives</a></li><li class="chapter-item "><a href="Library.Prelude.html">Prelude</a></li><li class="chapter-item "><a href="Library.Univalence.html">Univalence</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="UNICODE_DICTIONARY.html">Unicode Dictionary</a></li><li class="chapter-item affix "><a href="ACKNOWLEDGEMENTS.html">Acknowledgements</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <!-- <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li> -->
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Homotopy Type Theory in Cubical Agda</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/CQTS/introduction-to-cubical" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                  <main>
                    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<!--
<pre class="Agda"><a id="10" class="Keyword">module</a> <a id="17" href="2--Paths-and-Identifications.2-7--Propositions.html" class="Module">2--Paths-and-Identifications.2-7--Propositions</a> <a id="64" class="Keyword">where</a>

<a id="71" class="Keyword">open</a> <a id="76" class="Keyword">import</a> <a id="83" href="Library.Prelude.html" class="Module">Library.Prelude</a>
<a id="99" class="Keyword">open</a> <a id="104" class="Keyword">import</a> <a id="111" href="1--Type-Theory.1-1--Types-and-Functions.html" class="Module">1--Type-Theory.1-1--Types-and-Functions</a>
<a id="151" class="Keyword">open</a> <a id="156" class="Keyword">import</a> <a id="163" href="1--Type-Theory.1-2--Inductive-Types.html" class="Module">1--Type-Theory.1-2--Inductive-Types</a>
<a id="199" class="Keyword">open</a> <a id="204" class="Keyword">import</a> <a id="211" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html" class="Module">1--Type-Theory.1-3--Universes-and-More-Inductive-Types</a>
<a id="266" class="Keyword">open</a> <a id="271" class="Keyword">import</a> <a id="278" href="1--Type-Theory.1-5--Propositions-as-Types.html" class="Module">1--Type-Theory.1-5--Propositions-as-Types</a>
<a id="320" class="Keyword">open</a> <a id="325" class="Keyword">import</a> <a id="332" href="2--Paths-and-Identifications.2-1--Paths.html" class="Module">2--Paths-and-Identifications.2-1--Paths</a>
<a id="372" class="Keyword">open</a> <a id="377" class="Keyword">import</a> <a id="384" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html" class="Module">2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra</a>
<a id="448" class="Keyword">open</a> <a id="453" class="Keyword">import</a> <a id="460" href="2--Paths-and-Identifications.2-3--Substitution-and-J.html" class="Module">2--Paths-and-Identifications.2-3--Substitution-and-J</a>
<a id="513" class="Keyword">open</a> <a id="518" class="Keyword">import</a> <a id="525" href="2--Paths-and-Identifications.2-4--Composition-and-Filling.html" class="Module">2--Paths-and-Identifications.2-4--Composition-and-Filling</a>
<a id="583" class="Keyword">open</a> <a id="588" class="Keyword">import</a> <a id="595" href="2--Paths-and-Identifications.2-5--Transport.html" class="Module">2--Paths-and-Identifications.2-5--Transport</a>

<a id="640" class="Keyword">private</a>
  <a id="650" class="Keyword">variable</a>
    <a id="663" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a> <a id="665" href="2--Paths-and-Identifications.2-7--Propositions.html#665" class="Generalizable">ℓ&#39;</a> <a id="668" class="Symbol">:</a> <a id="670" href="Library.Primitive.html#1060" class="Postulate">Level</a>
    <a id="680" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="682" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="684" href="2--Paths-and-Identifications.2-7--Propositions.html#684" class="Generalizable">P</a> <a id="686" class="Symbol">:</a> <a id="688" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="693" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a>
</pre>-->
<h1 id="lecture-2-7-propositions"><a class="header" href="#lecture-2-7-propositions">Lecture 2-7: Propositions</a></h1>
<p>In Lecture 1-X, we saw how to use types to represent propositions. But
not all types have a sensible interpretation as propositions: an
element of <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code> in some sense contains more information than the mere
fact that a proposition being true. How can we characterise which
types should be thought of as propositions?</p>
<h2 id="contractible-types"><a class="header" href="#contractible-types">Contractible Types</a></h2>
<p>Before we get to defining propositions properly, we’ll start with a
class of types that is even simpler.</p>
<p>A <em>singleton</em> is a type consisting of exactly one element. In ordinary
set theory, if <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> is an element of a set <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, then the singleton
subset of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span> containing <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span></span></span></span> is <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">a</span><span class="mclose">}</span></span></span></span> which, to make crystal clear
that we are dealing with a subset of <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">A</span></span></span></span>, we could write more
pedantically as the set <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">x</span><span class="mclose">}</span></span></span></span>. This is the notion of
singleton we are going to use as our definition in type theory. For an
element of a type <code>a : A</code>, the singleton type at <code>a</code> is:</p>
<pre class="Agda"><a id="singl"></a><a id="1654" href="2--Paths-and-Identifications.2-7--Propositions.html#1654" class="Function">singl</a> <a id="1660" class="Symbol">:</a> <a id="1662" class="Symbol">{</a><a id="1663" href="2--Paths-and-Identifications.2-7--Propositions.html#1663" class="Bound">A</a> <a id="1665" class="Symbol">:</a> <a id="1667" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="1672" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="1673" class="Symbol">}</a> <a id="1675" class="Symbol">→</a> <a id="1677" class="Symbol">(</a><a id="1678" href="2--Paths-and-Identifications.2-7--Propositions.html#1678" class="Bound">a</a> <a id="1680" class="Symbol">:</a> <a id="1682" href="2--Paths-and-Identifications.2-7--Propositions.html#1663" class="Bound">A</a><a id="1683" class="Symbol">)</a> <a id="1685" class="Symbol">→</a> <a id="1687" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="1692" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a>
<a id="1694" href="2--Paths-and-Identifications.2-7--Propositions.html#1654" class="Function">singl</a> <a id="1700" class="Symbol">{</a><a id="1701" class="Argument">A</a> <a id="1703" class="Symbol">=</a> <a id="1705" href="2--Paths-and-Identifications.2-7--Propositions.html#1705" class="Bound">A</a><a id="1706" class="Symbol">}</a> <a id="1708" href="2--Paths-and-Identifications.2-7--Propositions.html#1708" class="Bound">a</a> <a id="1710" class="Symbol">=</a> <a id="1712" href="Library.Prelude.html#1429" class="Function">Σ[</a> <a id="1715" href="2--Paths-and-Identifications.2-7--Propositions.html#1715" class="Bound">x</a> <a id="1717" href="Library.Prelude.html#1429" class="Function">∈</a> <a id="1719" href="2--Paths-and-Identifications.2-7--Propositions.html#1705" class="Bound">A</a> <a id="1721" href="Library.Prelude.html#1429" class="Function">]</a> <a id="1723" href="2--Paths-and-Identifications.2-7--Propositions.html#1708" class="Bound">a</a> <a id="1725" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="1727" href="2--Paths-and-Identifications.2-7--Propositions.html#1715" class="Bound">x</a>
</pre>
<p>There is a unique element of <code>singl a</code>, namely the pair <code>(a, refl)</code>.</p>
<pre class="Agda"><a id="singl-center"></a><a id="1808" href="2--Paths-and-Identifications.2-7--Propositions.html#1808" class="Function">singl-center</a> <a id="1821" class="Symbol">:</a> <a id="1823" class="Symbol">(</a><a id="1824" href="2--Paths-and-Identifications.2-7--Propositions.html#1824" class="Bound">a</a> <a id="1826" class="Symbol">:</a> <a id="1828" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="1829" class="Symbol">)</a> <a id="1831" class="Symbol">→</a> <a id="1833" href="2--Paths-and-Identifications.2-7--Propositions.html#1654" class="Function">singl</a> <a id="1839" href="2--Paths-and-Identifications.2-7--Propositions.html#1824" class="Bound">a</a>
<a id="1841" href="2--Paths-and-Identifications.2-7--Propositions.html#1808" class="Function">singl-center</a> <a id="1854" href="2--Paths-and-Identifications.2-7--Propositions.html#1854" class="Bound">a</a> <a id="1856" class="Symbol">=</a> <a id="1858" class="Symbol">(</a><a id="1859" href="2--Paths-and-Identifications.2-7--Propositions.html#1854" class="Bound">a</a> <a id="1861" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="1863" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a><a id="1867" class="Symbol">)</a>
</pre>
<p>We would like to say in type theory that <code>singl a</code> has a unique
element, so we need a way of expressing “has a unique element”
type-theoretically. For this, we use: </p>
<pre class="Agda"><a id="∃!"></a><a id="2045" href="2--Paths-and-Identifications.2-7--Propositions.html#2045" class="Function">∃!</a> <a id="2048" class="Symbol">:</a> <a id="2050" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="2055" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a> <a id="2057" class="Symbol">→</a> <a id="2059" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="2064" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a>
<a id="2066" href="2--Paths-and-Identifications.2-7--Propositions.html#2045" class="Function">∃!</a> <a id="2069" href="2--Paths-and-Identifications.2-7--Propositions.html#2069" class="Bound">A</a> <a id="2071" class="Symbol">=</a> <a id="2073" href="Library.Prelude.html#1429" class="Function">Σ[</a> <a id="2076" href="2--Paths-and-Identifications.2-7--Propositions.html#2076" class="Bound">x</a> <a id="2078" href="Library.Prelude.html#1429" class="Function">∈</a> <a id="2080" href="2--Paths-and-Identifications.2-7--Propositions.html#2069" class="Bound">A</a> <a id="2082" href="Library.Prelude.html#1429" class="Function">]</a> <a id="2084" class="Symbol">((</a><a id="2086" href="2--Paths-and-Identifications.2-7--Propositions.html#2086" class="Bound">y</a> <a id="2088" class="Symbol">:</a> <a id="2090" href="2--Paths-and-Identifications.2-7--Propositions.html#2069" class="Bound">A</a><a id="2091" class="Symbol">)</a> <a id="2093" class="Symbol">→</a> <a id="2095" href="2--Paths-and-Identifications.2-7--Propositions.html#2086" class="Bound">y</a> <a id="2097" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="2099" href="2--Paths-and-Identifications.2-7--Propositions.html#2076" class="Bound">x</a><a id="2100" class="Symbol">)</a>
</pre>
<p>An element of <code>∃! A</code> demonstrates existence and uniqueness of elements
of <code>A</code>: an element <code>x : A</code> exists, and the function assigning to every
<code>y : A</code> a path <code>x ≡ y</code> means that it is unique. Homotopically
speaking, this means that the type <code>A</code> <em>contracts onto the point <code>x</code></em>.
If we have an element of <code>∃! A</code> we say that <code>A</code> is <em>contractible</em>.</p>
<p>This concept comes up often enough will define a record to capture it
so that we can name the two components.</p>
<pre class="Agda"><a id="2565" class="Keyword">record</a> <a id="isContr"></a><a id="2572" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="2580" class="Symbol">(</a><a id="2581" href="2--Paths-and-Identifications.2-7--Propositions.html#2581" class="Bound">A</a> <a id="2583" class="Symbol">:</a> <a id="2585" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="2590" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="2591" class="Symbol">)</a> <a id="2593" class="Symbol">:</a> <a id="2595" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="2600" href="2--Paths-and-Identifications.2-7--Propositions.html#2590" class="Bound">ℓ</a> <a id="2602" class="Keyword">where</a>
  <a id="2610" class="Keyword">constructor</a> <a id="isContrData"></a><a id="2622" href="2--Paths-and-Identifications.2-7--Propositions.html#2622" class="InductiveConstructor">isContrData</a>
  <a id="2636" class="Keyword">field</a>
    <a id="isContr.center"></a><a id="2646" href="2--Paths-and-Identifications.2-7--Propositions.html#2646" class="Field">center</a> <a id="2653" class="Symbol">:</a> <a id="2655" href="2--Paths-and-Identifications.2-7--Propositions.html#2581" class="Bound">A</a>
    <a id="isContr.contraction"></a><a id="2661" href="2--Paths-and-Identifications.2-7--Propositions.html#2661" class="Field">contraction</a> <a id="2673" class="Symbol">:</a> <a id="2675" class="Symbol">(</a><a id="2676" href="2--Paths-and-Identifications.2-7--Propositions.html#2676" class="Bound">a</a> <a id="2678" class="Symbol">:</a> <a id="2680" href="2--Paths-and-Identifications.2-7--Propositions.html#2581" class="Bound">A</a><a id="2681" class="Symbol">)</a> <a id="2683" class="Symbol">→</a> <a id="2685" href="2--Paths-and-Identifications.2-7--Propositions.html#2646" class="Field">center</a> <a id="2692" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="2694" href="2--Paths-and-Identifications.2-7--Propositions.html#2676" class="Bound">a</a>

<a id="2697" class="Keyword">open</a> <a id="2702" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Module">isContr</a> <a id="2710" class="Keyword">public</a>
</pre>
<p>The type <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a></code> was defined to have only the element <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8988" class="InductiveConstructor">tt</a></code>, so it is
easy to show it is contractible.</p>
<pre class="Agda"><a id="isContr-⊤"></a><a id="2829" href="2--Paths-and-Identifications.2-7--Propositions.html#2829" class="Function">isContr-⊤</a> <a id="2839" class="Symbol">:</a> <a id="2841" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="2849" href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a>
<a id="2851" class="Comment">-- Exercise:</a>
<a id="2864" class="Comment">-- isContr-⊤ = {!!}</a>
</pre>
<p>Singletons should also have a unique element. </p>
<pre class="Agda"><a id="isContr-singl"></a><a id="3051" href="2--Paths-and-Identifications.2-7--Propositions.html#3051" class="Function">isContr-singl</a> <a id="3065" class="Symbol">:</a> <a id="3067" class="Symbol">(</a><a id="3068" href="2--Paths-and-Identifications.2-7--Propositions.html#3068" class="Bound">a</a> <a id="3070" class="Symbol">:</a> <a id="3072" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="3073" class="Symbol">)</a> <a id="3075" class="Symbol">→</a> <a id="3077" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="3085" class="Symbol">(</a><a id="3086" href="2--Paths-and-Identifications.2-7--Propositions.html#1654" class="Function">singl</a> <a id="3092" href="2--Paths-and-Identifications.2-7--Propositions.html#3068" class="Bound">a</a><a id="3093" class="Symbol">)</a>
<a id="3095" class="Comment">-- Exercise: (Hint: You will need to use `J` or a connection.)</a>
<a id="3158" class="Comment">-- isContr-singl a = {!!}</a>
</pre>
<p>There are inductive types other than <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a></code> that we can show are
contractible. As a somewhat contrived example, consider the “fake”
interval type defined by</p>
<pre class="Agda"><a id="3582" class="Keyword">data</a> <a id="Interval"></a><a id="3587" href="2--Paths-and-Identifications.2-7--Propositions.html#3587" class="Datatype">Interval</a> <a id="3596" class="Symbol">:</a> <a id="3598" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="3603" class="Keyword">where</a>
  <a id="Interval.zero"></a><a id="3611" href="2--Paths-and-Identifications.2-7--Propositions.html#3611" class="InductiveConstructor">zero</a> <a id="3616" class="Symbol">:</a> <a id="3618" href="2--Paths-and-Identifications.2-7--Propositions.html#3587" class="Datatype">Interval</a>
  <a id="Interval.one"></a><a id="3629" href="2--Paths-and-Identifications.2-7--Propositions.html#3629" class="InductiveConstructor">one</a>  <a id="3634" class="Symbol">:</a> <a id="3636" href="2--Paths-and-Identifications.2-7--Propositions.html#3587" class="Datatype">Interval</a>
  <a id="Interval.seg"></a><a id="3647" href="2--Paths-and-Identifications.2-7--Propositions.html#3647" class="InductiveConstructor">seg</a>  <a id="3652" class="Symbol">:</a> <a id="3654" href="2--Paths-and-Identifications.2-7--Propositions.html#3611" class="InductiveConstructor">zero</a> <a id="3659" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="3661" href="2--Paths-and-Identifications.2-7--Propositions.html#3629" class="InductiveConstructor">one</a>
</pre>
<p>This interval contains no interesting information at all:</p>
<pre class="Agda"><a id="isContr-Interval"></a><a id="3733" href="2--Paths-and-Identifications.2-7--Propositions.html#3733" class="Function">isContr-Interval</a> <a id="3750" class="Symbol">:</a> <a id="3752" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="3760" href="2--Paths-and-Identifications.2-7--Propositions.html#3587" class="Datatype">Interval</a>
<a id="3769" class="Comment">-- Exercise: (Hint: You will need to use a connection square.)</a>
<a id="3832" class="Comment">-- isContr-Interval = {!!}</a>
</pre>
<div class="info">
<p><span class="info-label">Aside:</span>
This <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#3587" class="Datatype">Interval</a></code> is an ordinary type, in contrast to the
built-in interval <code class="Agda"><a href="Library.Primitive.html#1675" class="Datatype">I</a></code>. We can therefore use it like any other
type; form functions into it, look at paths in it, and so on. It does
not contain any of the magic that <code class="Agda"><a href="Library.Primitive.html#1675" class="Datatype">I</a></code> does, however, so we
can’t make a corresponding <code class="Agda"><a href="Library.Prelude.html#1916" class="Function">Path</a></code> or <code class="Agda"><a href="Library.Prelude.html#650" class="Function">hcomp</a></code>.</p>
</div>
<p>mvrnote: needed later</p>
<pre class="Agda"><a id="Σ-fst-≃"></a><a id="4504" href="2--Paths-and-Identifications.2-7--Propositions.html#4504" class="Function">Σ-fst-≃</a> <a id="4512" class="Symbol">:</a> <a id="4514" class="Symbol">{</a><a id="4515" href="2--Paths-and-Identifications.2-7--Propositions.html#4515" class="Bound">B</a> <a id="4517" class="Symbol">:</a> <a id="4519" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="4521" class="Symbol">→</a> <a id="4523" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="4528" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="4529" class="Symbol">}</a> <a id="4531" class="Symbol">→</a> <a id="4533" class="Symbol">((</a><a id="4535" href="2--Paths-and-Identifications.2-7--Propositions.html#4535" class="Bound">a</a> <a id="4537" class="Symbol">:</a> <a id="4539" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="4540" class="Symbol">)</a> <a id="4542" class="Symbol">→</a> <a id="4544" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="4552" class="Symbol">(</a><a id="4553" href="2--Paths-and-Identifications.2-7--Propositions.html#4515" class="Bound">B</a> <a id="4555" href="2--Paths-and-Identifications.2-7--Propositions.html#4535" class="Bound">a</a><a id="4556" class="Symbol">))</a> <a id="4559" class="Symbol">→</a> <a id="4561" class="Symbol">(</a><a id="4562" href="Library.Prelude.html#1429" class="Function">Σ[</a> <a id="4565" href="2--Paths-and-Identifications.2-7--Propositions.html#4565" class="Bound">a</a> <a id="4567" href="Library.Prelude.html#1429" class="Function">∈</a> <a id="4569" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="4571" href="Library.Prelude.html#1429" class="Function">]</a> <a id="4573" href="2--Paths-and-Identifications.2-7--Propositions.html#4515" class="Bound">B</a> <a id="4575" href="2--Paths-and-Identifications.2-7--Propositions.html#4565" class="Bound">a</a><a id="4576" class="Symbol">)</a> <a id="4578" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="4580" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a>
<a id="4582" href="2--Paths-and-Identifications.2-7--Propositions.html#4504" class="Function">Σ-fst-≃</a> <a id="4590" href="2--Paths-and-Identifications.2-7--Propositions.html#4590" class="Bound">c</a> <a id="4592" class="Symbol">=</a> <a id="4594" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#7290" class="Function">inv→equiv</a> <a id="4604" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="4608" class="Symbol">(λ</a> <a id="4611" href="2--Paths-and-Identifications.2-7--Propositions.html#4611" class="Bound">a</a> <a id="4613" class="Symbol">→</a> <a id="4615" href="2--Paths-and-Identifications.2-7--Propositions.html#4611" class="Bound">a</a> <a id="4617" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="4619" href="2--Paths-and-Identifications.2-7--Propositions.html#4590" class="Bound">c</a> <a id="4621" href="2--Paths-and-Identifications.2-7--Propositions.html#4611" class="Bound">a</a> <a id="4623" class="Symbol">.</a><a id="4624" href="2--Paths-and-Identifications.2-7--Propositions.html#2646" class="Field">center</a><a id="4630" class="Symbol">)</a> <a id="4632" class="Symbol">(λ</a> <a id="4635" href="2--Paths-and-Identifications.2-7--Propositions.html#4635" class="Bound">_</a> <a id="4637" class="Symbol">→</a> <a id="4639" href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a><a id="4643" class="Symbol">)</a> <a id="4645" class="Symbol">(λ</a> <a id="4648" class="Symbol">(</a><a id="4649" href="2--Paths-and-Identifications.2-7--Propositions.html#4649" class="Bound">a</a> <a id="4651" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="4653" href="2--Paths-and-Identifications.2-7--Propositions.html#4653" class="Bound">b</a><a id="4654" class="Symbol">)</a> <a id="4656" class="Symbol">→</a> <a id="4658" href="2--Paths-and-Identifications.2-1--Paths.html#17691" class="Function">ap</a> <a id="4661" class="Symbol">(</a><a id="4662" href="2--Paths-and-Identifications.2-7--Propositions.html#4649" class="Bound">a</a> <a id="4664" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,_</a><a id="4666" class="Symbol">)</a> <a id="4668" class="Symbol">(</a><a id="4669" href="2--Paths-and-Identifications.2-7--Propositions.html#4590" class="Bound">c</a> <a id="4671" href="2--Paths-and-Identifications.2-7--Propositions.html#4649" class="Bound">a</a> <a id="4673" class="Symbol">.</a><a id="4674" href="2--Paths-and-Identifications.2-7--Propositions.html#2661" class="Field">contraction</a> <a id="4686" href="2--Paths-and-Identifications.2-7--Propositions.html#4653" class="Bound">b</a><a id="4687" class="Symbol">))</a>
</pre>
<p>The empty type <code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a></code> is not contractible: it doesn’t have any elements
at all.</p>
<pre class="Agda"><a id="¬isContr-∅"></a><a id="4779" href="2--Paths-and-Identifications.2-7--Propositions.html#4779" class="Function">¬isContr-∅</a> <a id="4790" class="Symbol">:</a> <a id="4792" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="4794" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="4802" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a>
<a id="4804" class="Comment">-- Exercise:</a>
<a id="4817" class="Comment">-- ¬isContr-∅ = {!!}</a>
</pre>
<p>And neither is <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code>. Although elements of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> certainly
exist, they’re not unique.</p>
<pre class="Agda"><a id="¬isContr-Bool"></a><a id="4992" href="2--Paths-and-Identifications.2-7--Propositions.html#4992" class="Function">¬isContr-Bool</a> <a id="5006" class="Symbol">:</a> <a id="5008" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="5010" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="5018" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="5023" class="Comment">-- Exercise: (Hint: `true≢false`.)</a>
<a id="5058" class="Comment">-- ¬isContr-Bool (isContrData b p) = {!!}</a>
</pre>
<h2 id="propositions"><a class="header" href="#propositions">Propositions</a></h2>
<p>Let’s recall from Lecture 1-X that when considering a type <code>A</code> as a
proposition, we think of an element <code>a : A</code> as a witness to the fact
that the proposition <code>A</code> is true. Once we’ve constructed at least one
witness like this, we don’t particularly care about the details of the
construction: we don’t want there to more than one way that the
proposition <code>1 + 1 ≡ 2</code> can be true.</p>
<p>We turn this observation into a definition: propositions are types
which have <em>at most</em> one element. A type is a proposition when, for
any two elements, there is a path between them.</p>
<pre class="Agda"><a id="isProp"></a><a id="5867" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="5874" class="Symbol">:</a> <a id="5876" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="5881" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a> <a id="5883" class="Symbol">→</a> <a id="5885" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="5890" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a>
<a id="5892" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="5899" href="2--Paths-and-Identifications.2-7--Propositions.html#5899" class="Bound">A</a> <a id="5901" class="Symbol">=</a> <a id="5903" class="Symbol">(</a><a id="5904" href="2--Paths-and-Identifications.2-7--Propositions.html#5904" class="Bound">x</a> <a id="5906" href="2--Paths-and-Identifications.2-7--Propositions.html#5906" class="Bound">y</a> <a id="5908" class="Symbol">:</a> <a id="5910" href="2--Paths-and-Identifications.2-7--Propositions.html#5899" class="Bound">A</a><a id="5911" class="Symbol">)</a> <a id="5913" class="Symbol">→</a> <a id="5915" href="2--Paths-and-Identifications.2-7--Propositions.html#5904" class="Bound">x</a> <a id="5917" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="5919" href="2--Paths-and-Identifications.2-7--Propositions.html#5906" class="Bound">y</a>
</pre>
<p>The type <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a></code> is a proposition that has a proof <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8988" class="InductiveConstructor">tt</a></code> — truth.
Because its induction principle lets us assume any element of <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a></code> is
exactly <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8988" class="InductiveConstructor">tt</a></code>, it’s easy to show this is a proposition in this new
sense by pattern-matching.</p>
<pre class="Agda"><a id="isProp-⊤"></a><a id="6164" href="2--Paths-and-Identifications.2-7--Propositions.html#6164" class="Function">isProp-⊤</a> <a id="6173" class="Symbol">:</a> <a id="6175" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="6182" href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a>
<a id="6184" class="Comment">-- Exercise:</a>
<a id="6197" class="Comment">-- isProp-⊤ = {!!}</a>
</pre>
<p>The definition of <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a></code> doesn’t actually promise that there are
any elements of <code>A</code>, just that if we <em>did</em> have two elements, they
would be equal. This is just as well, because not every proposition
has a proof. As we saw in Lecture 1-X, <code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a></code> represents a proposition
with no proof — falsity. If a type has no elements at all then it
certainly has at most one element:</p>
<pre class="Agda"><a id="isProp-∅"></a><a id="6652" href="2--Paths-and-Identifications.2-7--Propositions.html#6652" class="Function">isProp-∅</a> <a id="6661" class="Symbol">:</a> <a id="6663" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="6670" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a>
<a id="6672" class="Comment">-- Exercise:</a>
<a id="6685" class="Comment">-- isProp-∅ = {!!}</a>
</pre>
<p>Using these two facts, we can show that the observational equality
types defined in Lecture 1-X are all propositions.</p>
<pre class="Agda"><a id="isProp-≡Bool"></a><a id="6871" href="2--Paths-and-Identifications.2-7--Propositions.html#6871" class="Function">isProp-≡Bool</a> <a id="6884" class="Symbol">:</a> <a id="6886" class="Symbol">(</a><a id="6887" href="2--Paths-and-Identifications.2-7--Propositions.html#6887" class="Bound">a</a> <a id="6889" href="2--Paths-and-Identifications.2-7--Propositions.html#6889" class="Bound">b</a> <a id="6891" class="Symbol">:</a> <a id="6893" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a><a id="6897" class="Symbol">)</a> <a id="6899" class="Symbol">→</a> <a id="6901" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="6908" class="Symbol">(</a><a id="6909" href="2--Paths-and-Identifications.2-7--Propositions.html#6887" class="Bound">a</a> <a id="6911" href="1--Type-Theory.1-5--Propositions-as-Types.html#13214" class="Function Operator">≡Bool</a> <a id="6917" href="2--Paths-and-Identifications.2-7--Propositions.html#6889" class="Bound">b</a><a id="6918" class="Symbol">)</a>
<a id="6920" href="2--Paths-and-Identifications.2-7--Propositions.html#6871" class="Function">isProp-≡Bool</a> <a id="6933" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="6938" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="6943" class="Symbol">=</a> <a id="6945" href="2--Paths-and-Identifications.2-7--Propositions.html#6164" class="Function">isProp-⊤</a>
<a id="6954" href="2--Paths-and-Identifications.2-7--Propositions.html#6871" class="Function">isProp-≡Bool</a> <a id="6967" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="6972" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="6978" class="Symbol">=</a> <a id="6980" href="2--Paths-and-Identifications.2-7--Propositions.html#6652" class="Function">isProp-∅</a>
<a id="6989" href="2--Paths-and-Identifications.2-7--Propositions.html#6871" class="Function">isProp-≡Bool</a> <a id="7002" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="7008" href="1--Type-Theory.1-2--Inductive-Types.html#1042" class="InductiveConstructor">true</a> <a id="7013" class="Symbol">=</a> <a id="7015" href="2--Paths-and-Identifications.2-7--Propositions.html#6652" class="Function">isProp-∅</a>
<a id="7024" href="2--Paths-and-Identifications.2-7--Propositions.html#6871" class="Function">isProp-≡Bool</a> <a id="7037" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="7043" href="1--Type-Theory.1-2--Inductive-Types.html#1057" class="InductiveConstructor">false</a> <a id="7049" class="Symbol">=</a> <a id="7051" href="2--Paths-and-Identifications.2-7--Propositions.html#6164" class="Function">isProp-⊤</a>

<a id="isProp-≡ℕ"></a><a id="7061" href="2--Paths-and-Identifications.2-7--Propositions.html#7061" class="Function">isProp-≡ℕ</a> <a id="7071" class="Symbol">:</a> <a id="7073" class="Symbol">(</a><a id="7074" href="2--Paths-and-Identifications.2-7--Propositions.html#7074" class="Bound">n</a> <a id="7076" href="2--Paths-and-Identifications.2-7--Propositions.html#7076" class="Bound">m</a> <a id="7078" class="Symbol">:</a> <a id="7080" href="Library.Prelude.html#3629" class="Datatype">ℕ</a><a id="7081" class="Symbol">)</a> <a id="7083" class="Symbol">→</a> <a id="7085" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="7092" class="Symbol">(</a><a id="7093" href="2--Paths-and-Identifications.2-7--Propositions.html#7074" class="Bound">n</a> <a id="7095" href="1--Type-Theory.1-5--Propositions-as-Types.html#17221" class="Function Operator">≡ℕ</a> <a id="7098" href="2--Paths-and-Identifications.2-7--Propositions.html#7076" class="Bound">m</a><a id="7099" class="Symbol">)</a>
<a id="7101" class="Comment">-- Exercise:</a>
<a id="7114" class="Comment">-- isProp-≡ℕ n m = {!!}</a>
</pre>
<p>Contractible types may be thought of as types with a unique element.
Of course, a type with <em>exactly</em> one element also has <em>at most</em> one
element, so contractible types are also propositions.</p>
<pre class="Agda"><a id="isContr→isProp"></a><a id="7588" href="2--Paths-and-Identifications.2-7--Propositions.html#7588" class="Function">isContr→isProp</a> <a id="7603" class="Symbol">:</a> <a id="7605" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="7613" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="7615" class="Symbol">→</a> <a id="7617" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="7624" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a>
<a id="7626" class="Comment">-- Exercise:</a>
<a id="7639" class="Comment">-- isContr→isProp c a b = {!!}</a>
</pre>
<p>The same is not true the other way, of course. We saw that <code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a></code> is a
proposition but isn’t contractible. Not being inhabited is the only
thing missing for a proposition to be contractible: as soon as a
proposition has an element, that element is unique.</p>
<pre class="Agda"><a id="isProp-with-point→isContr"></a><a id="8146" href="2--Paths-and-Identifications.2-7--Propositions.html#8146" class="Function">isProp-with-point→isContr</a> <a id="8172" class="Symbol">:</a> <a id="8174" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="8181" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="8183" class="Symbol">→</a> <a id="8185" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="8187" class="Symbol">→</a> <a id="8189" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="8197" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a>
<a id="8199" class="Comment">-- Exercise:</a>
<a id="8212" class="Comment">-- isProp-with-point→isContr p = {!!}</a>
</pre>
<p>Conversely, if assuming that a type is inhabited causes it to be
contractible, then that type must be a proposition to being with:</p>
<pre class="Agda"><a id="with-point-isContr→isProp"></a><a id="8536" href="2--Paths-and-Identifications.2-7--Propositions.html#8536" class="Function">with-point-isContr→isProp</a> <a id="8562" class="Symbol">:</a> <a id="8564" class="Symbol">(</a><a id="8565" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="8567" class="Symbol">→</a> <a id="8569" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="8577" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="8578" class="Symbol">)</a> <a id="8580" class="Symbol">→</a> <a id="8582" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="8589" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a>
<a id="8591" class="Comment">-- Exercise:</a>
<a id="8604" class="Comment">-- with-point-isContr→isProp c = {!!}</a>
</pre>
<p>Of course, the point of having a definition like <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a></code> is that
not all types are propositions.</p>
<pre class="Agda"><a id="¬isProp-Bool"></a><a id="8838" href="2--Paths-and-Identifications.2-7--Propositions.html#8838" class="Function">¬isProp-Bool</a> <a id="8851" class="Symbol">:</a> <a id="8853" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="8855" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="8862" href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a>
<a id="8867" class="Comment">-- Exercise:</a>
<a id="8880" class="Comment">-- ¬isProp-Bool pBool = {!!}</a>

<a id="¬isProp-ℕ"></a><a id="8980" href="2--Paths-and-Identifications.2-7--Propositions.html#8980" class="Function">¬isProp-ℕ</a> <a id="8990" class="Symbol">:</a> <a id="8992" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="8994" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="9001" href="Library.Prelude.html#3629" class="Datatype">ℕ</a>
<a id="9003" class="Comment">-- Exercise:</a>
<a id="9016" class="Comment">-- ¬isProp-ℕ pℕ = {!!}</a>
</pre>
<h2 id="propositions-equivalences-and-retracts"><a class="header" href="#propositions-equivalences-and-retracts">Propositions, Equivalences and Retracts</a></h2>
<p>Any function between contractible types is an equivalence.</p>
<pre class="Agda"><a id="contrEnds→isEquiv"></a><a id="9223" href="2--Paths-and-Identifications.2-7--Propositions.html#9223" class="Function">contrEnds→isEquiv</a> <a id="9241" class="Symbol">:</a> <a id="9243" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="9251" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="9253" class="Symbol">→</a> <a id="9255" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="9263" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="9265" class="Symbol">→</a> <a id="9267" class="Symbol">(</a><a id="9268" href="2--Paths-and-Identifications.2-7--Propositions.html#9268" class="Bound">f</a> <a id="9270" class="Symbol">:</a> <a id="9272" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="9274" class="Symbol">→</a> <a id="9276" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a><a id="9277" class="Symbol">)</a> <a id="9279" class="Symbol">→</a> <a id="9281" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5559" class="Record">isEquiv</a> <a id="9289" href="2--Paths-and-Identifications.2-7--Propositions.html#9268" class="Bound">f</a>
<a id="9291" class="Comment">-- Exercise:</a>
<a id="9304" class="Comment">-- contrEnds→isEquiv c c&#39; f = {!!}</a>

<a id="contrExt"></a><a id="9679" href="2--Paths-and-Identifications.2-7--Propositions.html#9679" class="Function">contrExt</a> <a id="9688" class="Symbol">:</a> <a id="9690" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="9698" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="9700" class="Symbol">→</a> <a id="9702" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="9710" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="9712" class="Symbol">→</a> <a id="9714" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="9716" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="9718" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a>
<a id="9720" class="Comment">-- Exercise:</a>
<a id="9733" class="Comment">-- contrExt c c&#39; = {!!}</a>
</pre>
<p>So, in fact, every contractible type is equivalent to <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a></code>.</p>
<pre class="Agda"><a id="isContr→≃⊤"></a><a id="9985" href="2--Paths-and-Identifications.2-7--Propositions.html#9985" class="Function">isContr→≃⊤</a> <a id="9996" class="Symbol">:</a> <a id="9998" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="10006" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="10008" class="Symbol">→</a> <a id="10010" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="10012" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="10014" href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a>
<a id="10016" href="2--Paths-and-Identifications.2-7--Propositions.html#9985" class="Function">isContr→≃⊤</a> <a id="10027" href="2--Paths-and-Identifications.2-7--Propositions.html#10027" class="Bound">c</a> <a id="10029" class="Symbol">=</a> <a id="10031" href="2--Paths-and-Identifications.2-7--Propositions.html#9679" class="Function">contrExt</a> <a id="10040" href="2--Paths-and-Identifications.2-7--Propositions.html#10027" class="Bound">c</a> <a id="10042" href="2--Paths-and-Identifications.2-7--Propositions.html#2829" class="Function">isContr-⊤</a>
</pre>
<p>A map between propositions is not enough for them to be equivalent,
consider the unique map <code>∅ → ⊤</code>. But if there are maps both ways, then
that’s enough. This is known as “proposition extensionality”.</p>
<pre class="Agda"><a id="propEnds→isEquiv"></a><a id="10263" href="2--Paths-and-Identifications.2-7--Propositions.html#10263" class="Function">propEnds→isEquiv</a> <a id="10280" class="Symbol">:</a> <a id="10282" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="10289" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="10291" class="Symbol">→</a> <a id="10293" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="10300" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a>
  <a id="10304" class="Symbol">→</a> <a id="10306" class="Symbol">(</a><a id="10307" href="2--Paths-and-Identifications.2-7--Propositions.html#10307" class="Bound">f</a> <a id="10309" class="Symbol">:</a> <a id="10311" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="10313" class="Symbol">→</a> <a id="10315" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a><a id="10316" class="Symbol">)</a>
  <a id="10320" class="Symbol">→</a> <a id="10322" class="Symbol">(</a><a id="10323" href="2--Paths-and-Identifications.2-7--Propositions.html#10323" class="Bound">g</a> <a id="10325" class="Symbol">:</a> <a id="10327" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="10329" class="Symbol">→</a> <a id="10331" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="10332" class="Symbol">)</a>
  <a id="10336" class="Symbol">→</a> <a id="10338" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5559" class="Record">isEquiv</a> <a id="10346" href="2--Paths-and-Identifications.2-7--Propositions.html#10307" class="Bound">f</a>
<a id="10348" class="Comment">-- Exercise:</a>
<a id="10361" href="2--Paths-and-Identifications.2-7--Propositions.html#10263" class="Function">propEnds→isEquiv</a> <a id="10378" href="2--Paths-and-Identifications.2-7--Propositions.html#10378" class="Bound">pA</a> <a id="10381" href="2--Paths-and-Identifications.2-7--Propositions.html#10381" class="Bound">pB</a> <a id="10384" href="2--Paths-and-Identifications.2-7--Propositions.html#10384" class="Bound">f</a> <a id="10386" href="2--Paths-and-Identifications.2-7--Propositions.html#10386" class="Bound">g</a> <a id="10388" class="Symbol">.</a><a id="10389" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5670" class="Field">section</a> <a id="10397" class="Symbol">.</a><a id="10398" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#2582" class="Field">map</a> <a id="10402" class="Symbol">=</a> <a id="10404" href="2--Paths-and-Identifications.2-7--Propositions.html#10386" class="Bound">g</a>

<a id="propExt"></a><a id="10657" href="2--Paths-and-Identifications.2-7--Propositions.html#10657" class="Function">propExt</a> <a id="10665" class="Symbol">:</a> <a id="10667" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="10674" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="10676" class="Symbol">→</a> <a id="10678" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="10685" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a>
  <a id="10689" class="Symbol">→</a> <a id="10691" class="Symbol">(</a><a id="10692" href="2--Paths-and-Identifications.2-7--Propositions.html#10692" class="Bound">f</a> <a id="10694" class="Symbol">:</a> <a id="10696" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="10698" class="Symbol">→</a> <a id="10700" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a><a id="10701" class="Symbol">)</a>
  <a id="10705" class="Symbol">→</a> <a id="10707" class="Symbol">(</a><a id="10708" href="2--Paths-and-Identifications.2-7--Propositions.html#10708" class="Bound">g</a> <a id="10710" class="Symbol">:</a> <a id="10712" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="10714" class="Symbol">→</a> <a id="10716" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="10717" class="Symbol">)</a>
  <a id="10721" class="Symbol">→</a> <a id="10723" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="10725" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="10727" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a>
<a id="10729" class="Comment">-- Exercise:</a>
<a id="10742" class="Comment">-- propExt pA pB f g = equiv f g {!!} {!!}</a>
</pre>
<p>The converse of <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#9985" class="Function">isContr→≃⊤</a></code> is true: if <code>A</code> is equivalent to <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a></code>,
then <code>A</code> is contractible. To prove this, we will use an argument that
we will repeat, with variations, in a couple of other proofs.</p>
<p>Many properties of types are preserved by equivalences, but it turns
out that often just half of the data of an equivalence is enough.
Recall that a map <em>is</em> a retract when it <em>has</em> a section.</p>
<pre class="Agda"><a id="11327" class="Keyword">record</a> <a id="_RetractOnto_"></a><a id="11334" href="2--Paths-and-Identifications.2-7--Propositions.html#11334" class="Record Operator">_RetractOnto_</a> <a id="11348" class="Symbol">(</a><a id="11349" href="2--Paths-and-Identifications.2-7--Propositions.html#11349" class="Bound">A</a> <a id="11351" class="Symbol">:</a> <a id="11353" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="11358" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="11359" class="Symbol">)</a> <a id="11361" class="Symbol">(</a><a id="11362" href="2--Paths-and-Identifications.2-7--Propositions.html#11362" class="Bound">B</a> <a id="11364" class="Symbol">:</a> <a id="11366" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="11371" href="2--Paths-and-Identifications.2-7--Propositions.html#665" class="Generalizable">ℓ&#39;</a><a id="11373" class="Symbol">)</a> <a id="11375" class="Symbol">:</a> <a id="11377" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="11382" class="Symbol">(</a><a id="11383" href="Library.Primitive.html#1128" class="Primitive">ℓ-max</a> <a id="11389" href="2--Paths-and-Identifications.2-7--Propositions.html#11358" class="Bound">ℓ</a> <a id="11391" href="2--Paths-and-Identifications.2-7--Propositions.html#11371" class="Bound">ℓ&#39;</a><a id="11393" class="Symbol">)</a> <a id="11395" class="Keyword">where</a>
  <a id="11403" class="Keyword">constructor</a> <a id="retractOntoData"></a><a id="11415" href="2--Paths-and-Identifications.2-7--Propositions.html#11415" class="InductiveConstructor">retractOntoData</a>
  <a id="11433" class="Keyword">field</a>
    <a id="_RetractOnto_.map"></a><a id="11443" href="2--Paths-and-Identifications.2-7--Propositions.html#11443" class="Field">map</a> <a id="11447" class="Symbol">:</a> <a id="11449" href="2--Paths-and-Identifications.2-7--Propositions.html#11349" class="Bound">A</a> <a id="11451" class="Symbol">→</a> <a id="11453" href="2--Paths-and-Identifications.2-7--Propositions.html#11362" class="Bound">B</a>
    <a id="_RetractOnto_.section"></a><a id="11459" href="2--Paths-and-Identifications.2-7--Propositions.html#11459" class="Field">section</a> <a id="11467" class="Symbol">:</a> <a id="11469" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#2469" class="Record">SectionOf</a> <a id="11479" class="Field">map</a>

<a id="11484" class="Keyword">open</a> <a id="11489" href="2--Paths-and-Identifications.2-7--Propositions.html#11334" class="Module Operator">_RetractOnto_</a> <a id="11503" class="Keyword">public</a>
</pre>
<p>If <code>A</code> is equivalent to <code>B</code> then certainly <code>B</code> retracts onto <code>A</code>,
forgetting the other part of the equivalence.</p>
<pre class="Agda"><a id="equiv→retract"></a><a id="11632" href="2--Paths-and-Identifications.2-7--Propositions.html#11632" class="Function">equiv→retract</a> <a id="11646" class="Symbol">:</a> <a id="11648" class="Symbol">{</a><a id="11649" href="2--Paths-and-Identifications.2-7--Propositions.html#11649" class="Bound">A</a> <a id="11651" class="Symbol">:</a> <a id="11653" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="11658" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="11659" class="Symbol">}</a> <a id="11661" class="Symbol">→</a> <a id="11663" class="Symbol">{</a><a id="11664" href="2--Paths-and-Identifications.2-7--Propositions.html#11664" class="Bound">B</a> <a id="11666" class="Symbol">:</a> <a id="11668" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="11673" href="2--Paths-and-Identifications.2-7--Propositions.html#665" class="Generalizable">ℓ&#39;</a><a id="11675" class="Symbol">}</a> <a id="11677" class="Symbol">→</a> <a id="11679" class="Symbol">(</a><a id="11680" href="2--Paths-and-Identifications.2-7--Propositions.html#11649" class="Bound">A</a> <a id="11682" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="11684" href="2--Paths-and-Identifications.2-7--Propositions.html#11664" class="Bound">B</a><a id="11685" class="Symbol">)</a> <a id="11687" class="Symbol">→</a> <a id="11689" href="2--Paths-and-Identifications.2-7--Propositions.html#11664" class="Bound">B</a> <a id="11691" href="2--Paths-and-Identifications.2-7--Propositions.html#11334" class="Record Operator">RetractOnto</a> <a id="11703" href="2--Paths-and-Identifications.2-7--Propositions.html#11649" class="Bound">A</a>
<a id="11705" href="2--Paths-and-Identifications.2-7--Propositions.html#11632" class="Function">equiv→retract</a> <a id="11719" href="2--Paths-and-Identifications.2-7--Propositions.html#11719" class="Bound">e</a> <a id="11721" class="Symbol">.</a><a id="11722" href="2--Paths-and-Identifications.2-7--Propositions.html#11443" class="Field">map</a> <a id="11726" class="Symbol">=</a> <a id="11728" href="2--Paths-and-Identifications.2-7--Propositions.html#11719" class="Bound">e</a> <a id="11730" class="Symbol">.</a><a id="11731" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5854" class="Field">proof</a> <a id="11737" class="Symbol">.</a><a id="11738" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5696" class="Field">retract</a> <a id="11746" class="Symbol">.</a><a id="11747" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#4253" class="Field">map</a>
<a id="11751" href="2--Paths-and-Identifications.2-7--Propositions.html#11632" class="Function">equiv→retract</a> <a id="11765" href="2--Paths-and-Identifications.2-7--Propositions.html#11765" class="Bound">e</a> <a id="11767" class="Symbol">.</a><a id="11768" href="2--Paths-and-Identifications.2-7--Propositions.html#11459" class="Field">section</a> <a id="11776" class="Symbol">.</a><a id="11777" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#2582" class="Field">map</a> <a id="11781" class="Symbol">=</a> <a id="11783" href="2--Paths-and-Identifications.2-7--Propositions.html#11765" class="Bound">e</a> <a id="11785" class="Symbol">.</a><a id="11786" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5838" class="Field">map</a>
<a id="11790" href="2--Paths-and-Identifications.2-7--Propositions.html#11632" class="Function">equiv→retract</a> <a id="11804" href="2--Paths-and-Identifications.2-7--Propositions.html#11804" class="Bound">e</a> <a id="11806" class="Symbol">.</a><a id="11807" href="2--Paths-and-Identifications.2-7--Propositions.html#11459" class="Field">section</a> <a id="11815" class="Symbol">.</a><a id="11816" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#2598" class="Field">proof</a> <a id="11822" class="Symbol">=</a> <a id="11824" href="2--Paths-and-Identifications.2-7--Propositions.html#11804" class="Bound">e</a> <a id="11826" class="Symbol">.</a><a id="11827" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5854" class="Field">proof</a> <a id="11833" class="Symbol">.</a><a id="11834" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5696" class="Field">retract</a> <a id="11842" class="Symbol">.</a><a id="11843" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#4269" class="Field">proof</a>
</pre>
<p>If <code>B' retracts onto </code>A<code>, then in some sense </code>A<code>is a continuous shrinking of</code>B<code>. And so if </code>B<code>is a proposition then</code>A` must be too.
Here is the key lemma, with a pre-drawn cube for your convenience:</p>
<pre><code>            y — — — — — — — — &gt; y
          / ^                 / ^
  .map  /   |            p  /   |
      /     |             /     |
    x — — — — — — — — &gt; x       |
    ^       |           ^       |                    ^   j
    |       |           |       |                  k | /
    |       |           |       |                    ∙ — &gt;
    |       |           |       |                      i
    |    r (s y)  — — — | — — &gt; y
    |     /             |     /
    |   /               |   /
    | /                 | /
 r (s x) — — — — — — —  x
</code></pre>
<pre class="Agda"><a id="retract-≡"></a><a id="12671" href="2--Paths-and-Identifications.2-7--Propositions.html#12671" class="Function">retract-≡</a> <a id="12681" class="Symbol">:</a> <a id="12683" class="Symbol">(</a><a id="12684" href="2--Paths-and-Identifications.2-7--Propositions.html#12684" class="Bound">r</a> <a id="12686" class="Symbol">:</a> <a id="12688" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="12690" href="2--Paths-and-Identifications.2-7--Propositions.html#11334" class="Record Operator">RetractOnto</a> <a id="12702" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="12703" class="Symbol">)</a>
  <a id="12707" class="Symbol">→</a> <a id="12709" class="Symbol">{</a><a id="12710" href="2--Paths-and-Identifications.2-7--Propositions.html#12710" class="Bound">x</a> <a id="12712" href="2--Paths-and-Identifications.2-7--Propositions.html#12712" class="Bound">y</a> <a id="12714" class="Symbol">:</a> <a id="12716" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="12717" class="Symbol">}</a>
  <a id="12721" class="Symbol">→</a> <a id="12723" class="Symbol">(</a><a id="12724" href="2--Paths-and-Identifications.2-7--Propositions.html#12684" class="Bound">r</a> <a id="12726" class="Symbol">.</a><a id="12727" class="Field">section</a> <a id="12735" class="Symbol">.</a><a id="12736" class="Field">map</a> <a id="12740" href="2--Paths-and-Identifications.2-7--Propositions.html#12710" class="Bound">x</a> <a id="12742" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="12744" href="2--Paths-and-Identifications.2-7--Propositions.html#12684" class="Bound">r</a> <a id="12746" class="Symbol">.</a><a id="12747" class="Field">section</a> <a id="12755" class="Symbol">.</a><a id="12756" class="Field">map</a> <a id="12760" href="2--Paths-and-Identifications.2-7--Propositions.html#12712" class="Bound">y</a><a id="12761" class="Symbol">)</a> <a id="12763" href="2--Paths-and-Identifications.2-7--Propositions.html#11334" class="Record Operator">RetractOnto</a> <a id="12775" class="Symbol">(</a><a id="12776" href="2--Paths-and-Identifications.2-7--Propositions.html#12710" class="Bound">x</a> <a id="12778" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="12780" href="2--Paths-and-Identifications.2-7--Propositions.html#12712" class="Bound">y</a><a id="12781" class="Symbol">)</a>
<a id="12783" class="Comment">-- Exercise: (Hint: Using `∙∙` gives the cleanest argument!)</a>
<a id="12844" class="Comment">-- retract-≡ r {x} {y} = {!!}</a>
</pre>
<p>Then the fact about <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a></code> follows easily.</p>
<pre class="Agda"><a id="isProp-retract"></a><a id="13626" href="2--Paths-and-Identifications.2-7--Propositions.html#13626" class="Function">isProp-retract</a> <a id="13641" class="Symbol">:</a> <a id="13643" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="13645" href="2--Paths-and-Identifications.2-7--Propositions.html#11334" class="Record Operator">RetractOnto</a> <a id="13657" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="13659" class="Symbol">→</a> <a id="13661" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="13668" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="13670" class="Symbol">→</a> <a id="13672" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="13679" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a>
<a id="13681" class="Comment">-- Exercise:</a>
<a id="13694" class="Comment">-- isProp-retract r pB x y = {!!}</a>
</pre>
<p>In particular, any type equivalent to a proposition is also a
proposition.</p>
<pre class="Agda"><a id="isProp-equiv"></a><a id="13928" href="2--Paths-and-Identifications.2-7--Propositions.html#13928" class="Function">isProp-equiv</a> <a id="13941" class="Symbol">:</a> <a id="13943" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="13945" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="13947" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="13949" class="Symbol">→</a> <a id="13951" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="13958" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="13960" class="Symbol">→</a> <a id="13962" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="13969" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a>
<a id="13971" class="Comment">-- Exercise:</a>
<a id="13984" class="Comment">-- isProp-equiv = {!!}</a>
</pre>
<p>And if some contractible type <code>B</code> retracts onto <code>A</code>, then <code>A</code> is also
contractible.</p>
<pre class="Agda"><a id="isContr-retract"></a><a id="14174" href="2--Paths-and-Identifications.2-7--Propositions.html#14174" class="Function">isContr-retract</a> <a id="14190" class="Symbol">:</a> <a id="14192" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="14194" href="2--Paths-and-Identifications.2-7--Propositions.html#11334" class="Record Operator">RetractOnto</a> <a id="14206" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="14208" class="Symbol">→</a> <a id="14210" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="14218" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="14220" class="Symbol">→</a> <a id="14222" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="14230" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a>
<a id="14232" class="Comment">-- Exercise:</a>
<a id="14245" class="Comment">-- isContr-retract r c = {!!}</a>

<a id="isContr-equiv"></a><a id="14636" href="2--Paths-and-Identifications.2-7--Propositions.html#14636" class="Function">isContr-equiv</a> <a id="14650" class="Symbol">:</a> <a id="14652" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="14654" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="14656" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="14658" class="Symbol">→</a> <a id="14660" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="14668" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="14670" class="Symbol">→</a> <a id="14672" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="14680" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a>
<a id="14682" class="Comment">-- Exercise:</a>
<a id="14695" class="Comment">-- isContr-equiv = {!!}</a>
</pre>
<p>So we have a converse to <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#9985" class="Function">isContr→≃⊤</a></code>, and being contractible is the
same as being equivalent to <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a></code>.</p>
<pre class="Agda"><a id="≃⊤→isContr"></a><a id="14910" href="2--Paths-and-Identifications.2-7--Propositions.html#14910" class="Function">≃⊤→isContr</a> <a id="14921" class="Symbol">:</a> <a id="14923" class="Symbol">(</a><a id="14924" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="14926" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="14928" href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a><a id="14929" class="Symbol">)</a> <a id="14931" class="Symbol">→</a> <a id="14933" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="14941" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a>
<a id="14943" class="Comment">-- Exercise:</a>
<a id="14956" class="Comment">-- ≃⊤→isContr = {!!}</a>
</pre>
<p>mvrnote:sort</p>
<pre class="Agda"><a id="¬→≃∅"></a><a id="15067" href="2--Paths-and-Identifications.2-7--Propositions.html#15067" class="Function">¬→≃∅</a> <a id="15072" class="Symbol">:</a> <a id="15074" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="15076" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="15078" class="Symbol">→</a> <a id="15080" class="Symbol">(</a><a id="15081" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="15083" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="15085" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6308" class="Datatype">∅</a><a id="15086" class="Symbol">)</a>
<a id="15088" href="2--Paths-and-Identifications.2-7--Propositions.html#15067" class="Function">¬→≃∅</a> <a id="15093" href="2--Paths-and-Identifications.2-7--Propositions.html#15093" class="Bound">p</a> <a id="15095" class="Symbol">.</a><a id="15096" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5838" class="Field">map</a> <a id="15100" class="Symbol">=</a> <a id="15102" href="2--Paths-and-Identifications.2-7--Propositions.html#15093" class="Bound">p</a>
<a id="15104" href="2--Paths-and-Identifications.2-7--Propositions.html#15067" class="Function">¬→≃∅</a> <a id="15109" href="2--Paths-and-Identifications.2-7--Propositions.html#15109" class="Bound">p</a> <a id="15111" class="Symbol">.</a><a id="15112" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5854" class="Field">proof</a> <a id="15118" class="Symbol">.</a><a id="15119" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5670" class="Field">section</a> <a id="15127" class="Symbol">.</a><a id="15128" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#2582" class="Field">map</a> <a id="15132" class="Symbol">()</a>
<a id="15135" href="2--Paths-and-Identifications.2-7--Propositions.html#15067" class="Function">¬→≃∅</a> <a id="15140" href="2--Paths-and-Identifications.2-7--Propositions.html#15140" class="Bound">p</a> <a id="15142" class="Symbol">.</a><a id="15143" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5854" class="Field">proof</a> <a id="15149" class="Symbol">.</a><a id="15150" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5670" class="Field">section</a> <a id="15158" class="Symbol">.</a><a id="15159" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#2598" class="Field">proof</a> <a id="15165" class="Symbol">()</a>
<a id="15168" href="2--Paths-and-Identifications.2-7--Propositions.html#15067" class="Function">¬→≃∅</a> <a id="15173" href="2--Paths-and-Identifications.2-7--Propositions.html#15173" class="Bound">p</a> <a id="15175" class="Symbol">.</a><a id="15176" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5854" class="Field">proof</a> <a id="15182" class="Symbol">.</a><a id="15183" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5696" class="Field">retract</a> <a id="15191" class="Symbol">.</a><a id="15192" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#4253" class="Field">map</a> <a id="15196" class="Symbol">()</a>
<a id="15199" href="2--Paths-and-Identifications.2-7--Propositions.html#15067" class="Function">¬→≃∅</a> <a id="15204" href="2--Paths-and-Identifications.2-7--Propositions.html#15204" class="Bound">p</a> <a id="15206" class="Symbol">.</a><a id="15207" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5854" class="Field">proof</a> <a id="15213" class="Symbol">.</a><a id="15214" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#5696" class="Field">retract</a> <a id="15222" class="Symbol">.</a><a id="15223" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#4269" class="Field">proof</a> <a id="15229" href="2--Paths-and-Identifications.2-7--Propositions.html#15229" class="Bound">a</a> <a id="15231" class="Symbol">=</a> <a id="15233" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#6971" class="Function">∅-rec</a> <a id="15239" class="Symbol">(</a><a id="15240" href="2--Paths-and-Identifications.2-7--Propositions.html#15204" class="Bound">p</a> <a id="15242" href="2--Paths-and-Identifications.2-7--Propositions.html#15229" class="Bound">a</a><a id="15243" class="Symbol">)</a>
</pre>
<h2 id="closure-properties-of-propositions"><a class="header" href="#closure-properties-of-propositions">Closure Properties of Propositions</a></h2>
<p>Back in Lecture 1-X, we used ordinary type constructors to represent
logical operations on propositions. We had better make sure that our
new notion of proposition is preserved by these type constructors!</p>
<p>First, we have implication. If <code>A</code> and <code>B</code> are propositions then the
type of functions <code>A → B</code> is a proposition — namely, the proposition
that <code>A</code> implies <code>B</code>.</p>
<pre class="Agda"><a id="isProp-→"></a><a id="15663" href="2--Paths-and-Identifications.2-7--Propositions.html#15663" class="Function">isProp-→</a> <a id="15672" class="Symbol">:</a> <a id="15674" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="15681" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="15683" class="Symbol">→</a> <a id="15685" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="15692" class="Symbol">(</a><a id="15693" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="15695" class="Symbol">→</a> <a id="15697" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a><a id="15698" class="Symbol">)</a>
<a id="15700" class="Comment">-- Exercise:</a>
<a id="15713" class="Comment">-- isProp-→ p f g i a = {!!}</a>
</pre>
<p>As a special case of implication, we find that type negation <code>¬ A</code> is
always a proposition even when <code>A</code> isn’t.</p>
<pre class="Agda"><a id="isProp-¬"></a><a id="15928" href="2--Paths-and-Identifications.2-7--Propositions.html#15928" class="Function">isProp-¬</a> <a id="15937" class="Symbol">:</a> <a id="15939" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="15946" class="Symbol">(</a><a id="15947" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="15949" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="15950" class="Symbol">)</a>
<a id="15952" href="2--Paths-and-Identifications.2-7--Propositions.html#15928" class="Function">isProp-¬</a> <a id="15961" class="Symbol">=</a> <a id="15963" href="2--Paths-and-Identifications.2-7--Propositions.html#15663" class="Function">isProp-→</a> <a id="15972" href="2--Paths-and-Identifications.2-7--Propositions.html#6652" class="Function">isProp-∅</a>
</pre>
<p>If <code>B</code> is true, then <code>A → B</code> is always true. Using <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a></code> as our
interpretation for “true proposition”, this means that <code>A → B</code> is
contractible as soon as <code>B</code> is contractible.</p>
<pre class="Agda"><a id="isContr→"></a><a id="16172" href="2--Paths-and-Identifications.2-7--Propositions.html#16172" class="Function">isContr→</a> <a id="16181" class="Symbol">:</a> <a id="16183" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="16191" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="16193" class="Symbol">→</a> <a id="16195" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="16203" class="Symbol">(</a><a id="16204" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="16206" class="Symbol">→</a> <a id="16208" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a><a id="16209" class="Symbol">)</a>
<a id="16211" class="Comment">-- Exercise:</a>
<a id="16224" class="Comment">-- isContr→ c = {!!}</a>
</pre>
<p>The “and” of two propositions <code>A</code> and <code>B</code> is the type of pairs <code>A × B</code>.</p>
<pre class="Agda"><a id="isProp-×"></a><a id="16469" href="2--Paths-and-Identifications.2-7--Propositions.html#16469" class="Function">isProp-×</a> <a id="16478" class="Symbol">:</a> <a id="16480" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="16487" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="16489" class="Symbol">→</a> <a id="16491" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="16498" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="16500" class="Symbol">→</a> <a id="16502" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="16509" class="Symbol">(</a><a id="16510" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="16512" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="16514" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a><a id="16515" class="Symbol">)</a>
<a id="16517" class="Comment">-- Exercise:</a>
<a id="16530" class="Comment">-- isProp-× pA pB = {!!}</a>
</pre>
<p>And if <code>A</code> and <code>B</code> are both true, then <code>A × B</code> should also be true.</p>
<pre class="Agda"><a id="isContr-×"></a><a id="16723" href="2--Paths-and-Identifications.2-7--Propositions.html#16723" class="Function">isContr-×</a> <a id="16733" class="Symbol">:</a> <a id="16735" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="16743" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="16745" class="Symbol">→</a> <a id="16747" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="16755" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="16757" class="Symbol">→</a> <a id="16759" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="16767" class="Symbol">(</a><a id="16768" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="16770" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="16772" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a><a id="16773" class="Symbol">)</a>
<a id="16775" class="Comment">-- Exercise:</a>
<a id="16788" class="Comment">-- isContr-× cA cB = {!!}</a>
</pre>
<p>For contractibility, the converse of <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#16723" class="Function">isContr-×</a></code> holds: if the product
is contractible then the inputs must have been.</p>
<pre class="Agda"><a id="isContr-×-conv"></a><a id="17132" href="2--Paths-and-Identifications.2-7--Propositions.html#17132" class="Function">isContr-×-conv</a> <a id="17147" class="Symbol">:</a> <a id="17149" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="17157" class="Symbol">(</a><a id="17158" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="17160" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="17162" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a><a id="17163" class="Symbol">)</a> <a id="17165" class="Symbol">→</a> <a id="17167" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="17175" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="17177" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="17179" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="17187" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a>
<a id="17189" class="Comment">-- Exercise:</a>
<a id="17202" class="Comment">-- isContr-×-conv cAB = {!!}</a>
</pre>
<p>The same is not true for propositions: a product of types being a
proposition does not imply that the two components are.</p>
<pre class="Agda"><a id="¬isProp-×-conv"></a><a id="17733" href="2--Paths-and-Identifications.2-7--Propositions.html#17733" class="Function">¬isProp-×-conv</a> <a id="17748" class="Symbol">:</a> <a id="17750" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="17752" class="Symbol">((</a><a id="17754" href="2--Paths-and-Identifications.2-7--Propositions.html#17754" class="Bound">A</a> <a id="17756" href="2--Paths-and-Identifications.2-7--Propositions.html#17756" class="Bound">B</a> <a id="17758" class="Symbol">:</a> <a id="17760" href="Library.Primitive.html#422" class="Primitive">Type</a><a id="17764" class="Symbol">)</a> <a id="17766" class="Symbol">→</a> <a id="17768" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="17775" class="Symbol">(</a><a id="17776" href="2--Paths-and-Identifications.2-7--Propositions.html#17754" class="Bound">A</a> <a id="17778" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="17780" href="2--Paths-and-Identifications.2-7--Propositions.html#17756" class="Bound">B</a><a id="17781" class="Symbol">)</a> <a id="17783" class="Symbol">→</a> <a id="17785" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="17792" href="2--Paths-and-Identifications.2-7--Propositions.html#17754" class="Bound">A</a> <a id="17794" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="17796" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="17803" href="2--Paths-and-Identifications.2-7--Propositions.html#17756" class="Bound">B</a><a id="17804" class="Symbol">)</a>
<a id="17806" class="Comment">-- Exercise: (Hint: <code class="Agda"><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#16326" class="Function">∅×≃∅</a></code>)</a>
<a id="17836" class="Comment">-- ¬isProp-×-conv = {!!}</a>
</pre>
<p>Propositions and contractible types are also closed under forming path
types. There’s another way interpret this fact. The <code class="Agda"><a href="Library.Prelude.html#650" class="Function">hcomp</a></code>
operation lets us fill in open boxes in any type. If the type is a
proposition, then we can fill any shape at all.</p>
<h2 id="filling-shapes-in-propositions"><a class="header" href="#filling-shapes-in-propositions">Filling Shapes in Propositions</a></h2>
<p>mvrnote: this section needs rationalising</p>
<p>If a type is a proposition we can use the element of <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a></code> to
find a path between any two points. Not only that, but this path we
are given is unique; all path between those points are equal.</p>
<p>This is a priori surprising: the definition of <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a></code> gives us
paths between points, but says nothing about cubes of higher
dimension.</p>
<p>mvrnote: draw cube</p>
<p>mvrnote: out of date:</p>
<iframe class="quiver-embed" src="https://q.uiver.app/#q=WzAsMTIsWzEsMCwiXFxtYXRodHR7YzF9Il0sWzMsMCwiXFxtYXRodHR7eX0iXSxbMCwxLCJcXG1hdGh₀dHtjMH₀iXSxbMiwxLCJcXG1hdGh₀dHt5fSJdLFswLDMsIlxcbWF0aHR0e2MwfSJdLFsyLDMsIlxcbWF0aHR0e2MwfSJdLFsxLDIsIlxcbWF0aHR0e2MwfSJdLFszLDIsIlxcbWF0aHR0e2MwfSJdLFs0LDIsIlxcLCJdLFs1LDIsIlxcLCJdLFs0LDEsIlxcLCJdLFs1LDEsIlxcLCJdLFswLDEsIlxcbWF0aHR0e2gxfVxcLCBcXG1hdGh₀dHt5fSJdLFsyLDMsIlxcbWF0aHR0e2gwfVxcLCBcXG1hdGh₀dHt5fSIsMCx7ImxhYmVsX3Bvc2l0aW9uIjo3MH₁dLFszLDEsIlxcbWF0aHR0e3l9IiwwLHsibGFiZWxfcG9zaXRpb24iOjQwfV0sWzIsMCwiXFxtYXRodHR7aDB9XFwsIFxcbWF0aHR0e2MxfSIsMCx7ImxhYmVsX3Bvc2l0aW9uIjozMH₁dLFs0LDJdLFs1LDNdLFs2LDBdLFs1LDddLFs0LDZdLFs0LDVdLFs2LDddLFs3LDFdLFs4LDksImkiLDJdLFs4LDEwLCJrIl0sWzgsMTEsImoiLDAseyJsYWJlbF9wb3NpdGlvbiI6NDAsInNob3J0ZW4iOnsidGFyZ2V0IjozMH₁9XV0=&embed" width="816" height="560" style="border-radius: 8px; border: none;"></iframe>
<pre class="Agda"><a id="isProp→Square"></a><a id="19565" href="2--Paths-and-Identifications.2-7--Propositions.html#19565" class="Function">isProp→Square</a> <a id="19579" class="Symbol">:</a> <a id="19581" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="19588" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a>
  <a id="19592" class="Symbol">→</a> <a id="19594" class="Symbol">{</a><a id="19595" href="2--Paths-and-Identifications.2-7--Propositions.html#19595" class="Bound">a</a> <a id="19597" href="2--Paths-and-Identifications.2-7--Propositions.html#19597" class="Bound">b</a> <a id="19599" href="2--Paths-and-Identifications.2-7--Propositions.html#19599" class="Bound">c</a> <a id="19601" href="2--Paths-and-Identifications.2-7--Propositions.html#19601" class="Bound">d</a> <a id="19603" class="Symbol">:</a> <a id="19605" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="19606" class="Symbol">}</a>
  <a id="19610" class="Symbol">→</a> <a id="19612" class="Symbol">(</a><a id="19613" href="2--Paths-and-Identifications.2-7--Propositions.html#19613" class="Bound">r</a> <a id="19615" class="Symbol">:</a> <a id="19617" href="2--Paths-and-Identifications.2-7--Propositions.html#19595" class="Bound">a</a> <a id="19619" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="19621" href="2--Paths-and-Identifications.2-7--Propositions.html#19599" class="Bound">c</a><a id="19622" class="Symbol">)</a> <a id="19624" class="Symbol">(</a><a id="19625" href="2--Paths-and-Identifications.2-7--Propositions.html#19625" class="Bound">s</a> <a id="19627" class="Symbol">:</a> <a id="19629" href="2--Paths-and-Identifications.2-7--Propositions.html#19597" class="Bound">b</a> <a id="19631" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="19633" href="2--Paths-and-Identifications.2-7--Propositions.html#19601" class="Bound">d</a><a id="19634" class="Symbol">)</a>
  <a id="19638" class="Symbol">→</a> <a id="19640" class="Symbol">(</a><a id="19641" href="2--Paths-and-Identifications.2-7--Propositions.html#19641" class="Bound">t</a> <a id="19643" class="Symbol">:</a> <a id="19645" href="2--Paths-and-Identifications.2-7--Propositions.html#19595" class="Bound">a</a> <a id="19647" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="19649" href="2--Paths-and-Identifications.2-7--Propositions.html#19597" class="Bound">b</a><a id="19650" class="Symbol">)</a> <a id="19652" class="Symbol">(</a><a id="19653" href="2--Paths-and-Identifications.2-7--Propositions.html#19653" class="Bound">u</a> <a id="19655" class="Symbol">:</a> <a id="19657" href="2--Paths-and-Identifications.2-7--Propositions.html#19599" class="Bound">c</a> <a id="19659" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="19661" href="2--Paths-and-Identifications.2-7--Propositions.html#19601" class="Bound">d</a><a id="19662" class="Symbol">)</a>
  <a id="19666" class="Symbol">→</a> <a id="19668" href="2--Paths-and-Identifications.2-1--Paths.html#24427" class="Function">Square</a> <a id="19675" href="2--Paths-and-Identifications.2-7--Propositions.html#19641" class="Bound">t</a> <a id="19677" href="2--Paths-and-Identifications.2-7--Propositions.html#19653" class="Bound">u</a> <a id="19679" href="2--Paths-and-Identifications.2-7--Propositions.html#19613" class="Bound">r</a> <a id="19681" href="2--Paths-and-Identifications.2-7--Propositions.html#19625" class="Bound">s</a>
<a id="19683" class="Comment">-- Exercise:</a>
<a id="19696" class="Comment">-- isProp→Square pA {a = a} r s t u i j = {!!}</a>
</pre>
<p>A special case of <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#19565" class="Function">isProp→Square</a></code> is when we fix two sides of the
square to be <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#5312" class="Function">refl</a></code>, resulting in an ordinary path between paths.
There’s another way to read this: for <code>x</code> and <code>y</code> elements of a
proposition, <code>x ≡ y</code> is also a proposition.</p>
<pre class="Agda"><a id="isProp→isProp≡"></a><a id="20540" href="2--Paths-and-Identifications.2-7--Propositions.html#20540" class="Function">isProp→isProp≡</a> <a id="20555" class="Symbol">:</a> <a id="20557" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="20564" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="20566" class="Symbol">→</a> <a id="20568" class="Symbol">(</a><a id="20569" href="2--Paths-and-Identifications.2-7--Propositions.html#20569" class="Bound">x</a> <a id="20571" href="2--Paths-and-Identifications.2-7--Propositions.html#20571" class="Bound">y</a> <a id="20573" class="Symbol">:</a> <a id="20575" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="20576" class="Symbol">)</a> <a id="20578" class="Symbol">→</a> <a id="20580" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="20587" class="Symbol">(</a><a id="20588" href="2--Paths-and-Identifications.2-7--Propositions.html#20569" class="Bound">x</a> <a id="20590" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="20592" href="2--Paths-and-Identifications.2-7--Propositions.html#20571" class="Bound">y</a><a id="20593" class="Symbol">)</a>
<a id="20595" class="Comment">-- Exercise:</a>
<a id="20608" class="Comment">-- isProp→isProp≡ = {!!}</a>
</pre>
<p>And from this we get that the types of paths in any proposition are
always contractible.</p>
<pre class="Agda"><a id="isProp→isContr≡"></a><a id="20818" href="2--Paths-and-Identifications.2-7--Propositions.html#20818" class="Function">isProp→isContr≡</a> <a id="20834" class="Symbol">:</a> <a id="20836" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="20843" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="20845" class="Symbol">→</a> <a id="20847" class="Symbol">(</a><a id="20848" href="2--Paths-and-Identifications.2-7--Propositions.html#20848" class="Bound">x</a> <a id="20850" href="2--Paths-and-Identifications.2-7--Propositions.html#20850" class="Bound">y</a> <a id="20852" class="Symbol">:</a> <a id="20854" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="20855" class="Symbol">)</a> <a id="20857" class="Symbol">→</a> <a id="20859" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="20867" class="Symbol">(</a><a id="20868" href="2--Paths-and-Identifications.2-7--Propositions.html#20848" class="Bound">x</a> <a id="20870" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="20872" href="2--Paths-and-Identifications.2-7--Propositions.html#20850" class="Bound">y</a><a id="20873" class="Symbol">)</a>
<a id="20875" class="Comment">-- Exercise: </a>
<a id="20889" class="Comment">-- isProp→isContr≡ p x y = {!!}</a>
</pre>
<p>We could have used this as an alternative definition of what it means
to be a proposition, because it’s trivial to go the other way:</p>
<pre class="Agda"><a id="isContr≡→isProp"></a><a id="21172" href="2--Paths-and-Identifications.2-7--Propositions.html#21172" class="Function">isContr≡→isProp</a> <a id="21188" class="Symbol">:</a> <a id="21190" class="Symbol">((</a><a id="21192" href="2--Paths-and-Identifications.2-7--Propositions.html#21192" class="Bound">x</a> <a id="21194" href="2--Paths-and-Identifications.2-7--Propositions.html#21194" class="Bound">y</a> <a id="21196" class="Symbol">:</a> <a id="21198" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="21199" class="Symbol">)</a> <a id="21201" class="Symbol">→</a> <a id="21203" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="21211" class="Symbol">(</a><a id="21212" href="2--Paths-and-Identifications.2-7--Propositions.html#21192" class="Bound">x</a> <a id="21214" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="21216" href="2--Paths-and-Identifications.2-7--Propositions.html#21194" class="Bound">y</a><a id="21217" class="Symbol">))</a> <a id="21220" class="Symbol">→</a> <a id="21222" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="21229" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a>
<a id="21231" class="Comment">-- Exercise: </a>
<a id="21245" class="Comment">-- isContr≡→isProp f x y = {!!}</a>
</pre>
<p>There’s a another way we can generalise <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a></code>. If we have a path
of types which are all propositions, we can produce a path-over that
path between any endpoints.</p>
<pre class="Agda"><a id="isProp→PathP"></a><a id="21519" href="2--Paths-and-Identifications.2-7--Propositions.html#21519" class="Function">isProp→PathP</a> <a id="21532" class="Symbol">:</a> <a id="21534" class="Symbol">{</a><a id="21535" href="2--Paths-and-Identifications.2-7--Propositions.html#21535" class="Bound">A</a> <a id="21537" class="Symbol">:</a> <a id="21539" href="Library.Primitive.html#1675" class="Datatype">I</a> <a id="21541" class="Symbol">→</a> <a id="21543" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="21548" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="21549" class="Symbol">}</a> 
  <a id="21554" class="Symbol">→</a> <a id="21556" class="Symbol">((</a><a id="21558" href="2--Paths-and-Identifications.2-7--Propositions.html#21558" class="Bound">i</a> <a id="21560" class="Symbol">:</a> <a id="21562" href="Library.Primitive.html#1675" class="Datatype">I</a><a id="21563" class="Symbol">)</a> <a id="21565" class="Symbol">→</a> <a id="21567" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="21574" class="Symbol">(</a><a id="21575" href="2--Paths-and-Identifications.2-7--Propositions.html#21535" class="Bound">A</a> <a id="21577" href="2--Paths-and-Identifications.2-7--Propositions.html#21558" class="Bound">i</a><a id="21578" class="Symbol">))</a>
  <a id="21583" class="Symbol">→</a> <a id="21585" class="Symbol">(</a><a id="21586" href="2--Paths-and-Identifications.2-7--Propositions.html#21586" class="Bound">a0</a> <a id="21589" class="Symbol">:</a> <a id="21591" href="2--Paths-and-Identifications.2-7--Propositions.html#21535" class="Bound">A</a> <a id="21593" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="21595" class="Symbol">)</a> <a id="21597" class="Symbol">(</a><a id="21598" href="2--Paths-and-Identifications.2-7--Propositions.html#21598" class="Bound">a1</a> <a id="21601" class="Symbol">:</a> <a id="21603" href="2--Paths-and-Identifications.2-7--Propositions.html#21535" class="Bound">A</a> <a id="21605" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="21607" class="Symbol">)</a>
  <a id="21611" class="Symbol">→</a> <a id="21613" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="21619" href="2--Paths-and-Identifications.2-7--Propositions.html#21535" class="Bound">A</a> <a id="21621" href="2--Paths-and-Identifications.2-7--Propositions.html#21586" class="Bound">a0</a> <a id="21624" href="2--Paths-and-Identifications.2-7--Propositions.html#21598" class="Bound">a1</a>
<a id="21627" class="Comment">-- Exercise: (Hint: `toPathP`)</a>
<a id="21658" class="Comment">-- isProp→PathP {A = A} hB a0 a1 = {!!}</a>

<a id="isProp→isProp-PathP"></a><a id="21804" href="2--Paths-and-Identifications.2-7--Propositions.html#21804" class="Function">isProp→isProp-PathP</a> <a id="21824" class="Symbol">:</a> <a id="21826" class="Symbol">{</a><a id="21827" href="2--Paths-and-Identifications.2-7--Propositions.html#21827" class="Bound">A</a> <a id="21829" class="Symbol">:</a> <a id="21831" href="Library.Primitive.html#1675" class="Datatype">I</a> <a id="21833" class="Symbol">→</a> <a id="21835" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="21840" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="21841" class="Symbol">}</a>
  <a id="21845" class="Symbol">→</a> <a id="21847" class="Symbol">((</a><a id="21849" href="2--Paths-and-Identifications.2-7--Propositions.html#21849" class="Bound">i</a> <a id="21851" class="Symbol">:</a> <a id="21853" href="Library.Primitive.html#1675" class="Datatype">I</a><a id="21854" class="Symbol">)</a> <a id="21856" class="Symbol">→</a> <a id="21858" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="21865" class="Symbol">(</a><a id="21866" href="2--Paths-and-Identifications.2-7--Propositions.html#21827" class="Bound">A</a> <a id="21868" href="2--Paths-and-Identifications.2-7--Propositions.html#21849" class="Bound">i</a><a id="21869" class="Symbol">))</a>
  <a id="21874" class="Symbol">→</a> <a id="21876" class="Symbol">(</a><a id="21877" href="2--Paths-and-Identifications.2-7--Propositions.html#21877" class="Bound">a0</a> <a id="21880" class="Symbol">:</a> <a id="21882" href="2--Paths-and-Identifications.2-7--Propositions.html#21827" class="Bound">A</a> <a id="21884" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="21886" class="Symbol">)</a> <a id="21888" class="Symbol">(</a><a id="21889" href="2--Paths-and-Identifications.2-7--Propositions.html#21889" class="Bound">a1</a> <a id="21892" class="Symbol">:</a> <a id="21894" href="2--Paths-and-Identifications.2-7--Propositions.html#21827" class="Bound">A</a> <a id="21896" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="21898" class="Symbol">)</a>
  <a id="21902" class="Symbol">→</a> <a id="21904" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="21911" class="Symbol">(</a><a id="21912" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="21918" href="2--Paths-and-Identifications.2-7--Propositions.html#21827" class="Bound">A</a> <a id="21920" href="2--Paths-and-Identifications.2-7--Propositions.html#21877" class="Bound">a0</a> <a id="21923" href="2--Paths-and-Identifications.2-7--Propositions.html#21889" class="Bound">a1</a><a id="21925" class="Symbol">)</a>
<a id="21927" class="Comment">-- Exercise: (Hint: Piggyback on `isProp→isProp≡`)</a>
<a id="21978" class="Comment">-- isProp→isProp-PathP pA x y = isProp-equiv {!!} {!1}</a>
</pre>
<p>We can use what we’ve proven so far to bootstrap the process of
filling more interesting shapes. For example, any <code class="Agda"><a href="2--Paths-and-Identifications.2-1--Paths.html#25495" class="Function">SquareP</a></code> can be
filled. We prove this in full, painful generality, because we will
need to use it shortly.</p>
<p>mvrnote: draw square</p>
<pre class="Agda"><a id="isProp→SquareP"></a><a id="22402" href="2--Paths-and-Identifications.2-7--Propositions.html#22402" class="Function">isProp→SquareP</a> <a id="22417" class="Symbol">:</a> <a id="22419" class="Symbol">{</a><a id="22420" href="2--Paths-and-Identifications.2-7--Propositions.html#22420" class="Bound">A</a> <a id="22422" class="Symbol">:</a> <a id="22424" href="Library.Primitive.html#1675" class="Datatype">I</a> <a id="22426" class="Symbol">→</a> <a id="22428" href="Library.Primitive.html#1675" class="Datatype">I</a> <a id="22430" class="Symbol">→</a> <a id="22432" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="22437" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="22438" class="Symbol">}</a> 
  <a id="22443" class="Symbol">→</a> <a id="22445" class="Symbol">((</a><a id="22447" href="2--Paths-and-Identifications.2-7--Propositions.html#22447" class="Bound">i</a> <a id="22449" href="2--Paths-and-Identifications.2-7--Propositions.html#22449" class="Bound">j</a> <a id="22451" class="Symbol">:</a> <a id="22453" href="Library.Primitive.html#1675" class="Datatype">I</a><a id="22454" class="Symbol">)</a> <a id="22456" class="Symbol">→</a> <a id="22458" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="22465" class="Symbol">(</a><a id="22466" href="2--Paths-and-Identifications.2-7--Propositions.html#22420" class="Bound">A</a> <a id="22468" href="2--Paths-and-Identifications.2-7--Propositions.html#22447" class="Bound">i</a> <a id="22470" href="2--Paths-and-Identifications.2-7--Propositions.html#22449" class="Bound">j</a><a id="22471" class="Symbol">))</a>
  
  <a id="22479" class="Symbol">→</a> <a id="22481" class="Symbol">{</a><a id="22482" href="2--Paths-and-Identifications.2-7--Propositions.html#22482" class="Bound">a</a> <a id="22484" class="Symbol">:</a> <a id="22486" href="2--Paths-and-Identifications.2-7--Propositions.html#22420" class="Bound">A</a> <a id="22488" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a> <a id="22491" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="22493" class="Symbol">}</a> <a id="22495" class="Symbol">{</a><a id="22496" href="2--Paths-and-Identifications.2-7--Propositions.html#22496" class="Bound">b</a> <a id="22498" class="Symbol">:</a> <a id="22500" href="2--Paths-and-Identifications.2-7--Propositions.html#22420" class="Bound">A</a> <a id="22502" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a> <a id="22505" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="22507" class="Symbol">}</a> <a id="22509" class="Symbol">{</a><a id="22510" href="2--Paths-and-Identifications.2-7--Propositions.html#22510" class="Bound">c</a> <a id="22512" class="Symbol">:</a> <a id="22514" href="2--Paths-and-Identifications.2-7--Propositions.html#22420" class="Bound">A</a> <a id="22516" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a> <a id="22519" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="22521" class="Symbol">}</a> <a id="22523" class="Symbol">{</a><a id="22524" href="2--Paths-and-Identifications.2-7--Propositions.html#22524" class="Bound">d</a> <a id="22526" class="Symbol">:</a> <a id="22528" href="2--Paths-and-Identifications.2-7--Propositions.html#22420" class="Bound">A</a> <a id="22530" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a> <a id="22533" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="22535" class="Symbol">}</a>

  <a id="22540" class="Symbol">→</a> <a id="22542" class="Symbol">(</a><a id="22543" href="2--Paths-and-Identifications.2-7--Propositions.html#22543" class="Bound">r</a> <a id="22545" class="Symbol">:</a> <a id="22547" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="22553" class="Symbol">(λ</a> <a id="22556" href="2--Paths-and-Identifications.2-7--Propositions.html#22556" class="Bound">j</a> <a id="22558" class="Symbol">→</a> <a id="22560" href="2--Paths-and-Identifications.2-7--Propositions.html#22420" class="Bound">A</a> <a id="22562" href="2--Paths-and-Identifications.2-7--Propositions.html#22556" class="Bound">j</a> <a id="22564" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="22566" class="Symbol">)</a> <a id="22568" href="2--Paths-and-Identifications.2-7--Propositions.html#22482" class="Bound">a</a> <a id="22570" href="2--Paths-and-Identifications.2-7--Propositions.html#22510" class="Bound">c</a><a id="22571" class="Symbol">)</a> <a id="22573" class="Symbol">(</a><a id="22574" href="2--Paths-and-Identifications.2-7--Propositions.html#22574" class="Bound">s</a> <a id="22576" class="Symbol">:</a> <a id="22578" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="22584" class="Symbol">(λ</a> <a id="22587" href="2--Paths-and-Identifications.2-7--Propositions.html#22587" class="Bound">j</a> <a id="22589" class="Symbol">→</a> <a id="22591" href="2--Paths-and-Identifications.2-7--Propositions.html#22420" class="Bound">A</a> <a id="22593" href="2--Paths-and-Identifications.2-7--Propositions.html#22587" class="Bound">j</a> <a id="22595" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="22597" class="Symbol">)</a> <a id="22599" href="2--Paths-and-Identifications.2-7--Propositions.html#22496" class="Bound">b</a> <a id="22601" href="2--Paths-and-Identifications.2-7--Propositions.html#22524" class="Bound">d</a><a id="22602" class="Symbol">)</a>
  <a id="22606" class="Symbol">→</a> <a id="22608" class="Symbol">(</a><a id="22609" href="2--Paths-and-Identifications.2-7--Propositions.html#22609" class="Bound">t</a> <a id="22611" class="Symbol">:</a> <a id="22613" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="22619" class="Symbol">(λ</a> <a id="22622" href="2--Paths-and-Identifications.2-7--Propositions.html#22622" class="Bound">j</a> <a id="22624" class="Symbol">→</a> <a id="22626" href="2--Paths-and-Identifications.2-7--Propositions.html#22420" class="Bound">A</a> <a id="22628" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a> <a id="22631" href="2--Paths-and-Identifications.2-7--Propositions.html#22622" class="Bound">j</a><a id="22632" class="Symbol">)</a> <a id="22634" href="2--Paths-and-Identifications.2-7--Propositions.html#22482" class="Bound">a</a> <a id="22636" href="2--Paths-and-Identifications.2-7--Propositions.html#22496" class="Bound">b</a><a id="22637" class="Symbol">)</a> <a id="22639" class="Symbol">(</a><a id="22640" href="2--Paths-and-Identifications.2-7--Propositions.html#22640" class="Bound">u</a> <a id="22642" class="Symbol">:</a> <a id="22644" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="22650" class="Symbol">(λ</a> <a id="22653" href="2--Paths-and-Identifications.2-7--Propositions.html#22653" class="Bound">j</a> <a id="22655" class="Symbol">→</a> <a id="22657" href="2--Paths-and-Identifications.2-7--Propositions.html#22420" class="Bound">A</a> <a id="22659" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a> <a id="22662" href="2--Paths-and-Identifications.2-7--Propositions.html#22653" class="Bound">j</a><a id="22663" class="Symbol">)</a> <a id="22665" href="2--Paths-and-Identifications.2-7--Propositions.html#22510" class="Bound">c</a> <a id="22667" href="2--Paths-and-Identifications.2-7--Propositions.html#22524" class="Bound">d</a><a id="22668" class="Symbol">)</a>

  <a id="22673" class="Symbol">→</a> <a id="22675" href="2--Paths-and-Identifications.2-1--Paths.html#25495" class="Function">SquareP</a> <a id="22683" href="2--Paths-and-Identifications.2-7--Propositions.html#22420" class="Bound">A</a> <a id="22685" href="2--Paths-and-Identifications.2-7--Propositions.html#22609" class="Bound">t</a> <a id="22687" href="2--Paths-and-Identifications.2-7--Propositions.html#22640" class="Bound">u</a> <a id="22689" href="2--Paths-and-Identifications.2-7--Propositions.html#22543" class="Bound">r</a> <a id="22691" href="2--Paths-and-Identifications.2-7--Propositions.html#22574" class="Bound">s</a>
<a id="22693" class="Comment">-- Exercise:</a>
<a id="22706" class="Comment">-- isProp→SquareP pA r s t u = {!!}</a>
</pre>
<p>We can prove similar facts for contractibility. These can be done
entirely by gluing together results we’ve already seen.</p>
<pre class="Agda"><a id="isContr→isContr≡"></a><a id="22993" href="2--Paths-and-Identifications.2-7--Propositions.html#22993" class="Function">isContr→isContr≡</a> <a id="23010" class="Symbol">:</a> <a id="23012" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="23020" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="23022" class="Symbol">→</a> <a id="23024" class="Symbol">(</a><a id="23025" href="2--Paths-and-Identifications.2-7--Propositions.html#23025" class="Bound">a</a> <a id="23027" href="2--Paths-and-Identifications.2-7--Propositions.html#23027" class="Bound">b</a> <a id="23029" class="Symbol">:</a> <a id="23031" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="23032" class="Symbol">)</a> <a id="23034" class="Symbol">→</a> <a id="23036" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="23044" class="Symbol">(</a><a id="23045" href="2--Paths-and-Identifications.2-7--Propositions.html#23025" class="Bound">a</a> <a id="23047" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="23049" href="2--Paths-and-Identifications.2-7--Propositions.html#23027" class="Bound">b</a><a id="23050" class="Symbol">)</a>
<a id="23052" class="Comment">-- Exercise: (Hint: `isProp-with-point→isContr`)</a>
<a id="23101" class="Comment">-- isContr→isContr≡ c a b = {!!}</a>

<a id="isContr→isContr-PathP"></a><a id="23276" href="2--Paths-and-Identifications.2-7--Propositions.html#23276" class="Function">isContr→isContr-PathP</a> <a id="23298" class="Symbol">:</a> <a id="23300" class="Symbol">{</a><a id="23301" href="2--Paths-and-Identifications.2-7--Propositions.html#23301" class="Bound">A</a> <a id="23303" class="Symbol">:</a> <a id="23305" href="Library.Primitive.html#1675" class="Datatype">I</a> <a id="23307" class="Symbol">→</a> <a id="23309" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="23314" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="23315" class="Symbol">}</a> <a id="23317" class="Symbol">(</a><a id="23318" href="2--Paths-and-Identifications.2-7--Propositions.html#23318" class="Bound">c</a> <a id="23320" class="Symbol">:</a> <a id="23322" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="23330" class="Symbol">(</a><a id="23331" href="2--Paths-and-Identifications.2-7--Propositions.html#23301" class="Bound">A</a> <a id="23333" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="23335" class="Symbol">))</a> <a id="23338" class="Symbol">→</a> <a id="23340" class="Symbol">(</a><a id="23341" href="2--Paths-and-Identifications.2-7--Propositions.html#23341" class="Bound">a</a> <a id="23343" class="Symbol">:</a> <a id="23345" href="2--Paths-and-Identifications.2-7--Propositions.html#23301" class="Bound">A</a> <a id="23347" href="Library.Primitive.html#1723" class="InductiveConstructor">i0</a><a id="23349" class="Symbol">)</a> <a id="23351" class="Symbol">→</a> <a id="23353" class="Symbol">(</a><a id="23354" href="2--Paths-and-Identifications.2-7--Propositions.html#23354" class="Bound">b</a> <a id="23356" class="Symbol">:</a> <a id="23358" href="2--Paths-and-Identifications.2-7--Propositions.html#23301" class="Bound">A</a> <a id="23360" href="Library.Primitive.html#1771" class="InductiveConstructor">i1</a><a id="23362" class="Symbol">)</a> <a id="23364" class="Symbol">→</a> <a id="23366" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="23374" class="Symbol">(</a><a id="23375" href="Library.Primitive.html#2174" class="Postulate">PathP</a> <a id="23381" href="2--Paths-and-Identifications.2-7--Propositions.html#23301" class="Bound">A</a> <a id="23383" href="2--Paths-and-Identifications.2-7--Propositions.html#23341" class="Bound">a</a> <a id="23385" href="2--Paths-and-Identifications.2-7--Propositions.html#23354" class="Bound">b</a><a id="23386" class="Symbol">)</a>
<a id="23388" href="2--Paths-and-Identifications.2-7--Propositions.html#23276" class="Function">isContr→isContr-PathP</a> <a id="23410" class="Symbol">{</a><a id="23411" class="Argument">A</a> <a id="23413" class="Symbol">=</a> <a id="23415" href="2--Paths-and-Identifications.2-7--Propositions.html#23415" class="Bound">A</a><a id="23416" class="Symbol">}</a> <a id="23418" href="2--Paths-and-Identifications.2-7--Propositions.html#23418" class="Bound">isc</a> <a id="23422" href="2--Paths-and-Identifications.2-7--Propositions.html#23422" class="Bound">a</a> <a id="23424" href="2--Paths-and-Identifications.2-7--Propositions.html#23424" class="Bound">b</a> <a id="23426" class="Symbol">=</a> <a id="23428" href="2--Paths-and-Identifications.2-7--Propositions.html#14636" class="Function">isContr-equiv</a> <a id="23442" class="Symbol">(</a><a id="23443" href="2--Paths-and-Identifications.2-5--Transport.html#8807" class="Function">PathP≃Path</a> <a id="23454" href="2--Paths-and-Identifications.2-7--Propositions.html#23415" class="Bound">A</a><a id="23455" class="Symbol">)</a> <a id="23457" class="Symbol">(</a><a id="23458" href="2--Paths-and-Identifications.2-7--Propositions.html#22993" class="Function">isContr→isContr≡</a> <a id="23475" href="2--Paths-and-Identifications.2-7--Propositions.html#23418" class="Bound">isc</a> <a id="23479" class="Symbol">_</a> <a id="23481" class="Symbol">_)</a>
</pre>
<p>Let’s give some more explicit examples of propositions. The first is a
little self-referential: for any type <code>A</code>, there is the proposition
that <code>A</code>… is a proposition.</p>
<pre class="Agda"><a id="isProp-isProp"></a><a id="23663" href="2--Paths-and-Identifications.2-7--Propositions.html#23663" class="Function">isProp-isProp</a> <a id="23677" class="Symbol">:</a> <a id="23679" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="23686" class="Symbol">(</a><a id="23687" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="23694" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="23695" class="Symbol">)</a>
<a id="23697" class="Comment">-- Exercise:</a>
<a id="23710" class="Comment">-- isProp-isProp pA₀ pA₁ i a b j = {!!}</a>
</pre>
<p>And <code>isContr A</code> is always a proposition; the proposition that <code>A</code> has
a unique element.</p>
<pre class="Agda"><a id="isProp-isContr"></a><a id="23984" href="2--Paths-and-Identifications.2-7--Propositions.html#23984" class="Function">isProp-isContr</a> <a id="23999" class="Symbol">:</a> <a id="24001" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="24008" class="Symbol">(</a><a id="24009" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="24017" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="24018" class="Symbol">)</a>
<a id="24020" class="Comment">-- Exercise:</a>
<a id="24033" class="Comment">-- isProp-isContr cA₀ cA₁ i .center = {!!}</a>
<a id="24076" class="Comment">-- isProp-isContr cA₀ cA₁ i .contraction x j = {!!}</a>
</pre>
<p>There’s another important type that is a proposition: the fact that a
map is an equivalence. We will prove this a little later in Lecture
2-X.</p>
<h2 id="subtypes"><a class="header" href="#subtypes">Subtypes</a></h2>
<p>Our definition of proposition leads to a good notion of “subtype”. If
<code>P : A → Type</code> is a family of propositions depending on a type <code>A</code>,
then the <em>subtype</em> of <code>A</code> carved out by <code>P</code> is simply the type of
pairs <code>Σ[ a ∈ A ] P a</code>. So, an element of the subtype is pair <code>(a , p)</code> of an <code>a : A</code> and a witness <code>p : P a</code> that <code>P</code> is true about <code>a</code>.</p>
<p>mvrnote: examples, isEven etc
mvrnote: union/intersection etc</p>
<p>The main fact to prove about subtypes is that they have the same paths
as the types they came from. That is, <code>(a1 , b1) ≡ (a2 , b2)</code> is
equivalent to <code>a1 ≡ a2</code> whenever <code>B</code> is a family of propositions. </p>
<pre class="Agda"><a id="≡-in-subtype"></a><a id="25346" href="2--Paths-and-Identifications.2-7--Propositions.html#25346" class="Function">≡-in-subtype</a> <a id="25359" class="Symbol">:</a> <a id="25361" class="Symbol">{</a><a id="25362" href="2--Paths-and-Identifications.2-7--Propositions.html#25362" class="Bound">A</a> <a id="25364" class="Symbol">:</a> <a id="25366" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="25371" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="25372" class="Symbol">}</a> <a id="25374" class="Symbol">{</a><a id="25375" href="2--Paths-and-Identifications.2-7--Propositions.html#25375" class="Bound">B</a> <a id="25377" class="Symbol">:</a> <a id="25379" href="2--Paths-and-Identifications.2-7--Propositions.html#25362" class="Bound">A</a> <a id="25381" class="Symbol">→</a> <a id="25383" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="25388" href="2--Paths-and-Identifications.2-7--Propositions.html#665" class="Generalizable">ℓ&#39;</a><a id="25390" class="Symbol">}</a>
  <a id="25394" class="Symbol">→</a> <a id="25396" class="Symbol">(</a><a id="25397" href="2--Paths-and-Identifications.2-7--Propositions.html#25397" class="Bound">p</a> <a id="25399" class="Symbol">:</a> <a id="25401" class="Symbol">(</a><a id="25402" href="2--Paths-and-Identifications.2-7--Propositions.html#25402" class="Bound">a</a> <a id="25404" class="Symbol">:</a> <a id="25406" href="2--Paths-and-Identifications.2-7--Propositions.html#25362" class="Bound">A</a><a id="25407" class="Symbol">)</a> <a id="25409" class="Symbol">→</a> <a id="25411" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="25418" class="Symbol">(</a><a id="25419" href="2--Paths-and-Identifications.2-7--Propositions.html#25375" class="Bound">B</a> <a id="25421" href="2--Paths-and-Identifications.2-7--Propositions.html#25402" class="Bound">a</a><a id="25422" class="Symbol">))</a>
  <a id="25427" class="Symbol">→</a> <a id="25429" class="Symbol">(</a><a id="25430" href="2--Paths-and-Identifications.2-7--Propositions.html#25430" class="Bound">x</a> <a id="25432" href="2--Paths-and-Identifications.2-7--Propositions.html#25432" class="Bound">y</a> <a id="25434" class="Symbol">:</a> <a id="25436" href="Library.Prelude.html#1429" class="Function">Σ[</a> <a id="25439" href="2--Paths-and-Identifications.2-7--Propositions.html#25439" class="Bound">a</a> <a id="25441" href="Library.Prelude.html#1429" class="Function">∈</a> <a id="25443" href="2--Paths-and-Identifications.2-7--Propositions.html#25362" class="Bound">A</a> <a id="25445" href="Library.Prelude.html#1429" class="Function">]</a> <a id="25447" href="2--Paths-and-Identifications.2-7--Propositions.html#25375" class="Bound">B</a> <a id="25449" href="2--Paths-and-Identifications.2-7--Propositions.html#25439" class="Bound">a</a><a id="25450" class="Symbol">)</a>
  <a id="25454" class="Symbol">→</a> <a id="25456" class="Symbol">(</a><a id="25457" href="2--Paths-and-Identifications.2-7--Propositions.html#25430" class="Bound">x</a> <a id="25459" class="Symbol">.</a><a id="25460" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="25464" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="25466" href="2--Paths-and-Identifications.2-7--Propositions.html#25432" class="Bound">y</a> <a id="25468" class="Symbol">.</a><a id="25469" href="Library.Prelude.html#1106" class="Field">fst</a><a id="25472" class="Symbol">)</a> <a id="25474" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="25476" class="Symbol">(</a><a id="25477" href="2--Paths-and-Identifications.2-7--Propositions.html#25430" class="Bound">x</a> <a id="25479" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="25481" href="2--Paths-and-Identifications.2-7--Propositions.html#25432" class="Bound">y</a><a id="25482" class="Symbol">)</a>
<a id="25484" href="2--Paths-and-Identifications.2-7--Propositions.html#25346" class="Function">≡-in-subtype</a> <a id="25497" href="2--Paths-and-Identifications.2-7--Propositions.html#25497" class="Bound">pB</a> <a id="25500" href="2--Paths-and-Identifications.2-7--Propositions.html#25500" class="Bound">x</a> <a id="25502" href="2--Paths-and-Identifications.2-7--Propositions.html#25502" class="Bound">y</a> <a id="25504" class="Symbol">=</a> <a id="25506" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#7290" class="Function">inv→equiv</a> <a id="25516" href="2--Paths-and-Identifications.2-7--Propositions.html#25554" class="Function">to</a> <a id="25519" class="Symbol">(</a><a id="25520" href="2--Paths-and-Identifications.2-1--Paths.html#17691" class="Function">ap</a> <a id="25523" href="Library.Prelude.html#1106" class="Field">fst</a><a id="25526" class="Symbol">)</a> <a id="25528" href="2--Paths-and-Identifications.2-7--Propositions.html#25824" class="Function">to-fro</a> <a id="25535" href="2--Paths-and-Identifications.2-7--Propositions.html#26233" class="Function">fro-to</a>
  <a id="25544" class="Keyword">where</a>
    <a id="25554" href="2--Paths-and-Identifications.2-7--Propositions.html#25554" class="Function">to</a> <a id="25557" class="Symbol">:</a> <a id="25559" href="2--Paths-and-Identifications.2-7--Propositions.html#25500" class="Bound">x</a> <a id="25561" class="Symbol">.</a><a id="25562" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="25566" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="25568" href="2--Paths-and-Identifications.2-7--Propositions.html#25502" class="Bound">y</a> <a id="25570" class="Symbol">.</a><a id="25571" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="25575" class="Symbol">→</a> <a id="25577" href="2--Paths-and-Identifications.2-7--Propositions.html#25500" class="Bound">x</a> <a id="25579" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="25581" href="2--Paths-and-Identifications.2-7--Propositions.html#25502" class="Bound">y</a>
    <a id="25587" class="Comment">-- Exercise: (Hint: `isProp→PathP`)</a>
    <a id="25627" class="Comment">-- to e i .fst = {!!}</a>
    <a id="25653" class="Comment">-- to e i .snd = {!!}</a>

    <a id="25824" href="2--Paths-and-Identifications.2-7--Propositions.html#25824" class="Function">to-fro</a> <a id="25831" class="Symbol">:</a> <a id="25833" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#1716" class="Function">isSection</a> <a id="25843" href="2--Paths-and-Identifications.2-7--Propositions.html#25554" class="Function">to</a> <a id="25846" class="Symbol">(</a><a id="25847" href="2--Paths-and-Identifications.2-1--Paths.html#17691" class="Function">ap</a> <a id="25850" href="Library.Prelude.html#1106" class="Field">fst</a><a id="25853" class="Symbol">)</a>
    <a id="25859" class="Comment">-- Exercise: (Hint: `isProp→SquareP`)</a>
    <a id="25901" class="Comment">-- to-fro e i j .fst = {!!}</a>
    <a id="25933" class="Comment">-- to-fro e i j .snd = {!!}</a>

    <a id="26233" href="2--Paths-and-Identifications.2-7--Propositions.html#26233" class="Function">fro-to</a> <a id="26240" class="Symbol">:</a> <a id="26242" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#4019" class="Function">isRetract</a> <a id="26252" href="2--Paths-and-Identifications.2-7--Propositions.html#25554" class="Function">to</a> <a id="26255" class="Symbol">(</a><a id="26256" href="2--Paths-and-Identifications.2-1--Paths.html#17691" class="Function">ap</a> <a id="26259" href="Library.Prelude.html#1106" class="Field">fst</a><a id="26262" class="Symbol">)</a>
    <a id="26268" href="2--Paths-and-Identifications.2-7--Propositions.html#26233" class="Function">fro-to</a> <a id="26275" href="2--Paths-and-Identifications.2-7--Propositions.html#26275" class="Bound">p</a> <a id="26277" href="2--Paths-and-Identifications.2-7--Propositions.html#26277" class="Bound">i</a> <a id="26279" href="2--Paths-and-Identifications.2-7--Propositions.html#26279" class="Bound">j</a> <a id="26281" class="Symbol">=</a> <a id="26283" href="2--Paths-and-Identifications.2-7--Propositions.html#26275" class="Bound">p</a> <a id="26285" href="2--Paths-and-Identifications.2-7--Propositions.html#26279" class="Bound">j</a>
</pre>
<p>To foreshadow Lecture 3-X, this is extremely useful when we start
looking at algebraic structures such as groups, rings, and so on.
These come with some data, like addition and multiplication operators,
together with a bunch of axioms, like associativity, commutativity,
and so on. What we’ve just proven tells us that to build a path
between two groups, it’s enough to build a path just between the
underlying data, ignoring all the axioms.</p>
<h2 id="dependent-closure-properties"><a class="header" href="#dependent-closure-properties">Dependent Closure Properties</a></h2>
<p>The <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#16469" class="Function">isProp-×</a></code> operation has an upgraded, dependent version. This
states that if <code>A</code> is a proposition and <code>P : A → Type</code> is a family of
propositions depending on <code>a : A</code> then the type of pairs <code>Σ[ a ∈ A ] B a</code> is also a proposition. Really, <code>Σ[ a ∈ A ] P a</code> still represents
the proposition “<code>A</code> and <code>B</code>” — the difference is that we can use it
in situations where the proposition <code>B</code> only makes sense when <code>A</code> is
known to hold.</p>
<pre class="Agda"><a id="isProp-Σ"></a><a id="27206" href="2--Paths-and-Identifications.2-7--Propositions.html#27206" class="Function">isProp-Σ</a> <a id="27215" class="Symbol">:</a> <a id="27217" class="Symbol">{</a><a id="27218" href="2--Paths-and-Identifications.2-7--Propositions.html#27218" class="Bound">A</a> <a id="27220" class="Symbol">:</a> <a id="27222" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="27227" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="27228" class="Symbol">}</a> <a id="27230" class="Symbol">{</a><a id="27231" href="2--Paths-and-Identifications.2-7--Propositions.html#27231" class="Bound">P</a> <a id="27233" class="Symbol">:</a> <a id="27235" href="2--Paths-and-Identifications.2-7--Propositions.html#27218" class="Bound">A</a> <a id="27237" class="Symbol">→</a> <a id="27239" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="27244" href="2--Paths-and-Identifications.2-7--Propositions.html#665" class="Generalizable">ℓ&#39;</a><a id="27246" class="Symbol">}</a>
  <a id="27250" class="Symbol">→</a> <a id="27252" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="27259" href="2--Paths-and-Identifications.2-7--Propositions.html#27218" class="Bound">A</a>
  <a id="27263" class="Symbol">→</a> <a id="27265" class="Symbol">((</a><a id="27267" href="2--Paths-and-Identifications.2-7--Propositions.html#27267" class="Bound">a</a> <a id="27269" class="Symbol">:</a> <a id="27271" href="2--Paths-and-Identifications.2-7--Propositions.html#27218" class="Bound">A</a><a id="27272" class="Symbol">)</a> <a id="27274" class="Symbol">→</a> <a id="27276" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="27283" class="Symbol">(</a><a id="27284" href="2--Paths-and-Identifications.2-7--Propositions.html#27231" class="Bound">P</a> <a id="27286" href="2--Paths-and-Identifications.2-7--Propositions.html#27267" class="Bound">a</a><a id="27287" class="Symbol">))</a>
  <a id="27292" class="Symbol">→</a> <a id="27294" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="27301" class="Symbol">(</a><a id="27302" href="Library.Prelude.html#1429" class="Function">Σ[</a> <a id="27305" href="2--Paths-and-Identifications.2-7--Propositions.html#27305" class="Bound">a</a> <a id="27307" href="Library.Prelude.html#1429" class="Function">∈</a> <a id="27309" href="2--Paths-and-Identifications.2-7--Propositions.html#27218" class="Bound">A</a> <a id="27311" href="Library.Prelude.html#1429" class="Function">]</a> <a id="27313" href="2--Paths-and-Identifications.2-7--Propositions.html#27231" class="Bound">P</a> <a id="27315" href="2--Paths-and-Identifications.2-7--Propositions.html#27305" class="Bound">a</a><a id="27316" class="Symbol">)</a>
<a id="27318" class="Comment">-- Exercise: (Hint: use <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#21519" class="Function">isProp→PathP</a></code>.)</a>
<a id="27361" class="Comment">-- isProp-Σ pA pP (a₀ , b₀) (a₁ , b₁) i = {!!}</a>
</pre>
<p>And similarly for contractibility. If <code>A</code> is contractible and <code>P : A → Type</code> is a family of contractible types, then the entire Σ-type is
contractible. This is similar to the <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#16723" class="Function">isContr-×</a></code> case, but will
require <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#21519" class="Function">isProp→PathP</a></code> or <code class="Agda"><a href="" class="Primitive">transport-fixing</a></code> in the second
component.</p>
<pre class="Agda"><a id="isContr-Σ"></a><a id="27849" href="2--Paths-and-Identifications.2-7--Propositions.html#27849" class="Function">isContr-Σ</a> <a id="27859" class="Symbol">:</a> <a id="27861" class="Symbol">{</a><a id="27862" href="2--Paths-and-Identifications.2-7--Propositions.html#27862" class="Bound">P</a> <a id="27864" class="Symbol">:</a> <a id="27866" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="27868" class="Symbol">→</a> <a id="27870" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="27875" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="27876" class="Symbol">}</a> <a id="27878" class="Symbol">→</a> <a id="27880" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="27888" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="27890" class="Symbol">→</a> <a id="27892" class="Symbol">((</a><a id="27894" href="2--Paths-and-Identifications.2-7--Propositions.html#27894" class="Bound">x</a> <a id="27896" class="Symbol">:</a> <a id="27898" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="27899" class="Symbol">)</a> <a id="27901" class="Symbol">→</a> <a id="27903" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="27911" class="Symbol">(</a><a id="27912" href="2--Paths-and-Identifications.2-7--Propositions.html#27862" class="Bound">P</a> <a id="27914" href="2--Paths-and-Identifications.2-7--Propositions.html#27894" class="Bound">x</a><a id="27915" class="Symbol">))</a> <a id="27918" class="Symbol">→</a> <a id="27920" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="27928" class="Symbol">(</a><a id="27929" href="Library.Prelude.html#1429" class="Function">Σ[</a> <a id="27932" href="2--Paths-and-Identifications.2-7--Propositions.html#27932" class="Bound">a</a> <a id="27934" href="Library.Prelude.html#1429" class="Function">∈</a> <a id="27936" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="27938" href="Library.Prelude.html#1429" class="Function">]</a> <a id="27940" href="2--Paths-and-Identifications.2-7--Propositions.html#27862" class="Bound">P</a> <a id="27942" href="2--Paths-and-Identifications.2-7--Propositions.html#27932" class="Bound">a</a><a id="27943" class="Symbol">)</a>
<a id="27945" href="2--Paths-and-Identifications.2-7--Propositions.html#27849" class="Function">isContr-Σ</a> <a id="27955" href="2--Paths-and-Identifications.2-7--Propositions.html#27955" class="Bound">p</a> <a id="27957" href="2--Paths-and-Identifications.2-7--Propositions.html#27957" class="Bound">q</a> <a id="27959" class="Symbol">.</a><a id="27960" href="2--Paths-and-Identifications.2-7--Propositions.html#2646" class="Field">center</a> <a id="27967" class="Symbol">.</a><a id="27968" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="27972" class="Symbol">=</a> <a id="27974" href="2--Paths-and-Identifications.2-7--Propositions.html#27955" class="Bound">p</a> <a id="27976" class="Symbol">.</a><a id="27977" href="2--Paths-and-Identifications.2-7--Propositions.html#2646" class="Field">center</a> 
<a id="27985" href="2--Paths-and-Identifications.2-7--Propositions.html#27849" class="Function">isContr-Σ</a> <a id="27995" href="2--Paths-and-Identifications.2-7--Propositions.html#27995" class="Bound">p</a> <a id="27997" href="2--Paths-and-Identifications.2-7--Propositions.html#27997" class="Bound">q</a> <a id="27999" class="Symbol">.</a><a id="28000" href="2--Paths-and-Identifications.2-7--Propositions.html#2646" class="Field">center</a> <a id="28007" class="Symbol">.</a><a id="28008" href="Library.Prelude.html#1118" class="Field">snd</a> <a id="28012" class="Symbol">=</a> <a id="28014" href="2--Paths-and-Identifications.2-7--Propositions.html#27997" class="Bound">q</a> <a id="28016" class="Symbol">(</a><a id="28017" href="2--Paths-and-Identifications.2-7--Propositions.html#27995" class="Bound">p</a> <a id="28019" class="Symbol">.</a><a id="28020" href="2--Paths-and-Identifications.2-7--Propositions.html#2646" class="Field">center</a><a id="28026" class="Symbol">)</a> <a id="28028" class="Symbol">.</a><a id="28029" href="2--Paths-and-Identifications.2-7--Propositions.html#2646" class="Field">center</a>
<a id="28036" href="2--Paths-and-Identifications.2-7--Propositions.html#27849" class="Function">isContr-Σ</a> <a id="28046" href="2--Paths-and-Identifications.2-7--Propositions.html#28046" class="Bound">p</a> <a id="28048" href="2--Paths-and-Identifications.2-7--Propositions.html#28048" class="Bound">q</a> <a id="28050" class="Symbol">.</a><a id="28051" href="2--Paths-and-Identifications.2-7--Propositions.html#2661" class="Field">contraction</a> <a id="28063" class="Symbol">(</a><a id="28064" href="2--Paths-and-Identifications.2-7--Propositions.html#28064" class="Bound">a</a> <a id="28066" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="28068" href="2--Paths-and-Identifications.2-7--Propositions.html#28068" class="Bound">b</a><a id="28069" class="Symbol">)</a> <a id="28071" href="2--Paths-and-Identifications.2-7--Propositions.html#28071" class="Bound">i</a> <a id="28073" class="Symbol">.</a><a id="28074" href="Library.Prelude.html#1106" class="Field">fst</a> <a id="28078" class="Symbol">=</a> <a id="28080" href="2--Paths-and-Identifications.2-7--Propositions.html#28046" class="Bound">p</a> <a id="28082" class="Symbol">.</a><a id="28083" href="2--Paths-and-Identifications.2-7--Propositions.html#2661" class="Field">contraction</a> <a id="28095" href="2--Paths-and-Identifications.2-7--Propositions.html#28064" class="Bound">a</a> <a id="28097" href="2--Paths-and-Identifications.2-7--Propositions.html#28071" class="Bound">i</a> 
<a id="28100" href="2--Paths-and-Identifications.2-7--Propositions.html#27849" class="Function">isContr-Σ</a> <a id="28110" class="Symbol">{</a><a id="28111" class="Argument">P</a> <a id="28113" class="Symbol">=</a> <a id="28115" href="2--Paths-and-Identifications.2-7--Propositions.html#28115" class="Bound">P</a><a id="28116" class="Symbol">}</a> <a id="28118" href="2--Paths-and-Identifications.2-7--Propositions.html#28118" class="Bound">p</a> <a id="28120" href="2--Paths-and-Identifications.2-7--Propositions.html#28120" class="Bound">q</a> <a id="28122" class="Symbol">.</a><a id="28123" href="2--Paths-and-Identifications.2-7--Propositions.html#2661" class="Field">contraction</a> <a id="28135" class="Symbol">(</a><a id="28136" href="2--Paths-and-Identifications.2-7--Propositions.html#28136" class="Bound">a</a> <a id="28138" href="Library.Prelude.html#1090" class="InductiveConstructor Operator">,</a> <a id="28140" href="2--Paths-and-Identifications.2-7--Propositions.html#28140" class="Bound">b</a><a id="28141" class="Symbol">)</a> <a id="28143" href="2--Paths-and-Identifications.2-7--Propositions.html#28143" class="Bound">i</a> <a id="28145" class="Symbol">.</a><a id="28146" href="Library.Prelude.html#1118" class="Field">snd</a> <a id="28150" class="Symbol">=</a> <a id="28152" href="2--Paths-and-Identifications.2-7--Propositions.html#28120" class="Bound">q</a> <a id="28154" class="Symbol">(</a><a id="28155" href="2--Paths-and-Identifications.2-7--Propositions.html#28118" class="Bound">p</a> <a id="28157" class="Symbol">.</a><a id="28158" href="2--Paths-and-Identifications.2-7--Propositions.html#2661" class="Field">contraction</a> <a id="28170" href="2--Paths-and-Identifications.2-7--Propositions.html#28136" class="Bound">a</a> <a id="28172" href="2--Paths-and-Identifications.2-7--Propositions.html#28143" class="Bound">i</a><a id="28173" class="Symbol">)</a> <a id="28175" class="Symbol">.</a><a id="28176" href="2--Paths-and-Identifications.2-7--Propositions.html#2661" class="Field">contraction</a> <a id="28188" class="Symbol">(</a><a id="28189" href="Library.Prelude.html#447" class="Primitive">transport-fixing</a> <a id="28206" class="Symbol">(λ</a> <a id="28209" href="2--Paths-and-Identifications.2-7--Propositions.html#28209" class="Bound">j</a> <a id="28211" class="Symbol">→</a> <a id="28213" href="2--Paths-and-Identifications.2-7--Propositions.html#28115" class="Bound">P</a> <a id="28215" class="Symbol">(</a><a id="28216" href="2--Paths-and-Identifications.2-7--Propositions.html#28118" class="Bound">p</a> <a id="28218" class="Symbol">.</a><a id="28219" href="2--Paths-and-Identifications.2-7--Propositions.html#2661" class="Field">contraction</a> <a id="28231" href="2--Paths-and-Identifications.2-7--Propositions.html#28136" class="Bound">a</a> <a id="28233" class="Symbol">(</a><a id="28234" href="2--Paths-and-Identifications.2-7--Propositions.html#28143" class="Bound">i</a> <a id="28236" href="Library.Prelude.html#387" class="Primitive Operator">∨</a> <a id="28238" href="Library.Prelude.html#359" class="Primitive Operator">~</a> <a id="28240" href="2--Paths-and-Identifications.2-7--Propositions.html#28209" class="Bound">j</a><a id="28241" class="Symbol">)))</a> <a id="28245" href="2--Paths-and-Identifications.2-7--Propositions.html#28143" class="Bound">i</a> <a id="28247" href="2--Paths-and-Identifications.2-7--Propositions.html#28140" class="Bound">b</a><a id="28248" class="Symbol">)</a> <a id="28250" href="2--Paths-and-Identifications.2-7--Propositions.html#28143" class="Bound">i</a>
</pre>
<p>And <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#15663" class="Function">isProp-→</a></code> can be extended to dependent functions. If <code>P : A → Type</code> is a family of propositions depending on <code>A</code>, then the type of
functions <code>(a : A) → P a</code> is a proposition; the proposition that “for
all <code>a : A</code>, the proposition <code>P a</code> holds”.</p>
<pre class="Agda"><a id="isProp-Π"></a><a id="28513" href="2--Paths-and-Identifications.2-7--Propositions.html#28513" class="Function">isProp-Π</a> <a id="28522" class="Symbol">:</a> <a id="28524" class="Symbol">{</a><a id="28525" href="2--Paths-and-Identifications.2-7--Propositions.html#28525" class="Bound">A</a> <a id="28527" class="Symbol">:</a> <a id="28529" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="28534" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="28535" class="Symbol">}</a> <a id="28537" class="Symbol">→</a> <a id="28539" class="Symbol">{</a><a id="28540" href="2--Paths-and-Identifications.2-7--Propositions.html#28540" class="Bound">P</a> <a id="28542" class="Symbol">:</a> <a id="28544" href="2--Paths-and-Identifications.2-7--Propositions.html#28525" class="Bound">A</a> <a id="28546" class="Symbol">→</a> <a id="28548" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="28553" href="2--Paths-and-Identifications.2-7--Propositions.html#665" class="Generalizable">ℓ&#39;</a><a id="28555" class="Symbol">}</a>
  <a id="28559" class="Symbol">→</a> <a id="28561" class="Symbol">(</a><a id="28562" href="2--Paths-and-Identifications.2-7--Propositions.html#28562" class="Bound">p</a> <a id="28564" class="Symbol">:</a> <a id="28566" class="Symbol">(</a><a id="28567" href="2--Paths-and-Identifications.2-7--Propositions.html#28567" class="Bound">a</a> <a id="28569" class="Symbol">:</a> <a id="28571" href="2--Paths-and-Identifications.2-7--Propositions.html#28525" class="Bound">A</a><a id="28572" class="Symbol">)</a> <a id="28574" class="Symbol">→</a> <a id="28576" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="28583" class="Symbol">(</a><a id="28584" href="2--Paths-and-Identifications.2-7--Propositions.html#28540" class="Bound">P</a> <a id="28586" href="2--Paths-and-Identifications.2-7--Propositions.html#28567" class="Bound">a</a><a id="28587" class="Symbol">))</a>
  <a id="28592" class="Symbol">→</a> <a id="28594" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="28601" class="Symbol">((</a><a id="28603" href="2--Paths-and-Identifications.2-7--Propositions.html#28603" class="Bound">a</a> <a id="28605" class="Symbol">:</a> <a id="28607" href="2--Paths-and-Identifications.2-7--Propositions.html#28525" class="Bound">A</a><a id="28608" class="Symbol">)</a> <a id="28610" class="Symbol">→</a> <a id="28612" href="2--Paths-and-Identifications.2-7--Propositions.html#28540" class="Bound">P</a> <a id="28614" href="2--Paths-and-Identifications.2-7--Propositions.html#28603" class="Bound">a</a><a id="28615" class="Symbol">)</a>
<a id="28617" class="Comment">-- Exercise:</a>
<a id="28630" class="Comment">-- isProp-Π p f g = {!!}</a>
</pre>
<p>And if in fact every <code>P a</code> does hold, then the “for all” proposition
holds too.</p>
<pre class="Agda"><a id="isContr-Π"></a><a id="28811" href="2--Paths-and-Identifications.2-7--Propositions.html#28811" class="Function">isContr-Π</a> <a id="28821" class="Symbol">:</a> <a id="28823" class="Symbol">{</a><a id="28824" href="2--Paths-and-Identifications.2-7--Propositions.html#28824" class="Bound">A</a> <a id="28826" class="Symbol">:</a> <a id="28828" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="28833" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="28834" class="Symbol">}</a> <a id="28836" class="Symbol">→</a> <a id="28838" class="Symbol">{</a><a id="28839" href="2--Paths-and-Identifications.2-7--Propositions.html#28839" class="Bound">P</a> <a id="28841" class="Symbol">:</a> <a id="28843" href="2--Paths-and-Identifications.2-7--Propositions.html#28824" class="Bound">A</a> <a id="28845" class="Symbol">→</a> <a id="28847" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="28852" href="2--Paths-and-Identifications.2-7--Propositions.html#665" class="Generalizable">ℓ&#39;</a><a id="28854" class="Symbol">}</a>
  <a id="28858" class="Symbol">→</a> <a id="28860" class="Symbol">((</a><a id="28862" href="2--Paths-and-Identifications.2-7--Propositions.html#28862" class="Bound">a</a> <a id="28864" class="Symbol">:</a> <a id="28866" href="2--Paths-and-Identifications.2-7--Propositions.html#28824" class="Bound">A</a><a id="28867" class="Symbol">)</a> <a id="28869" class="Symbol">→</a> <a id="28871" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="28879" class="Symbol">(</a><a id="28880" href="2--Paths-and-Identifications.2-7--Propositions.html#28839" class="Bound">P</a> <a id="28882" href="2--Paths-and-Identifications.2-7--Propositions.html#28862" class="Bound">a</a><a id="28883" class="Symbol">))</a>
  <a id="28888" class="Symbol">→</a> <a id="28890" href="2--Paths-and-Identifications.2-7--Propositions.html#2572" class="Record">isContr</a> <a id="28898" class="Symbol">((</a><a id="28900" href="2--Paths-and-Identifications.2-7--Propositions.html#28900" class="Bound">a</a> <a id="28902" class="Symbol">:</a> <a id="28904" href="2--Paths-and-Identifications.2-7--Propositions.html#28824" class="Bound">A</a><a id="28905" class="Symbol">)</a> <a id="28907" class="Symbol">→</a> <a id="28909" href="2--Paths-and-Identifications.2-7--Propositions.html#28839" class="Bound">P</a> <a id="28911" href="2--Paths-and-Identifications.2-7--Propositions.html#28900" class="Bound">a</a><a id="28912" class="Symbol">)</a>
<a id="28914" class="Comment">-- Exercise:</a>
<a id="28927" class="Comment">-- isContr-Π c = {!!}</a>
</pre>
<h2 id="propositional-truncation"><a class="header" href="#propositional-truncation">Propositional Truncation</a></h2>
<p>We are still missing two important logical operations, the same two
that we had trouble with back in Lecture 1-X: “or” and “exists”.</p>
<p>Our guess for “or” was disjoint union <code class="Agda"><a href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype">⊎</a></code>, but the disjoint union of
two propositions is not necessarily a proposition. We checked in
<code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#8838" class="Function">¬isProp-Bool</a></code> that <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> is not a proposition, and we know from
<code class="Agda"><a href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#14924" class="Function">Bool≃⊤⊎⊤</a></code> that <code class="Agda"><a href="1--Type-Theory.1-2--Inductive-Types.html#1022" class="Datatype">Bool</a></code> is the disjoint union <code>⊤ ⊎ ⊤</code>.</p>
<pre class="Agda"><a id="¬isProp-⊤⊎⊤"></a><a id="29532" href="2--Paths-and-Identifications.2-7--Propositions.html#29532" class="Function">¬isProp-⊤⊎⊤</a> <a id="29544" class="Symbol">:</a> <a id="29546" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="29548" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="29555" class="Symbol">(</a><a id="29556" href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a> <a id="29558" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="29560" href="1--Type-Theory.1-2--Inductive-Types.html#8971" class="Datatype">⊤</a><a id="29561" class="Symbol">)</a>
<a id="29563" class="Comment">-- Exercise:</a>
<a id="29576" class="Comment">-- ¬isProp-⊤⊎⊤ = {!!}</a>
</pre>
<div class="info">
<p><span class="info-label">Aside:</span>
But! If we know that the two propositions are mutually exclusive, then
their disjoint union is still a proposition.</p>
<pre class="Agda"><a id="isPropExclusive⊎"></a><a id="29808" href="2--Paths-and-Identifications.2-7--Propositions.html#29808" class="Function">isPropExclusive⊎</a> <a id="29825" class="Symbol">:</a> <a id="29827" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="29834" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="29836" class="Symbol">→</a> <a id="29838" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="29845" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a> <a id="29847" class="Symbol">→</a> <a id="29849" href="1--Type-Theory.1-5--Propositions-as-Types.html#5483" class="Function Operator">¬</a> <a id="29851" class="Symbol">(</a><a id="29852" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="29854" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="29856" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a><a id="29857" class="Symbol">)</a> <a id="29859" class="Symbol">→</a> <a id="29861" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="29868" class="Symbol">(</a><a id="29869" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="29871" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="29873" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a><a id="29874" class="Symbol">)</a>
<a id="29876" class="Comment">-- Exercise:</a>
<a id="29889" class="Comment">-- isPropExclusive⊎ pA pB dis x y = {!!}</a>
</pre>
</div>
<p>For “or” and “exists”, we introduce another inductive type: the
<em>propositional truncation</em>. This accepts any type <code>A</code> as a parameter
and forms a proposition <code>∃ A</code> — the proposition that “there exists
some element of A”. An element of <code>∃ A</code> will be a proof that <code>A</code> has
some element, but crucially, knowing <code>∃ A</code> won’t actually provide us
with a specific element of <code>A</code>, just the fuzzy knowledge that there
exists one.</p>
<pre class="Agda">
<a id="30725" class="Keyword">data</a> <a id="∃_"></a><a id="30730" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃_</a> <a id="30733" class="Symbol">(</a><a id="30734" href="2--Paths-and-Identifications.2-7--Propositions.html#30734" class="Bound">A</a> <a id="30736" class="Symbol">:</a> <a id="30738" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="30743" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="30744" class="Symbol">)</a> <a id="30746" class="Symbol">:</a> <a id="30748" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="30753" href="2--Paths-and-Identifications.2-7--Propositions.html#30743" class="Bound">ℓ</a> <a id="30755" class="Keyword">where</a>
  <a id="∃_.in-∃"></a><a id="30763" href="2--Paths-and-Identifications.2-7--Propositions.html#30763" class="InductiveConstructor">in-∃</a> <a id="30768" class="Symbol">:</a> <a id="30770" href="2--Paths-and-Identifications.2-7--Propositions.html#30734" class="Bound">A</a> <a id="30772" class="Symbol">→</a> <a id="30774" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="30776" href="2--Paths-and-Identifications.2-7--Propositions.html#30734" class="Bound">A</a>
  <a id="∃_.squash"></a><a id="30780" href="2--Paths-and-Identifications.2-7--Propositions.html#30780" class="InductiveConstructor">squash</a> <a id="30787" class="Symbol">:</a> <a id="30789" class="Symbol">(</a><a id="30790" href="2--Paths-and-Identifications.2-7--Propositions.html#30790" class="Bound">x</a> <a id="30792" href="2--Paths-and-Identifications.2-7--Propositions.html#30792" class="Bound">y</a> <a id="30794" class="Symbol">:</a> <a id="30796" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="30798" href="2--Paths-and-Identifications.2-7--Propositions.html#30734" class="Bound">A</a><a id="30799" class="Symbol">)</a> <a id="30801" class="Symbol">→</a> <a id="30803" href="2--Paths-and-Identifications.2-7--Propositions.html#30790" class="Bound">x</a> <a id="30805" href="Library.Prelude.html#2004" class="Function Operator">≡</a> <a id="30807" href="2--Paths-and-Identifications.2-7--Propositions.html#30792" class="Bound">y</a>

<a id="30810" class="Keyword">infix</a> <a id="30816" class="Number">3</a> <a id="30818" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃_</a>
</pre>
<p>The first constructor, written <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#30763" class="InductiveConstructor">in-∃</a></code>, says that to prove that there
exists an element in <code>A</code>, it suffices to have an actual element of
<code>A</code>. The second constructor, <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#30780" class="InductiveConstructor">squash</a></code>, is exactly the claim that <code>∃ A</code> to be a proposition. This is a recursive constructor (like <code class="Agda"><a href="Library.Prelude.html#3657" class="InductiveConstructor">suc</a></code>
is for <code class="Agda"><a href="Library.Prelude.html#3629" class="Datatype">ℕ</a></code>).</p>
<pre class="Agda"><a id="isProp-∃"></a><a id="31124" href="2--Paths-and-Identifications.2-7--Propositions.html#31124" class="Function">isProp-∃</a> <a id="31133" class="Symbol">:</a> <a id="31135" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="31142" class="Symbol">(</a><a id="31143" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="31145" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="31146" class="Symbol">)</a>
<a id="31148" href="2--Paths-and-Identifications.2-7--Propositions.html#31124" class="Function">isProp-∃</a> <a id="31157" class="Symbol">=</a> <a id="31159" href="2--Paths-and-Identifications.2-7--Propositions.html#30780" class="InductiveConstructor">squash</a>
</pre>
<div class="info">
<p><span class="info-label">Aside:</span>
In fact, Agda would even let us declare the <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#30780" class="InductiveConstructor">squash</a></code> constructor to
have type <code>isProp (∃ A)</code>, and realise by unfolding the definition that
this is asking for a path constructor.</p>
</div>
<div class="warning">
<p><span class="warning-label">Warning:</span>
The usual terminology for propositional truncation in Homotopy Type
Theory is <code>∥ A ∥</code>, but this can get confusing if we are doing
mathematics where the same double-bars denote the norm of a vector or
operator.</p>
</div>
<p>The recursion principle for <code>∃ A</code> says that to prove that <code>∃ A</code>
implies some proposition <code>P</code>, it suffices to assume we have an actual
element <code>a : A</code> and then prove <code>P</code>. That is, given a function <code>A → P</code>,
we can get an implication <code>∃ A → P</code> whenever <code>P</code> is a proposition.</p>
<pre class="Agda"><a id="∃-rec"></a><a id="31872" href="2--Paths-and-Identifications.2-7--Propositions.html#31872" class="Function">∃-rec</a> <a id="31878" class="Symbol">:</a> <a id="31880" class="Symbol">(</a><a id="31881" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="31888" href="2--Paths-and-Identifications.2-7--Propositions.html#684" class="Generalizable">P</a><a id="31889" class="Symbol">)</a>
      <a id="31897" class="Symbol">→</a> <a id="31899" class="Symbol">(</a><a id="31900" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="31902" class="Symbol">→</a> <a id="31904" href="2--Paths-and-Identifications.2-7--Propositions.html#684" class="Generalizable">P</a><a id="31905" class="Symbol">)</a>
      <a id="31913" class="Symbol">→</a> <a id="31915" class="Symbol">(</a><a id="31916" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="31918" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="31920" class="Symbol">→</a> <a id="31922" href="2--Paths-and-Identifications.2-7--Propositions.html#684" class="Generalizable">P</a><a id="31923" class="Symbol">)</a>
<a id="31925" class="Comment">-- Exercise:</a>
<a id="31938" class="Comment">-- ∃-rec pP f (in-∃ x) = {!!}</a>
<a id="31968" class="Comment">-- ∃-rec pP f (squash x y i) = pP {!!} {!!} {!!}</a>
</pre>
<div class="info">
<p><span class="info-label">Aside:</span>
This definition is recursive — we use <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#31872" class="Function">∃-rec</a></code> in its own
definition. It’s tempting to give the <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#30780" class="InductiveConstructor">squash</a></code> constructor the
non-recursive type <code>(x y : A) → (in-∃ x) ≡ (in-∃ y)</code>. It turns out this is
not enough: it really is necessary to equate <em>all</em> elements of <code>∃ A</code>,
not just those coming from <code>A</code>. With the non-recursive type, it’s not
possible to prove that <code>∃ A</code> is a proposition.</p>
</div>
<p>As usual, there is a dependently-typed upgrade for this recursion
principle. The individual proposition <code>P</code> is replaced by a family of
types, each of which is a proposition.</p>
<pre class="Agda"><a id="∃-ind"></a><a id="32748" href="2--Paths-and-Identifications.2-7--Propositions.html#32748" class="Function">∃-ind</a> <a id="32754" class="Symbol">:</a> <a id="32756" class="Symbol">{</a><a id="32757" href="2--Paths-and-Identifications.2-7--Propositions.html#32757" class="Bound">P</a> <a id="32759" class="Symbol">:</a> <a id="32761" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="32763" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="32765" class="Symbol">→</a> <a id="32767" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="32772" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="32773" class="Symbol">}</a>
      <a id="32781" class="Symbol">→</a> <a id="32783" class="Symbol">((</a><a id="32785" href="2--Paths-and-Identifications.2-7--Propositions.html#32785" class="Bound">e</a> <a id="32787" class="Symbol">:</a> <a id="32789" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="32791" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="32792" class="Symbol">)</a> <a id="32794" class="Symbol">→</a> <a id="32796" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="32803" class="Symbol">(</a><a id="32804" href="2--Paths-and-Identifications.2-7--Propositions.html#32757" class="Bound">P</a> <a id="32806" href="2--Paths-and-Identifications.2-7--Propositions.html#32785" class="Bound">e</a><a id="32807" class="Symbol">))</a>
      <a id="32816" class="Symbol">→</a> <a id="32818" class="Symbol">((</a><a id="32820" href="2--Paths-and-Identifications.2-7--Propositions.html#32820" class="Bound">a</a> <a id="32822" class="Symbol">:</a> <a id="32824" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="32825" class="Symbol">)</a> <a id="32827" class="Symbol">→</a> <a id="32829" href="2--Paths-and-Identifications.2-7--Propositions.html#32757" class="Bound">P</a> <a id="32831" class="Symbol">(</a><a id="32832" href="2--Paths-and-Identifications.2-7--Propositions.html#30763" class="InductiveConstructor">in-∃</a> <a id="32837" href="2--Paths-and-Identifications.2-7--Propositions.html#32820" class="Bound">a</a><a id="32838" class="Symbol">))</a>
      <a id="32847" class="Symbol">→</a> <a id="32849" class="Symbol">((</a><a id="32851" href="2--Paths-and-Identifications.2-7--Propositions.html#32851" class="Bound">e</a> <a id="32853" class="Symbol">:</a> <a id="32855" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="32857" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="32858" class="Symbol">)</a> <a id="32860" class="Symbol">→</a> <a id="32862" href="2--Paths-and-Identifications.2-7--Propositions.html#32757" class="Bound">P</a> <a id="32864" href="2--Paths-and-Identifications.2-7--Propositions.html#32851" class="Bound">e</a><a id="32865" class="Symbol">)</a>
<a id="32867" class="Comment">-- Exercise:</a>
<a id="32880" class="Comment">-- ∃-ind pP f (in-∃ x) = {!!}</a>
<a id="32910" class="Comment">-- ∃-ind pP f (squash x y i) = isProp→PathP {!!} {!!} {!!} {!!}</a>
</pre>
<p>In fact, all maps into a proposition are of this form, that is,
<code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#32748" class="Function">∃-ind</a></code> is an equivalence.</p>
<pre class="Agda"><a id="∃-ump-≃"></a><a id="33256" href="2--Paths-and-Identifications.2-7--Propositions.html#33256" class="Function">∃-ump-≃</a> <a id="33264" class="Symbol">:</a> <a id="33266" class="Symbol">{</a><a id="33267" href="2--Paths-and-Identifications.2-7--Propositions.html#33267" class="Bound">P</a> <a id="33269" class="Symbol">:</a> <a id="33271" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="33273" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="33275" class="Symbol">→</a> <a id="33277" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="33282" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="33283" class="Symbol">}</a>
      <a id="33291" class="Symbol">→</a> <a id="33293" class="Symbol">((</a><a id="33295" href="2--Paths-and-Identifications.2-7--Propositions.html#33295" class="Bound">e</a> <a id="33297" class="Symbol">:</a> <a id="33299" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="33301" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="33302" class="Symbol">)</a> <a id="33304" class="Symbol">→</a> <a id="33306" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="33313" class="Symbol">(</a><a id="33314" href="2--Paths-and-Identifications.2-7--Propositions.html#33267" class="Bound">P</a> <a id="33316" href="2--Paths-and-Identifications.2-7--Propositions.html#33295" class="Bound">e</a><a id="33317" class="Symbol">))</a>
      <a id="33326" class="Symbol">→</a> <a id="33328" class="Symbol">((</a><a id="33330" href="2--Paths-and-Identifications.2-7--Propositions.html#33330" class="Bound">a</a> <a id="33332" class="Symbol">:</a> <a id="33334" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="33335" class="Symbol">)</a> <a id="33337" class="Symbol">→</a> <a id="33339" href="2--Paths-and-Identifications.2-7--Propositions.html#33267" class="Bound">P</a> <a id="33341" class="Symbol">(</a><a id="33342" href="2--Paths-and-Identifications.2-7--Propositions.html#30763" class="InductiveConstructor">in-∃</a> <a id="33347" href="2--Paths-and-Identifications.2-7--Propositions.html#33330" class="Bound">a</a><a id="33348" class="Symbol">))</a>
      <a id="33357" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="33359" class="Symbol">((</a><a id="33361" href="2--Paths-and-Identifications.2-7--Propositions.html#33361" class="Bound">e</a> <a id="33363" class="Symbol">:</a> <a id="33365" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="33367" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a><a id="33368" class="Symbol">)</a> <a id="33370" class="Symbol">→</a> <a id="33372" href="2--Paths-and-Identifications.2-7--Propositions.html#33267" class="Bound">P</a> <a id="33374" href="2--Paths-and-Identifications.2-7--Propositions.html#33361" class="Bound">e</a><a id="33375" class="Symbol">)</a>
<a id="33377" class="Comment">-- Exercise:</a>
<a id="33390" class="Comment">-- ∃-ump-≃ pP = propExt {!!} {!!} {!!} {!!}</a>
</pre>
<p><code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype">∃</a></code> is functorial, that is, if we have a function from <code>A</code> to
<code>B</code> then <code>A</code> having an element implies <code>B</code> has an element.</p>
<pre class="Agda"><a id="∃-map"></a><a id="33679" href="2--Paths-and-Identifications.2-7--Propositions.html#33679" class="Function">∃-map</a> <a id="33685" class="Symbol">:</a> <a id="33687" class="Symbol">(</a><a id="33688" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="33690" class="Symbol">→</a> <a id="33692" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a><a id="33693" class="Symbol">)</a> <a id="33695" class="Symbol">→</a> <a id="33697" class="Symbol">(</a><a id="33698" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="33700" href="2--Paths-and-Identifications.2-7--Propositions.html#680" class="Generalizable">A</a> <a id="33702" class="Symbol">→</a> <a id="33704" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="33706" href="2--Paths-and-Identifications.2-7--Propositions.html#682" class="Generalizable">B</a><a id="33707" class="Symbol">)</a>
<a id="33709" class="Comment">-- Exercise:</a>
<a id="33722" class="Comment">-- ∃-map f = {!!}</a>
</pre>
<p>If <code>P</code> is already a proposition, truncating it should do nothing:</p>
<pre class="Agda"><a id="isProp→≃∃"></a><a id="33879" href="2--Paths-and-Identifications.2-7--Propositions.html#33879" class="Function">isProp→≃∃</a> <a id="33889" class="Symbol">:</a> <a id="33891" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="33898" href="2--Paths-and-Identifications.2-7--Propositions.html#684" class="Generalizable">P</a> <a id="33900" class="Symbol">→</a> <a id="33902" href="2--Paths-and-Identifications.2-7--Propositions.html#684" class="Generalizable">P</a> <a id="33904" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="33906" class="Symbol">(</a><a id="33907" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="33909" href="2--Paths-and-Identifications.2-7--Propositions.html#684" class="Generalizable">P</a><a id="33910" class="Symbol">)</a>
<a id="33912" class="Comment">-- Exercise: (Hint: use <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#10657" class="Function">propExt</a></code>)</a>
<a id="33949" class="Comment">-- isProp→≃∃ isPropP = {!!}</a>
</pre>
<p>In particular, truncating twice is the same as truncating once.</p>
<pre class="Agda"><a id="∃≃∃∃"></a><a id="34150" href="2--Paths-and-Identifications.2-7--Propositions.html#34150" class="Function">∃≃∃∃</a> <a id="34155" class="Symbol">:</a> <a id="34157" class="Symbol">(</a><a id="34158" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="34160" href="2--Paths-and-Identifications.2-7--Propositions.html#684" class="Generalizable">P</a><a id="34161" class="Symbol">)</a> <a id="34163" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="34165" class="Symbol">(</a><a id="34166" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="34168" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="34170" href="2--Paths-and-Identifications.2-7--Propositions.html#684" class="Generalizable">P</a><a id="34171" class="Symbol">)</a>
<a id="34173" href="2--Paths-and-Identifications.2-7--Propositions.html#34150" class="Function">∃≃∃∃</a> <a id="34178" class="Symbol">=</a> <a id="34180" href="2--Paths-and-Identifications.2-7--Propositions.html#33879" class="Function">isProp→≃∃</a> <a id="34190" href="2--Paths-and-Identifications.2-7--Propositions.html#31124" class="Function">isProp-∃</a>
</pre>
<p>With propositional truncation, we can finally define the proposition
representing “or” which has eluded us. The type <code>A ⊎ B</code> has some
element exactly when <code>A</code> has some element or <code>B</code> has some element.
Therefore, we can define <code>A orP B</code> as the proposition that there
exists an element in <code>A ⊎ B</code>.</p>
<pre class="Agda"><a id="_orP_"></a><a id="34505" href="2--Paths-and-Identifications.2-7--Propositions.html#34505" class="Function Operator">_orP_</a> <a id="34511" class="Symbol">:</a> <a id="34513" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="34518" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a> <a id="34520" class="Symbol">→</a> <a id="34522" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="34527" href="2--Paths-and-Identifications.2-7--Propositions.html#665" class="Generalizable">ℓ&#39;</a> <a id="34530" class="Symbol">→</a> <a id="34532" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="34537" class="Symbol">(</a><a id="34538" href="Library.Primitive.html#1128" class="Primitive">ℓ-max</a> <a id="34544" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a> <a id="34546" href="2--Paths-and-Identifications.2-7--Propositions.html#665" class="Generalizable">ℓ&#39;</a><a id="34548" class="Symbol">)</a>
<a id="34550" href="2--Paths-and-Identifications.2-7--Propositions.html#34550" class="Bound">A</a> <a id="34552" href="2--Paths-and-Identifications.2-7--Propositions.html#34505" class="Function Operator">orP</a> <a id="34556" href="2--Paths-and-Identifications.2-7--Propositions.html#34556" class="Bound">B</a> <a id="34558" class="Symbol">=</a> <a id="34560" href="2--Paths-and-Identifications.2-7--Propositions.html#30730" class="Datatype Operator">∃</a> <a id="34562" class="Symbol">(</a><a id="34563" href="2--Paths-and-Identifications.2-7--Propositions.html#34550" class="Bound">A</a> <a id="34565" href="1--Type-Theory.1-3--Universes-and-More-Inductive-Types.html#8265" class="Datatype Operator">⊎</a> <a id="34567" href="2--Paths-and-Identifications.2-7--Propositions.html#34556" class="Bound">B</a><a id="34568" class="Symbol">)</a>
</pre>
<p>Here’s how we can justify that this is the correct definition. First
of all, clearly <code>A orP B</code> is always a proposition, via <code class="Agda"><a href="2--Paths-and-Identifications.2-7--Propositions.html#31124" class="Function">isProp-∃</a></code>.
And, it has the correct universal mapping property with respect to
other propositions: <code>P orP Q → R</code> exactly when <code>P → R</code> and <code>Q → R</code>.</p>
<pre class="Agda"><a id="orP-ump-≃"></a><a id="34853" href="2--Paths-and-Identifications.2-7--Propositions.html#34853" class="Function">orP-ump-≃</a> <a id="34863" class="Symbol">:</a> <a id="34865" class="Symbol">{</a><a id="34866" href="2--Paths-and-Identifications.2-7--Propositions.html#34866" class="Bound">P</a> <a id="34868" href="2--Paths-and-Identifications.2-7--Propositions.html#34868" class="Bound">Q</a> <a id="34870" href="2--Paths-and-Identifications.2-7--Propositions.html#34870" class="Bound">R</a> <a id="34872" class="Symbol">:</a> <a id="34874" href="Library.Primitive.html#422" class="Primitive">Type</a> <a id="34879" href="2--Paths-and-Identifications.2-7--Propositions.html#663" class="Generalizable">ℓ</a><a id="34880" class="Symbol">}</a>
  <a id="34884" class="Symbol">→</a> <a id="34886" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="34893" href="2--Paths-and-Identifications.2-7--Propositions.html#34866" class="Bound">P</a> <a id="34895" class="Symbol">→</a> <a id="34897" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="34904" href="2--Paths-and-Identifications.2-7--Propositions.html#34868" class="Bound">Q</a> <a id="34906" class="Symbol">→</a> <a id="34908" href="2--Paths-and-Identifications.2-7--Propositions.html#5867" class="Function">isProp</a> <a id="34915" href="2--Paths-and-Identifications.2-7--Propositions.html#34870" class="Bound">R</a>
  <a id="34919" class="Symbol">→</a> <a id="34921" class="Symbol">(</a><a id="34922" href="2--Paths-and-Identifications.2-7--Propositions.html#34866" class="Bound">P</a> <a id="34924" class="Symbol">→</a> <a id="34926" href="2--Paths-and-Identifications.2-7--Propositions.html#34870" class="Bound">R</a><a id="34927" class="Symbol">)</a> <a id="34929" href="Library.Prelude.html#1692" class="Function Operator">×</a> <a id="34931" class="Symbol">(</a><a id="34932" href="2--Paths-and-Identifications.2-7--Propositions.html#34868" class="Bound">Q</a> <a id="34934" class="Symbol">→</a> <a id="34936" href="2--Paths-and-Identifications.2-7--Propositions.html#34870" class="Bound">R</a><a id="34937" class="Symbol">)</a> <a id="34939" href="2--Paths-and-Identifications.2-2--Equivalences-and-Path-Algebra.html#6026" class="Function Operator">≃</a> <a id="34941" class="Symbol">(</a><a id="34942" href="2--Paths-and-Identifications.2-7--Propositions.html#34866" class="Bound">P</a> <a id="34944" href="2--Paths-and-Identifications.2-7--Propositions.html#34505" class="Function Operator">orP</a> <a id="34948" href="2--Paths-and-Identifications.2-7--Propositions.html#34868" class="Bound">Q</a> <a id="34950" class="Symbol">→</a> <a id="34952" href="2--Paths-and-Identifications.2-7--Propositions.html#34870" class="Bound">R</a><a id="34953" class="Symbol">)</a>
<a id="34955" class="Comment">-- Exercise:</a>
<a id="34968" class="Comment">-- orP-ump-≃ pP pQ pR = {!!}</a>
</pre>  
<h2 id="references-and-further-reading"><a class="header" href="#references-and-further-reading">References and Further Reading</a></h2>
<p>mvrnote:</p>
<ul>
<li>The General Universal Property of the Propositional Truncation, Nicolai Kraus:
https://arxiv.org/abs/1411.2682</li>
</ul>

                  </main>
                  <div class="sidetoc">
                    <nav class="pagetoc"></nav>
                  </div>
                </div>
            </div>
        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>


    </div>
    </body>
</html>
