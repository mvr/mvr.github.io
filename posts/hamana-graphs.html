<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Hamana's Graph GADT</title>

        
        
        <link rel="canonical" href="http://mvr.github.io/posts/hamana-graphs.html" />
        

        <meta property="og:title" content="Hamana's Graph GADT" />
        
        
        <meta property="og:url" content="http://mvr.github.io/posts/hamana-graphs.html" />
        
        <meta property="og:type" content="website" />
        <meta property="og:site_name" content="Mitch is Typing" />
        
        <meta property="og:image" content="http://mvr.github.io/cards/default.png" />
        <meta name="twitter:image" content="http://mvr.github.io/cards/default.png" />
        
        <meta name="twitter:card" content="summary_large_image" />
        <meta name="twitter:title" content="Hamana's Graph GADT" />
        

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP" crossorigin="anonymous">
        <script defer src="../katex.js" crossorigin="anonymous"></script>
        <!-- <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js" integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6" crossorigin="anonymous"></script> -->

        <script>
          document.addEventListener("DOMContentLoaded", function () {
            var mathElements = document.getElementsByClassName("math");
            for (var i = 0; i < mathElements.length; i++) {
              var texText = mathElements[i].firstChild;
              if (mathElements[i].tagName == "SPAN") {
                katex.render(texText.data, mathElements[i], {
                  displayMode: mathElements[i].classList.contains('display'),
                  throwOnError: false,
                  fleqn: false
                });
              }}});
        </script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap" rel="stylesheet">

      <!-- TODO: Some other font candidates. Maybe Nunito? -->
      <!-- <link rel="preconnect" href="https://fonts.googleapis.com"> -->
      <!-- <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> -->
      <!-- <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Nunito:ital,wght@0,200..1000;1,200..1000&family=Raleway:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet"> -->

        <link rel="stylesheet" type="text/css" href="../css/style.css" />

        <link rel="icon" type="image/png" href="../favicon.png" />

        <meta name="LifeViewer" content="lifeviewer textarea 30 hide limit">

        <link rel="alternate" type="application/atom+xml" title="mvr Blog Posts" href="../atom.xml" />
    </head>

    <body>
      <svg style="display: none;">
  <!-- Right Chevron -->
  <symbol id="icon-chevron-right" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
    <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5"></path>
  </symbol>

  <!-- Left Chevron -->
  <symbol id="icon-chevron-left" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
    <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5l-7.5-7.5 7.5-7.5"></path>
  </symbol>
      </svg>
        <!-- <div id="header">
     <a href="/">&#171; Home</a>
     </div> -->

<section class="post">
    <a href="../" id="home-page-link"><svg class="chevron-icon"><use href="#icon-chevron-left"></use></svg> Home</a>
    <h1 class="post-title"><a href="../posts/hamana-graphs.html">Hamana's Graph GADT</a></h1>
<p class="post-deets">February 10, 2018   / <a title="All pages tagged 'note-to-self'." href="../tags/note-to-self.html" rel="tag">note-to-self</a>, <a title="All pages tagged 'code'." href="../tags/code.html" rel="tag">code</a>, <a title="All pages tagged 'retroactive'." href="../tags/retroactive.html" rel="tag">retroactive</a> </p>
<div class="post-content">
    <p>Hamana describes a neat way of encoding general graphs as a GADT in
<a href="https://lmcs.episciences.org/1060">Initial Algebra Semantics for Cyclic Sharing Tree
Structures</a>, a nice trick that I
hadn’t seen before. The idea is that the <code>Graph</code> data type will have a
<code>Ptr</code> constructor that allows us to add an edge reference other parts
of the structure. The <code>Graph</code> type will be indexed by a ‘context’ that
specifies what <code>Ptr</code>s are valid.</p>
<p>Elements of <code>Graph</code> won’t correspond to general graphs exactly. We are
actually describing graphs that are “rooted, connected, directed and
edge-ordered with each node having out-degree 2”. It is possible to
choose different roots and orderings for the same graph, and these
choices will lead to different representations as elements of
<code>Graph</code>. The problem of determining whether two elements of <code>Graph</code>
have the same underlying actual graph seems like it would be difficult
in general.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -fno-warn-unticked-promoted-constructors #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Graphs</span> <span class="kw">where</span></span></code></pre></div>
<p>First, let us define a type describing the possible shapes of our data
structure. We will be using this at the type-level via DataKinds. Our
<code>Graph</code>s all have underlying binary trees.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TreeShape</span> <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LeafShape</span><span class="ot">    ::</span> <span class="dt">TreeShape</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">BinShape</span><span class="ot">     ::</span> <span class="dt">TreeShape</span> <span class="ot">-&gt;</span> <span class="dt">TreeShape</span> <span class="ot">-&gt;</span> <span class="dt">TreeShape</span></span></code></pre></div>
<p>There are also special leaves that are <code>Ptr</code>s to other locations.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">PtrShape</span><span class="ot">     ::</span> <span class="dt">TreeShape</span></span></code></pre></div>
<p>And finally, we will need a way of blocking off a section of a graph
so that a <code>Ptr</code> can’t refer to it.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">VoidShape</span><span class="ot">    ::</span> <span class="dt">TreeShape</span></span></code></pre></div>
<p>This won’t occur as the shape of an actual graph.</p>
<p>The next piece is an indexed type that, given a <code>TreeShape</code>, picks
out the location of a node in that shape. These will be what we use to
specify where in a tree a <code>Ptr</code> is pointing.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TreePosition</span> (<span class="ot">shape ::</span> <span class="dt">TreeShape</span>) <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LeafPos</span><span class="ot">  ::</span> <span class="dt">TreePosition</span> <span class="dt">LeafShape</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">BinPos</span><span class="ot">   ::</span> <span class="dt">TreePosition</span> (<span class="dt">BinShape</span> s t)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LeftPos</span><span class="ot">  ::</span> <span class="dt">TreePosition</span> s <span class="ot">-&gt;</span> <span class="dt">TreePosition</span> (<span class="dt">BinShape</span> s s')</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">RightPos</span><span class="ot"> ::</span> <span class="dt">TreePosition</span> s' <span class="ot">-&gt;</span> <span class="dt">TreePosition</span> (<span class="dt">BinShape</span> s s')</span></code></pre></div>
<p>There is, of course, no constructor for <code>TreePosition VoidShape</code>. We
also don’t allow <code>TreePosition PtrShape</code>, which means that <code>Ptr</code>s
will be required to point to genuine nodes in the tree, and not other
<code>Ptr</code>s. This avoids there being multiple ways of specifying the same
tree via chains of pointers, rather than having each <code>Ptr</code> target the
eventual node at the end of the chain.</p>
<p>We’ll need to be able to index type-level lists, so let’s get that out
of the way:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Elem</span><span class="ot"> ::</span> k <span class="ot">-&gt;</span> [k] <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Here</span><span class="ot"> ::</span> <span class="dt">Elem</span> s (s <span class="op">:</span> c)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">There</span><span class="ot"> ::</span> <span class="dt">Elem</span> s c <span class="ot">-&gt;</span> <span class="dt">Elem</span> s (t <span class="op">:</span> c)</span></code></pre></div>
<p>Now for the actual graph type. The type is indexed both by the <code>shape</code>
of the underlying tree, and a <code>context</code>, a list of <code>TreeShape</code>s. As we
build a tree, this list is collecting the shapes of all the subtrees
used as a left branch of an earlier binary node.</p>
<p>Consider the following tree:</p>
<pre><code>             a
            / \
           /   \
          a     b
         / \   / \
        a   a b   *
               \
                b</code></pre>
<p>If we are currently defining the subtree to be placed at <code>*</code>, then the
<code>context</code> will consist of the two shapes</p>
<pre><code>                      a
         b           / \
        / \         /   \
  [    b   0  ,    a     0   ]
        \         / \
         b       a   a</code></pre>
<p>In the subtree to be placed at <code>*</code>, we may have pointers to <code>a</code>s or <code>b</code>s,
but not the <code>0</code>s.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Graph</span> (<span class="ot">context ::</span> [<span class="dt">TreeShape</span>]) (<span class="ot">shape ::</span> <span class="dt">TreeShape</span>) <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Leaf</span><span class="ot"> ::</span> <span class="dt">Graph</span> c <span class="dt">LeafShape</span></span></code></pre></div>
<p>Leaves are easy, we can have a leaf in any context.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Ptr</span><span class="ot"> ::</span> <span class="dt">Elem</span> s context <span class="ot">-&gt;</span> <span class="dt">TreePosition</span> s <span class="ot">-&gt;</span> <span class="dt">Graph</span> context <span class="dt">PtrShape</span></span></code></pre></div>
<p>For the pointers, we pick a shape from the context and then a position
in that shape.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Bin</span><span class="ot"> ::</span> <span class="dt">Graph</span> (<span class="dt">BinShape</span> <span class="dt">VoidShape</span> <span class="dt">VoidShape</span> <span class="op">:</span> c) s</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>      <span class="ot">-&gt;</span> <span class="dt">Graph</span> (<span class="dt">BinShape</span> s <span class="dt">VoidShape</span> <span class="op">:</span> c) t</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>      <span class="ot">-&gt;</span> <span class="dt">Graph</span> c (<span class="dt">BinShape</span> s t)</span></code></pre></div>
<p>The interesting case is a binary node. In the left and right branches,
we push new trees onto the context c. When defining the left branch,
we only have access to one additional node over what is already in
<code>c</code>: the binary node we are currently defining. In the right branch,
we have access to the entire left branch: note that the shape <code>s</code> of
the left branch is what is pushed onto the context. This is why this
type has to be indexed over the shape of the resulting graph, not just
the context.</p>
<p>And that’s it! We can add labels to the nodes in the graph if we like,
by adding a parameter to the <code>Leaf</code> and <code>Bin</code> constructors.</p>
<p>Graphs of shape <code>s</code> then correspond to elements of <code>Graph '[] s</code>. If
we don’t care about having the shape as part of the type, we can
existentially quantify it.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AnyGraph</span> <span class="ot">=</span> <span class="kw">forall</span> s<span class="op">.</span> <span class="dt">AnyGraph</span> (<span class="dt">Graph</span> '[] s)</span></code></pre></div>
<p>Here are some simple graphs:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">graph1 ::</span> <span class="dt">AnyGraph</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>graph1 <span class="ot">=</span> <span class="dt">AnyGraph</span> <span class="op">$</span> <span class="dt">Bin</span> (<span class="dt">Bin</span> <span class="dt">Leaf</span> <span class="dt">Leaf</span>) (<span class="dt">Bin</span> (<span class="dt">Ptr</span> (<span class="dt">There</span> <span class="op">$</span> <span class="dt">Here</span>) (<span class="dt">LeftPos</span> <span class="op">$</span> <span class="dt">LeftPos</span> <span class="op">$</span> <span class="dt">LeafPos</span>)) <span class="dt">Leaf</span>)</span></code></pre></div>
<p>Corresponding to</p>
<pre><code>     *
    / \
   /   \
  *     *
 / \   / \
*   * /   *
 \   /
  ---</code></pre>
<p>We can modify what kinds of graphs are representable by changing the
way the <code>context</code> is extended. Note that we can currently have cycles
in the graph:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">graph2 ::</span> <span class="dt">AnyGraph</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>graph2 <span class="ot">=</span> <span class="dt">AnyGraph</span> <span class="op">$</span> <span class="dt">Bin</span> <span class="dt">Leaf</span> (<span class="dt">Ptr</span> <span class="dt">Here</span> <span class="dt">BinPos</span>)</span></code></pre></div>
<p>corresponds to</p>
<pre><code>    ---
   /   \
  *    /
 / \  /
*   --</code></pre>
<p>It’s not hard to change this though:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DAG</span> (<span class="ot">context ::</span> [<span class="dt">TreeShape</span>]) (<span class="ot">shape ::</span> <span class="dt">TreeShape</span>) <span class="kw">where</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">DAGLeaf</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">DAG</span> c <span class="dt">LeafShape</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">DAGPtr</span><span class="ot"> ::</span> <span class="dt">Elem</span> s context <span class="ot">-&gt;</span> <span class="dt">TreePosition</span> s <span class="ot">-&gt;</span> <span class="dt">DAG</span> context <span class="dt">PtrShape</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">DAGBin</span><span class="ot"> ::</span> <span class="dt">DAG</span> c s <span class="ot">-&gt;</span> <span class="dt">DAG</span> (s <span class="op">:</span> c) t <span class="ot">-&gt;</span> <span class="dt">DAG</span> c (<span class="dt">BinShape</span> s t)</span></code></pre></div>
<p>The only difference is in the <code>DAGBin</code> constructor. Here, when
constructing the left branch, we are no longer permitted to reference
the current binary node. The same is true when constructing the right
branch, but we still give it access to the left branch. The result is
that every <code>Ptr</code> points to something to the left, other than a direct
ancestor of the current node. That is enough to rule out any cycles.</p>
<p>We have no need for <code>VoidShape</code> here, which is nice.</p>
</div>

</section>

        <footer>
          Please <a href="mailto:mitchell.v.riley@gmail.com">email</a> me any comments or suggestions. Site built using <a href="https://jaspervdj.be/hakyll/">Hakyll</a>, source on <a href="https://github.com/mvr/mvr.github.io">Github</a>. <!-- Some design elements cribbed from <a href="https://github.com/coletownsend/balzac-for-jekyll">Cole Townsend</a>. -->
        </footer>

    </body>
</html>
