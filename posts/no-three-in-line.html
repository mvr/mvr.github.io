<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>No‑Three‑In‑Line</title>

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP" crossorigin="anonymous">
        <script defer src="../katex.js" crossorigin="anonymous"></script>
        <!-- <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js" integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6" crossorigin="anonymous"></script> -->

        <script>
          document.addEventListener("DOMContentLoaded", function () {
            var mathElements = document.getElementsByClassName("math");
            for (var i = 0; i < mathElements.length; i++) {
              var texText = mathElements[i].firstChild;
              if (mathElements[i].tagName == "SPAN") {
                katex.render(texText.data, mathElements[i], {
                  displayMode: mathElements[i].classList.contains('display'),
                  throwOnError: false,
                  fleqn: false
                });
              }}});
        </script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap" rel="stylesheet">

      <!-- TODO: Some other font candidates. Maybe Nunito? -->
      <!-- <link rel="preconnect" href="https://fonts.googleapis.com"> -->
      <!-- <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin> -->
      <!-- <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Nunito:ital,wght@0,200..1000;1,200..1000&family=Raleway:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet"> -->

        <link rel="stylesheet" type="text/css" href="../css/style.css" />

        <link rel="icon" type="image/png" href="../favicon.png" />

        <meta name="LifeViewer" content="lifeviewer textarea 30 hide limit">

        <link rel="alternate" type="application/atom+xml" title="mvr Blog Posts" href="../atom.xml" />
    </head>

    <body>
      <svg style="display: none;">
  <!-- Right Chevron -->
  <symbol id="icon-chevron-right" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
    <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5"></path>
  </symbol>

  <!-- Left Chevron -->
  <symbol id="icon-chevron-left" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
    <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5l-7.5-7.5 7.5-7.5"></path>
  </symbol>
      </svg>
        <!-- <div id="header">
     <a href="/">&#171; Home</a>
     </div> -->

<section class="post">
    <a href="../" id="home-page-link"><svg class="chevron-icon"><use href="#icon-chevron-left"></use></svg> Home</a>
    <h1 class="post-title"><a href="../posts/no-three-in-line.html">No‑Three‑In‑Line</a></h1>
<p class="post-deets">September  1, 2025   / <a title="All pages tagged 'code'." href="../tags/code.html" rel="tag">code</a>, <a title="All pages tagged 'cuda'." href="../tags/cuda.html" rel="tag">cuda</a> </p>
<div class="post-content">
    <script defer src="../life/lv-plugin.js"></script>
<p>The <a href="https://en.wikipedia.org/wiki/No-three-in-line_problem">No-three-in-line
problem</a> asks
how many points can be placed on a <span class="math inline">n \times n</span> grid so that no three
points are on the same line, where the lines considered are of any
slope and not just orthogonal and diagonal. Each row/column can
contain at most 2 points, so clearly the answer is at most <span class="math inline">2n</span>. The
real question is, can we actually achieve <span class="math inline">2n</span> for every grid size?
It’s <a href="https://doi.org/10.4153%2FCMB-1968-062-3">conjectured</a> that the
answer is “no” for grids large enough, but we don’t know where the
crossover point is and there’s <a href="http://web.archive.org/web/20131027174807/http://wso.williams.edu/~bchaffin/no_three_in_line/index.htm">no
indication</a>
that the number of <span class="math inline">2n</span>-point solutions is falling away from
exponential growth, at least up to <span class="math inline">18 \times 18</span>!</p>
<p>To my eye, the configurations that work can be quite balanced and
attractive. Here are some symmetrical ones for <span class="math inline">14 \times 14</span> (though
in general the solutions are not necessarily symmetric in this way):</p>
<div class="lifeviewer"><textarea>
x = 54, y = 14, rule = LifeHistory
5BA3BA4B6.5BA3BA4B6.5BA3BA4B$3BA3BA6B6.3BABA8B6.6BA3BA3B$8BABA3B6.9B
2A3B6.5BA3BA4B$2BA9BAB6.2BA9BAB6.BA4BA7B$A5BA7B6.ABA11B6.ABA11B$2BA
10BA6.12B2A6.11BABA$BA7BA4B6.6B2A6B6.10BABAB$4BA7BAB6.6B2A6B6.BABA10B
$A10BA2B6.2A12B6.ABA11B$7BA5BA6.11BABA6.11BABA$BA9BA2B6.BA9BA2B6.7BA
4BAB$3BABA8B6.3B2A9B6.4BA3BA5B$6BA3BA3B6.8BABA3B6.3BA3BA6B$4BA3BA5B6.
4BA3BA5B6.4BA3BA5B!

#C [[ ZOOM 8 ]]
#C Colours are set in src/LifeViewer.hs
#C [[ NOGUI ]]
#C [[ COLOR BACKGROUND #f8f8f8 ]]
#C [[ COLOR ALIVE #000000 ]]
#C [[ COLOR ALIVERAMP #000000 ]]
#C [[ COLOR DEADRAMP #dfebf6 ]]
#C [[ COLOR GRID #f0f0f0 ]]
#C [[ GRID ]]
#C [[ GRIDMAJOR 0 ]]
#C [[ COLOR HISTORY #dfebf6 ]]
#C [[ COLOR MARK1 #803300 ]]
#C [[ COLOR MARKOFF #e0ae8f ]]
</textarea>
<canvas width="600px"></canvas>
</div>

<p>The most extensive searches for configurations so far have been done
by <a href="http://wwwhomes.uni-bielefeld.de/achim/no3in/readme.html">Achim
Flammenkamp</a>
and later by <a href="https://benchaffin.com/">Ben Chaffin</a>. I’ve <a href="https://github.com/mvr/no-three-in-line">written
some CUDA code</a><span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle" /><span class="sidenote">By the way,
the existing <code>cuda-mode</code> for Emacs is a bit messed up, I have a fork
with some bugfixes <a href="https://github.com/mvr/cuda-mode">here</a>.<br />
<br />
</span></span> of my
own with the goal of pushing things a little further, and I’ll explain
it in the rest of this post.</p>
<!--more-->
<h2 id="general-strategy">General Strategy</h2>
<p>We’ll be doing a simple depth-first search over configurations,
storing a stack in device memory that the CUDA kernel interacts with.
Each configuration consists of two bitboards: one for cells known to
contain a point and another for cells known to be empty. On each
search step, we’ll propagate as much information as we can in the
given configuration. If we don’t reach a contradiction, we’ll use a
heuristic to choose a row or column, and branch on all possibilities
for the locations of the points in that row.</p>
<p>To avoid repeating work, we’ll also check that the configuration is in
a canonical orientation. Here, that means it’s lexicographically
earliest out of all members in its symmetry orbit. If not, we just
discard the configuration. Doing this check accurately is slightly
less straightforward than it sounds, because of cells whose state is
still unknown.</p>
<p>As we did<span class="sidenote-wrapper"><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle" /><span class="sidenote">Or rather, as APG
<a href="https://gitlab.com/apgoucher/lifelib/-/blob/master/cuda2/cudagol.h">did</a>.<br />
<br />
</span></span>
when representing <a href="../posts/cool-still-lifes.html">Game of Life
configurations</a> on the GPU, we’re going
to be representing a <span class="math inline">32 \times 32</span> board by storing a single
<code>uint32_t</code> per thread, each representing a single row. Across the 32
threads in a warp (which we might imagine stacked vertically), these
values represent the whole board.<span class="sidenote-wrapper"><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle" /><span class="sidenote">In this problem we’ll only be using
a <span class="math inline">n \times n</span> subset of the full <span class="math inline">32 \times 32</span> board available, but
trying to be more lane-efficient here would be hugely complex for
almost no gain.<br />
<br />
</span></span> There are a handful of warp-level primitives that
make manipulating such boards easy. We just have to make sure that
execution stays synchronised across the warp at all times or it will
hang.</p>
<p>For example, we can test whether a board is empty by checking whether
all rows are empty, using a ballot:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> empty <span class="op">=</span> __ballot_sync<span class="op">(</span><span class="bn">0xffffffff</span><span class="op">,</span> state<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div>
<p>And we can find the first set bit in a board by doing a ballot to
find the first nonempty row, and then using a shuffle to broadcast the
position in that row to all the other threads.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> x <span class="op">=</span> __ffs<span class="op">(</span>state<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">uint32_t</span> mask <span class="op">=</span> __ballot_sync<span class="op">(</span><span class="bn">0xffffffff</span><span class="op">,</span> state<span class="op">);</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> y <span class="op">=</span> __ffs<span class="op">(</span>mask<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> __shfl_sync<span class="op">(</span><span class="bn">0xffffffff</span><span class="op">,</span> x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> <span class="op">{</span>x<span class="op">,</span> y<span class="op">};</span></span></code></pre></div>
<h2 id="propagating-orthogonally">Propagating Orthogonally</h2>
<p>The simplest information propagation we’ll be doing is setting forced
values in each row and column. This can be done in two complementary
situations:</p>
<ul>
<li>If the row/column contains <span class="math inline">2</span> known points already, the rest of the
row must be empty.</li>
<li>If the row/column contains <span class="math inline">n-2</span> known empty cells, the two
remaining cells must contain points.</li>
</ul>
<p>For rows, this is straightforward. Each thread can use the <code>__popc</code>
primitive to count the number of points in its row directly. Columns
are more expensive, because we need to count across threads.</p>
<p>A small binary counter is enough: we use two bits to count <span class="math inline">0,1,2,3</span>,
and another bit to record overflow for any count higher than that. We
can then tree-reduce the binary counter across the warp, to do 5
rounds of additions rather than 32. Each “bit” here is actually
represented again as a <code>uint32_t</code>, considering that 32-bit value as a
bit-vector with one position for each column. We have to do two binary
counts: one to count the known points (and force accordingly), and one
to count the not-known-empty cells (and force accordingly).</p>
<p>Unfortunately, we can’t force values based on lines of other slopes:
there’s no requirement for these lines to contain exactly two points
each. In principle this kind of counting could still be useful though.
For example, each diagonal line can contain at most two points, so if
we tally up the number of available positions on each diagonal,
clamped at a maximum of 2 per line, we might be able to determine
early that a position is not completable even if each row and column
individually looks alright.<span class="sidenote-wrapper"><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle" /><span class="sidenote">There are <span class="math inline">2n-1</span> diagonal lines
in each direction compared with <span class="math inline">n</span> orthogonal lines, so a lot more
“room” to fit points in.<br />
<br />
</span></span> But after some experiments, it seems doing
this check is not a time improvement.</p>
<h2 id="eliminating-lines">Eliminating Lines</h2>
<p>The above handles orthogonal lines, but we also have to update the
known-empty cells caused by lines of all other slopes. I couldn’t come
up with an efficient way to do this simultaneously for all points, as
we did for the orthogonal lines<span class="sidenote-wrapper"><label for="sn-4" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-4" class="margin-toggle" /><span class="sidenote">But maybe there’s a better way to do
it, please let me know!<br />
<br />
</span></span>. For each new point, we handle the lines
through all other points one by one.</p>
<p>So let’s suppose two points <span class="math inline">p = (p_0, p_1)</span>, <span class="math inline">q = (q_0, q_1)</span>, and
let’s say that <span class="math inline">p</span> is above <span class="math inline">q</span>, so <span class="math inline">p_1 &lt; q_1</span><span class="sidenote-wrapper"><label for="sn-5" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-5" class="margin-toggle" /><span class="sidenote">We’ve already handled
the case where two points are in the same row.<br />
<br />
</span></span>. The first step is to
bring <span class="math inline">q</span> as close as possible to <span class="math inline">p</span> on the same line, because we
don’t want to accidentally miss the points <em>between</em> <span class="math inline">p</span> and <span class="math inline">q</span>:</p>
<div class="lifeviewer"><textarea>
x = 34, y = 14, rule = LifeHistory
3BD10B6.3BD10B$14B6.14B$4BA9B6.4BA9B$14B6.14B$5BD8B6.5BA8B$14B6.14B$
6BD7B6.6BD7B$14B6.14B$7BA6B6.7BD6B$14B6.14B$8BD5B6.8BD5B$14B6.14B$9BD
4B6.9BD4B$14B6.14B!

#C [[ ZOOM 10 ]]
#C Colours are set in src/LifeViewer.hs
#C [[ NOGUI ]]
#C [[ COLOR BACKGROUND #f8f8f8 ]]
#C [[ COLOR ALIVE #000000 ]]
#C [[ COLOR ALIVERAMP #000000 ]]
#C [[ COLOR DEADRAMP #dfebf6 ]]
#C [[ COLOR GRID #f0f0f0 ]]
#C [[ GRID ]]
#C [[ GRIDMAJOR 0 ]]
#C [[ COLOR HISTORY #dfebf6 ]]
#C [[ COLOR MARK1 #803300 ]]
#C [[ COLOR MARKOFF #e0ae8f ]]
</textarea>
<canvas width="600px"></canvas>
</div>

<p>That is, we scale <span class="math inline">\Delta = (q_0-p_0, q_1-p_1)</span> down by <span class="math inline">\gcd(q_0-p_0,
q_1-p_1)</span>. We can avoid doing this expensive calculation for each line
by precomputing a table of <span class="math inline">x / \gcd(x, y)</span> for all <span class="math inline">0 \leq x,y &lt; n</span>
and storing it in the device’s constant memory, which is pretty quick
to read.</p>
<p>So far the same calculation has been done in all threads. Now, each
thread checks whether its row contains a point on the line<span class="sidenote-wrapper"><label for="sn-6" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-6" class="margin-toggle" /><span class="sidenote">Again, by
assumption the line is not horizontal, so at most one point in each
row is on the line.<br />
<br />
</span></span>. Not all rows will, because for some rows the
line falls between integer points (as in the example above). If the
row does contain a point, a little algebra gives us which bit needs to
be set. It doesn’t seem possible to avoid integer division/modulus
here, unfortunately.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> p_quo <span class="op">=</span> p<span class="op">.</span>second <span class="op">/</span> delta<span class="op">.</span>second<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> p_rem <span class="op">=</span> p<span class="op">.</span>second <span class="op">%</span> delta<span class="op">.</span>second<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> row <span class="op">=</span> threadIdx<span class="op">.</span>x <span class="op">&amp;</span> <span class="dv">31</span><span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>row <span class="op">%</span> delta<span class="op">.</span>second <span class="op">==</span> p_rem<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> col <span class="op">=</span> p<span class="op">.</span>first <span class="op">+</span> <span class="op">((</span><span class="dt">int</span><span class="op">)(</span>row <span class="op">/</span> delta<span class="op">.</span>second<span class="op">)</span> <span class="op">-</span> p_quo<span class="op">)</span> <span class="op">*</span> delta<span class="op">.</span>first<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>col <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> col <span class="op">&lt;</span> <span class="dv">32</span><span class="op">)</span> </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    state <span class="op">|=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> col<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co">// We don't want to eliminate the original points...</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>p<span class="op">.</span>second <span class="op">==</span> row <span class="op">||</span> q<span class="op">.</span>second <span class="op">==</span> row<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  state <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>There are a couple of ways to speed this up. First, we can avoid the
integer divisions completely in the case that <code>delta.second</code> is a
power of two. Rather than writing out special cases by hand, we can
give the compiler some strong encouragement to do it for us:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="cf">switch</span> <span class="op">(</span>delta<span class="op">.</span>second<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="dv">1</span><span class="op">:</span>  <span class="cf">return</span> eliminate_line_inner<span class="op">(</span>p<span class="op">,</span> q<span class="op">,</span> <span class="op">{</span>delta<span class="op">.</span>first<span class="op">,</span> <span class="dv">1</span><span class="op">});</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="dv">2</span><span class="op">:</span>  <span class="cf">return</span> eliminate_line_inner<span class="op">(</span>p<span class="op">,</span> q<span class="op">,</span> <span class="op">{</span>delta<span class="op">.</span>first<span class="op">,</span> <span class="dv">2</span><span class="op">});</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="cf">case</span> <span class="dv">4</span><span class="op">:</span>  <span class="cf">return</span> eliminate_line_inner<span class="op">(</span>p<span class="op">,</span> q<span class="op">,</span> <span class="op">{</span>delta<span class="op">.</span>first<span class="op">,</span> <span class="dv">4</span><span class="op">});</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="cf">default</span><span class="op">:</span> <span class="cf">return</span> eliminate_line_inner<span class="op">(</span>p<span class="op">,</span> q<span class="op">,</span> delta<span class="op">);</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Second, we can do some early filtering on the pairs of points that we
need to consider. If <span class="math inline">\Delta</span> is large enough then additional points
in either direction will be off the edge of the grid, so we can skip
processing that line entirely. This applies so long as there are no
points between, which is again determined by calculating the GCD of
the coordinates of <span class="math inline">\Delta</span>.</p>
<div class="lifeviewer"><textarea>
x = 34, y = 22, rule = LifeHistory
2.D$22.D3$14B6.3BD10B$14B6.14B$14B6.14B$4BA9B6.4BA9B$14B6.14B$14B6.
14B$14B6.5BD8B$14B6.14B$14B6.14B$14B6.6BA7B$6BA7B6.14B$14B6.14B$14B6.
7BD6B$14B6.14B2$28.D2$8.D!

#C [[ ZOOM 8 ]]
#C Colours are set in src/LifeViewer.hs
#C [[ NOGUI ]]
#C [[ COLOR BACKGROUND #f8f8f8 ]]
#C [[ COLOR ALIVE #000000 ]]
#C [[ COLOR ALIVERAMP #000000 ]]
#C [[ COLOR DEADRAMP #dfebf6 ]]
#C [[ COLOR GRID #f0f0f0 ]]
#C [[ GRID ]]
#C [[ GRIDMAJOR 0 ]]
#C [[ COLOR HISTORY #dfebf6 ]]
#C [[ COLOR MARK1 #803300 ]]
#C [[ COLOR MARKOFF #e0ae8f ]]
</textarea>
<canvas width="600px"></canvas>
</div>

<p>For this, we precompute a mask giving all “relevant” endpoints for a
line with one point at <span class="math inline">(0, 0)</span>. When processing a new point, we first
use this mask (appropriately shifted) to restrict to the second
endpoints we need to worry about.</p>
<p>In case you’re curious, here’s how that mask looks for <span class="math inline">13 \times 13</span>:</p>
<div class="lifeviewer"><textarea>
x = 25, y = 25, rule = LifeHistory
AB3ABAB3A3B3ABAB3ABA$BA21BAB$ABABAB3ABA3BAB3ABABABA$A2BA2BA2BA5BA2BA
2BA2BA$ABABABABABA3BABABABABABA$5BA13BA5B$AB3AB6AB6AB3ABA$2BA3B6AB6A
3BA2B$ABABAB6AB6ABABABA$A2BA2B6AB6A2BA2BA$ABABAB6AB6ABABABA$6B6AB6A6B
$25B$6B6AB6A6B$ABABAB6AB6ABABABA$A2BA2B6AB6A2BA2BA$ABABAB6AB6ABABABA$
2BA3B6AB6A3BA2B$AB3AB6AB6AB3ABA$5BA13BA5B$ABABABABABA3BABABABABABA$A
2BA2BA2BA5BA2BA2BA2BA$ABABAB3ABA3BAB3ABABABA$BA21BAB$AB3ABAB3A3B3ABAB
3ABA!

#C [[ ZOOM 8 ]]
#C Colours are set in src/LifeViewer.hs
#C [[ NOGUI ]]
#C [[ COLOR BACKGROUND #f8f8f8 ]]
#C [[ COLOR ALIVE #000000 ]]
#C [[ COLOR ALIVERAMP #000000 ]]
#C [[ COLOR DEADRAMP #dfebf6 ]]
#C [[ COLOR GRID #f0f0f0 ]]
#C [[ GRID ]]
#C [[ GRIDMAJOR 0 ]]
#C [[ COLOR HISTORY #dfebf6 ]]
#C [[ COLOR MARK1 #803300 ]]
#C [[ COLOR MARKOFF #e0ae8f ]]
</textarea>
<canvas width="600px"></canvas>
</div>

<p>So only 304/625 of the time do we need to actually process a pair of
points.</p>
<h2 id="branching-and-vulnerable-cells">Branching and Vulnerable Cells</h2>
<p>The remaining piece of the puzzle is how we choose what to branch on
once we’ve propagated all the information we can. One observation is
that for the typical cell, placing a point in that cell provides a lot
more information than assuming the cell is empty. If it contains a
point, the lines through that point are likely to rule out a handful
of other cells, whereas if empty, we’ve learned very little.</p>
<p>But for some unknown cells, learning that cell is empty causes a
<em>different</em> cell to contain a point, via the orthogonal forcing
detailed earlier. This happens when a row/column has zero points and
three unknowns, or when a row/column has one point already and two
unknowns. These cells I’m calling “vulnerable”, and they’re more
promising to branch on.</p>
<p>Here’s the best strategy I’ve been able to come up with, just fiddling
with some different options:</p>
<ul>
<li>If there are any vulnerable cells, choose the one closest to the
centre of the board and branch on whether it contains a point.</li>
<li>Otherwise, find the row (not column!) with the fewest options for
where its points can go and branch on each possibility.</li>
</ul>
<p>I’m not sure why preferring to always branch along the same axis works
much better than, say, always taking the row or column with fewest
unknown cells, but empirically it’s the case. This makes me think
there’s a lot about the structure of this search problem that I don’t
understand.</p>
<p>Again for the curious, here are some typical mid-search
configurations, where the red cells are ones which have been
definitively ruled out. Is there an obvious “tell” for these that
makes clear they’re not completable? I don’t see one.</p>
<div class="lifeviewer"><textarea>
x = 54, y = 14, rule = LifeHistory
11DADA6.11DADA6.11DADA$5DADA6D6.2DBD4BDB4D6.4DADA7D$B5DB5DAD6.2DBD4BD
2B3D6.4DA3DA5D$3BA2DB7D6.2DBDB2DB6D6.6DB4DBDB$3DA8DAD6.4D3B3DB3D6.D2A
11D$B3DBD2B6D6.2DBD3B3DB3D6.9DBD3B$2DB4D2B4DA6.A11DAD6.3DA2D2BD2BD2B$
A9DA3D6.A11DAD6.DA10DAD$8DADA3D6.6DADA5D6.A2DA10D$3B5DB5D6.DA6DA5D6.
7DBD5B$5DA5DA2D6.3DA7DA2D6.6DB2DBD3B$2B2DB3DB5D6.DA11DA6.5DADB2DBD2B$
6DA2DA4D6.3DA5DA4D6.A7DA5D$D2BDB2DBDA4D6.4DA2DA6D6.2DA2DA8D!

#C [[ ZOOM 8 ]]
#C Colours are set in src/LifeViewer.hs
#C [[ NOGUI ]]
#C [[ COLOR BACKGROUND #f8f8f8 ]]
#C [[ COLOR ALIVE #000000 ]]
#C [[ COLOR ALIVERAMP #000000 ]]
#C [[ COLOR DEADRAMP #dfebf6 ]]
#C [[ COLOR GRID #f0f0f0 ]]
#C [[ GRID ]]
#C [[ GRIDMAJOR 0 ]]
#C [[ COLOR HISTORY #dfebf6 ]]
#C [[ COLOR MARK1 #803300 ]]
#C [[ COLOR MARKOFF #e0ae8f ]]
</textarea>
<canvas width="600px"></canvas>
</div>

<p>On my <a href="https://www.nvidia.com/en-us/autonomous-machines/embedded-systems/jetson-orin/nano-super-developer-kit/">toy
machine</a>,
here’s how long it takes to enumerate all configurations of a given
size.</p>
<table>
<thead>
<tr>
<th>Size</th>
<th>Time (s)</th>
</tr>
</thead>
<tbody>
<tr>
<td>12</td>
<td>13.5</td>
</tr>
<tr>
<td>13</td>
<td>65</td>
</tr>
<tr>
<td>14</td>
<td>1231</td>
</tr>
<tr>
<td>15</td>
<td>15672</td>
</tr>
</tbody>
</table>
<p>Extrapolating outwards, redoing the <a href="http://web.archive.org/web/20131027174807/http://wso.williams.edu/~bchaffin/no_three_in_line/index.htm">existing
calculation</a>
for <span class="math inline">18 \times 18</span> would take around 9 months. To push ahead to <span class="math inline">19
\times 19</span>, I’m going to need better ideas or a better machine.</p>
<p>This is a good place to stop.</p>
</div>

</section>

        <footer>
          Please <a href="mailto:mitchell.v.riley@gmail.com">email</a> me any comments or suggestions. Site built using <a href="https://jaspervdj.be/hakyll/">Hakyll</a>, source on <a href="https://github.com/mvr/mvr.github.io">Github</a>. <!-- Some design elements cribbed from <a href="https://github.com/coletownsend/balzac-for-jekyll">Cole Townsend</a>. -->
        </footer>

    </body>
</html>
